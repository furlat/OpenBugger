["def twoSum(nums, target):\n    map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in map:\n            return [map[complement], i]\n        map[num] = i\n    return []", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef addTwoNumbers(l1, l2):\n    dummy = ListNode(0)\n    current = dummy\n    carry = 0\n\n    while l1 or l2 or carry:\n        sum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\n        carry = sum_val // 10\n        current.next = ListNode(sum_val % 10)\n        current = current.next\n\n        if l1: l1 = l1.next\n        if l2: l2 = l2.next\n\n    return dummy.next", "def length_of_longest_substring(s: str) -> int:\n    left = 0\n    right = 0\n    max_length = 0\n    characters = set()\n\n    while right < len(s):\n        if s[right] not in characters:\n            characters.add(s[right])\n            max_length = max(max_length, right - left + 1)\n            right += 1\n        else:\n            characters.remove(s[left])\n            left += 1\n\n    return max_length", "def findMedianSortedArrays(nums1, nums2):\n    if len(nums1) > len(nums2):\n        return findMedianSortedArrays(nums2, nums1)\n    \n    x, y = len(nums1), len(nums2)\n    low, high = 0, x\n\n    while low <= high:\n        partition_x = (low + high) // 2\n        partition_y = (x + y + 1) // 2 - partition_x\n\n        max_left_x = float('-inf') if partition_x == 0 else nums1[partition_x - 1]\n        min_right_x = float('inf') if partition_x == x else nums1[partition_x]\n\n        max_left_y = float('-inf') if partition_y == 0 else nums2[partition_y - 1]\n        min_right_y = float('inf') if partition_y == y else nums2[partition_y]\n\n        if max_left_x <= min_right_y and max_left_y <= min_right_x:\n            if (x + y) % 2 == 0:\n                return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2\n            else:\n                return max(max_left_x, max_left_y)\n        elif max_left_x > min_right_y:\n            high = partition_x - 1\n        else:\n            low = partition_x + 1\n    \n    return 0", "def longest_palindromic_substring(s: str) -> str:\n    n = len(s)\n    if n == 0: return \"\"\n\n    start, max_length = 0, 1\n\n    for i in range(n):\n        l, r = i, i\n\n        while r < n - 1 and s[r] == s[r + 1]:\n            r += 1\n        i = r\n\n        while l > 0 and r < n - 1 and s[l - 1] == s[r + 1]:\n            l -= 1\n            r += 1\n\n        length = r - l + 1\n        if length > max_length:\n            start, max_length = l, length\n\n    return s[start:start + max_length]", "def convert(s: str, numRows: int) -> str:\n    if numRows == 1 or numRows >= len(s):\n        return s\n\n    rows = [\"\"] * numRows\n    curRow = 0\n    goingDown = False\n\n    for c in s:\n        rows[curRow] += c\n        if curRow == 0 or curRow == numRows - 1:\n            goingDown = not goingDown\n        curRow += 1 if goingDown else -1\n\n    return \"\".join(rows)", "def reverse(x: int) -> int:\n    sign = -1 if x < 0 else 1\n    x = abs(x)\n    res = 0\n    while x:\n        res = res * 10 + x % 10\n        x //= 10\n    res *= sign\n    return res if -2**31 <= res <= 2**31 - 1 else 0", "def myAtoi(s):\n    result, i, sign = 0, 0, 1\n    while i < len(s) and s[i] == ' ': i += 1\n    if i < len(s) and (s[i] == '-' or s[i] == '+'):\n        sign = -1 if s[i] == '-' else 1\n        i += 1\n    while i < len(s) and s[i].isdigit():\n        result = result * 10 + int(s[i])\n        i += 1\n        if result * sign > 2**31 - 1: return 2**31 - 1\n        if result * sign < -2**31: return -2**31\n    return result * sign", "def is_palindrome(x: int) -> bool:\n    if x < 0:\n        return False\n    original, reversed = x, 0\n    while x > 0:\n        reversed = reversed * 10 + x % 10\n        x //= 10\n    return original == reversed", "def is_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        if p[j - 1] == '*' and dp[0][j - 2]:\n            dp[0][j] = True\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                dp[i][j] = dp[i - 1][j - 1]\n            elif p[j - 1] == '*':\n                dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))\n\n    return dp[m][n]", "def max_area(height):\n    max_area, left, right = 0, 0, len(height) - 1\n    while left < right:\n        max_area = max(max_area, min(height[left], height[right]) * (right - left))\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area", "def int_to_roman(num):\n    romans = [\n        (1000, \"M\"), (900, \"CM\"), (500, \"D\"),\n        (400, \"CD\"), (100, \"C\"), (90, \"XC\"),\n        (50, \"L\"), (40, \"XL\"), (10, \"X\"), \n        (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")\n    ]\n    roman = \"\"\n    for value, symbol in romans:\n        while num >= value:\n            roman += symbol\n            num -= value\n    return roman", "def roman_to_int(s):\n    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    prev_value = 0\n    \n    for c in s:\n        current_value = roman_values[c]\n        if current_value > prev_value:\n            total += current_value - 2 * prev_value\n        else:\n            total += current_value\n        prev_value = current_value\n\n    return total", "def longest_common_prefix(strs):\n    if not strs:\n        return \"\"\n\n    for i, c in enumerate(strs[0]):\n        for j in range(1, len(strs)):\n            if i == len(strs[j]) or strs[j][i] != c:\n                return strs[0][:i]\n    return strs[0]", "def threeSum(nums):\n    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 2):\n        if i == 0 or nums[i] != nums[i - 1]:\n            j, k = i + 1, len(nums) - 1\n            while j < k:\n                s = nums[i] + nums[j] + nums[k]\n                if s == 0:\n                    result.append([nums[i], nums[j], nums[k]])\n                    while j < k and nums[j] == nums[j + 1]:\n                        j += 1\n                    while j < k and nums[k] == nums[k - 1]:\n                        k -= 1\n                    j += 1\n                    k -= 1\n                elif s < 0:\n                    j += 1\n                else:\n                    k -= 1\n\n    return result", "def threeSumClosest(nums, target):\n    nums.sort()\n    closest = sum(nums[:3])\n    for i in range(len(nums) - 2):\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            cur_sum = nums[i] + nums[left] + nums[right]\n            if cur_sum == target:\n                return cur_sum\n            if abs(target - cur_sum) < abs(target - closest):\n                closest = cur_sum\n            if cur_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return closest", "def letter_combinations(digits: str):\n    if not digits: return []\n    phone = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\n    result = [\"\"]\n\n    for digit in digits:\n        temp = []\n        for s in result:\n            for c in phone[int(digit) - 2]:\n                temp.append(s + c)\n        result = temp\n\n    return result", "def fourSum(nums, target):\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 3):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        for j in range(i + 1, len(nums) - 2):\n            if j > i + 1 and nums[j] == nums[j - 1]:\n                continue\n            left = j + 1\n            right = len(nums) - 1\n            while left < right:\n                cur_sum = nums[i] + nums[j] + nums[left] + nums[right]\n                if cur_sum == target:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    left += 1\n                    right -= 1\n                    while left < right and nums[left] == nums[left - 1]: left += 1\n                    while left < right and nums[right] == nums[right + 1]: right -= 1\n                elif cur_sum < target:\n                    left += 1\n                else:\n                    right -= 1\n    return result", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef removeNthFromEnd(head, n):\n    first = head\n    second = head\n    \n    for i in range(n):\n        first = first.next\n    \n    if not first:\n        head = head.next\n        return head\n    \n    while first.next:\n        first = first.next\n        second = second.next\n    \n    second.next = second.next.next\n    \n    return head", "def is_valid(s: str) -> bool:\n    stack = []\n\n    for c in s:\n        if c in '([{':\n            stack.append(c)\n        else:\n            if not stack:\n                return False\n            if c == ')' and stack[-1] != '(':\n                return False\n            if c == '}' and stack[-1] != '{':\n                return False\n            if c == ']' and stack[-1] != '[':\n                return False\n            stack.pop()\n\n    return not stack", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n         \ndef merge_two_lists(list1, list2):\n    if list1 is None:\n        return list2\n    if list2 is None:\n        return list1\n\n    if list1.val < list2.val:\n        list1.next = merge_two_lists(list1.next, list2)\n        return list1\n    else:\n        list2.next = merge_two_lists(list1, list2.next)\n        return list2", "def generate_parenthesis(n):\n    def generate_parenthesis_helper(open, close, current):\n        if open == 0 and close == 0:\n            result.append(current)\n            return\n        if open > 0:\n            generate_parenthesis_helper(open - 1, close + 1, current + '(')\n        if close > 0:\n            generate_parenthesis_helper(open, close - 1, current + ')')\n\n    result = []\n    generate_parenthesis_helper(n, 0, '')\n    return result", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def mergeKLists(self, lists):\n        if not lists: return None\n        while len(lists) > 1:\n            lists.append(self.merge2Lists(lists.pop(0), lists.pop(0)))\n        return lists[0]\n        \n    def merge2Lists(self, l1, l2):\n        if not l1: return l2\n        if not l2: return l1\n        if l1.val <= l2.val:\n            l1.next = self.merge2Lists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.merge2Lists(l1, l2.next)\n            return l2", "def swapPairs(head: Optional[ListNode]) -> Optional[ListNode]:\n    if not head or not head.next:\n        return head\n\n    second = head.next\n    head.next = swapPairs(second.next)\n    second.next = head\n\n    return second", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverseKGroup(head, k):\n    if not head or k == 1:\n        return head\n        \n    cur = head\n    length = 0\n    while cur:\n        length += 1\n        cur = cur.next\n        \n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n    cur = head\n    \n    while length >= k:\n        for _ in range(1, k):\n            temp = cur.next\n            cur.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n            \n        prev = cur\n        cur = cur.next\n        length -= k\n        \n    return dummy.next", "def removeDuplicates(nums):\n    if not nums: return 0\n    i = 0\n    for j in range(1, len(nums)):\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n    return i + 1", "def removeElement(nums, val):\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != val:\n            nums[i] = nums[j]\n            i += 1\n    return i", "def strStr(haystack: str, needle: str) -> int:\n    if not needle:\n        return 0\n    try:\n        index = haystack.index(needle)\n        return index\n    except ValueError:\n        return -1", "def divide(dividend: int, divisor: int) -> int:\n    if dividend == -(2**31) and divisor == -1:\n        return 2**31 - 1\n\n    sign = -1 if (dividend > 0) ^ (divisor > 0) else 1\n\n    dvd = abs(dividend)\n    dvs = abs(divisor)\n    ans = 0\n\n    while dvd >= dvs:\n        temp = dvs\n        multiple = 1\n        while dvd >= (temp << 1):\n            temp <<= 1\n            multiple <<= 1\n        dvd -= temp\n        ans += multiple\n\n    return ans * sign", "from collections import Counter\n\ndef findSubstring(s, words):\n    if not s or not words:\n        return []\n\n    word_count = Counter(words)\n    word_length = len(words[0])\n    total_words = len(words)\n    total_length = word_length * total_words\n    result = []\n\n    for i in range(len(s) - total_length + 1):\n        temp_word_count = Counter()\n        for j in range(total_words):\n            current_word = s[i + j * word_length:i + (j + 1) * word_length]\n            if current_word not in word_count:\n                break\n            temp_word_count[current_word] += 1\n            if temp_word_count[current_word] > word_count[current_word]:\n                break\n            if j + 1 == total_words:\n                result.append(i)\n\n    return result", "def nextPermutation(nums):\n    n, k = len(nums), -1\n    for i in range(n - 1, 0, -1):\n        if nums[i - 1] < nums[i]:\n            k = i - 1\n            break\n    if k == -1:\n        nums.reverse()\n    else:\n        l = 0\n        for i in range(n - 1, k, -1):\n            if nums[i] > nums[k]:\n                l = i\n                break\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k + 1:] = reversed(nums[k + 1:])", "def longest_valid_parentheses(s: str) -> int:\n    n = len(s)\n    result = 0\n    st = []\n\n    for i in range(n):\n        if s[i] == '(':\n            st.append(i)\n        else:\n            if st and s[st[-1]] == '(':\n                st.pop()\n            else:\n                st.append(i)\n\n    if not st:\n        result = n\n    else:\n        right, left = n, 0\n        while st:\n            left = st.pop()\n            result = max(result, right - left - 1)\n            right = left\n        result = max(result, right)\n\n    return result", "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] >= nums[left]:\n            if target >= nums[left] and target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if target > nums[mid] and target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1", "def searchRange(nums, target):\n    start, end = -1, -1\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n            if nums[mid] == target:\n                start = mid\n\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] > target:right = mid - 1\n        else:\n            left = mid + 1\n            if nums[mid] == target:\n                end = mid\n    \n    return [start, end]", "def searchInsert(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left", "def isValidSudoku(board):\n    seen = set()\n\n    for i in range(9):\n        for j in range(9):\n            current_val = board[i][j]\n            \n            if current_val != '.':\n                row = f\"{current_val} in row {i}\"\n                col = f\"{current_val} in col {j}\"\n                box = f\"{current_val} in box {i // 3}-{j // 3}\"\n                \n                if row in seen or col in seen or box in seen:\n                    return False\n\n                seen.add(row)\n                seen.add(col)\n                seen.add(box)\n\n    return True", "def isValid(board, row, col, c):\n    for i in range(9):\n        if board[i][col] == c:\n            return False\n        if board[row][i] == c:\n            return False\n        if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == c:\n            return False\n    return True\n\ndef solveSudokuHelper(board):\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == '.':\n                for c in '123456789':\n                    if isValid(board, i, j, c):\n                        board[i][j] = c\n\n                        if solveSudokuHelper(board):\n                            return True\n\n                        board[i][j] = '.'\n                return False\n\n    return True\n\ndef solveSudoku(board):\n    solveSudokuHelper(board)", "def count_and_say(n):\n    if n == 1:\n        return \"1\"\n    previous = count_and_say(n - 1)\n    result = []\n    count = 1\n    for i in range(1, len(previous)):\n        if previous[i] == previous[i - 1]:\n            count += 1\n        else:\n            result.append(str(count))\n            result.append(previous[i - 1])\n            count = 1\n    result.append(str(count))\n    result.append(previous[-1])\n    return \"\".join(result)", "def combinationSum(candidates, target):\n    def findCombinations(startIndex, remaining):\n        if remaining == 0:\n            return [[]]\n        if startIndex == len(candidates) or remaining < 0:\n            return []\n\n        result = []\n        result.extend(findCombinations(startIndex + 1, remaining))\n        result.extend([x + [candidates[startIndex]] for x in findCombinations(startIndex, remaining - candidates[startIndex])])\n        \n        return result\n\n    return findCombinations(0, target)", "def combinationSum2(candidates, target):\n    def combine(candidates, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i - 1]:\n                continue\n            if candidates[i] > target:\n                break\n            combine(candidates, target - candidates[i], i+1, path + [candidates[i]], res)\n\n    candidates.sort()\n    res = []\n    combine(candidates, target, 0, [], res)\n    return res", "def firstMissingPositive(nums):\n    n = len(nums)\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    return n + 1", "def trap(height):\n    n = len(height)\n    left, right, max_left, max_right, water = 0, n - 1, 0, 0, 0\n\n    while left < right:\n        if height[left] <= height[right]:\n            max_left = max(max_left, height[left])\n            water += max_left - height[left]\n            left += 1\n        else:\n            max_right = max(max_right, height[right])\n            water += max_right - height[right]\n            right -= 1\n\n    return water", "def multiply(num1, num2):\n    m, n = len(num1), len(num2)\n    pos = [0] * (m + n)\n    \n    for i in range(m-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            mult = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))\n            p1, p2 = i + j, i + j + 1\n            total_pos = mult + pos[p2]\n            pos[p1] += total_pos // 10\n            pos[p2] = total_pos % 10\n            \n    res = ''.join(str(p) for p in pos if not (len(res) == 0 and p == 0))            \n    return '0' if len(res) == 0 else res", "def is_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    i = j = 0\n    match = asterisk = -1\n    while i < m:\n        if j < n and (s[i] == p[j] or p[j] == '?'):\n            i, j = i + 1, j + 1\n        elif j < n and p[j] == '*':\n            match, asterisk = i, j\n            j += 1\n        elif asterisk >= 0:\n            i, j = match + 1, asterisk + 1\n            match += 1\n        else:\n            return False\n    while j < n and p[j] == '*':\n        j += 1\n    return j == n", "def jump(nums):\n    jumps = 0\n    current_end = 0\n    current_farthest = 0\n\n    for i in range(len(nums) - 1):\n        current_farthest = max(current_farthest, i + nums[i])\n        if i == current_end:\n            jumps += 1\n            current_end = current_farthest\n\n    return jumps", "from typing import List\n\ndef permute(nums: List[int]) -> List[List[int]]:\n    def helper(index):\n        if index == len(nums) - 1:\n            results.append(nums[:])\n            return\n\n        for i in range(index, len(nums)):\n            nums[index], nums[i] = nums[i], nums[index]\n            helper(index + 1)\n            nums[index], nums[i] = nums[i], nums[index]\n\n    results = []\n    helper(0)\n    return results", "from typing import List\n\ndef permuteUnique(nums: List[int]) -> List[List[int]]:\n    def backtrack(start):\n        if start == len(nums):\n            result.append(nums[:])\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[start]:\n                continue\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]\n\n    nums.sort()\n    result = []\n    backtrack(0)\n    return result", "def rotate(matrix):\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp", "from collections import defaultdict\n\ndef group_anagrams(strs):\n    anagram_map = defaultdict(list)\n\n    for s in strs:\n        key = ''.join(sorted(s))\n        anagram_map[key].append(s)\n\n    return list(anagram_map.values())", "def myPow(x: float, n: int) -> float:\n    if n == 0:\n        return 1\n    if n < 0:\n        x = 1 / x\n        n = -n\n    result = 1\n    currentProduct = x\n    i = n\n    while i:\n        if i % 2 == 1:\n            result *= currentProduct\n        currentProduct *= currentProduct\n        i //= 2\n    return result", "def solveNQueens(n):\n    def isSafe(board, row, col):\n        for i in range(col):\n            if board[row][i] == 'Q': return False\n        i, j = row, col\n        while i >= 0 and j >= 0:\n            if board[i][j] == 'Q': return False\n            i, j = i - 1, j - 1\n        i, j = row, col\n        while i < n and j >= 0:\n            if board[i][j] == 'Q': return False\n            i, j = i + 1, j - 1\n        return True\n\n    def solve(result, board, n, col):\n        if col == n:\n            result.append(board.copy())\n            return\n        for row in range(n):\n            if isSafe(board, row, col):\n                board[row] = board[row][:col] + 'Q' + board[row][col + 1:]\n                solve(result, board, n, col + 1)\n                board[row] = board[row][:col] + '.' + board[row][col + 1:]\n\n    result, board = [], ['.' * n for _ in range(n)]\n    solve(result, board, n, 0)\n    return result", "def is_safe(cols, row):\n    col = len(cols)\n    for i, r in enumerate(cols):\n        if r == row or abs(i - col) == abs(r - row):\n            return False\n    return True\n\n\ndef backtrack(n, cols):\n    if len(cols) == n:\n        return 1\n\n    count = 0\n    for i in range(n):\n        if is_safe(cols, i):\n            cols.append(i)\n            count += backtrack(n, cols)\n            cols.pop()\n\n    return count\n\n\ndef total_n_queens(n):\n    cols = []\n    return backtrack(n, cols)", "def maxSubArray(nums):\n    max_sum = current_sum = nums[0]\n\n    for num in nums[1:]:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "def spiralOrder(matrix):\n    result = []\n    if not matrix: return result\n    m, n = len(matrix), len(matrix[0])\n    rowStart, colStart, rowEnd, colEnd = 0, 0, m - 1, n - 1\n\n    while rowStart <= rowEnd and colStart <= colEnd:\n        for i in range(colStart, colEnd + 1): \n            result.append(matrix[rowStart][i])\n        rowStart += 1\n        \n        for i in range(rowStart, rowEnd + 1): \n            result.append(matrix[i][colEnd]) \n        colEnd -= 1\n        \n        if rowStart <= rowEnd:\n            for i in range(colEnd, colStart - 1, -1): \n                result.append(matrix[rowEnd][i]) \n        rowEnd -= 1\n        \n        if colStart <= colEnd:\n            for i in range(rowEnd, rowStart - 1, -1): \n                result.append(matrix[i][colStart]) \n        colStart += 1\n        \n    return result", "def canJump(nums):\n    max_reach = 0\n    for i, num in enumerate(nums):\n        if i > max_reach:\n            return False\n        max_reach = max(max_reach, i + num)\n    return True", "def merge(intervals):\n    if not intervals:\n        return []\n\n    intervals.sort()\n    result = [intervals[0]]\n\n    for i in range(1, len(intervals)):\n        if result[-1][1] >= intervals[i][0]:\n            result[-1][1] = max(result[-1][1], intervals[i][1])\n        else:\n            result.append(intervals[i])\n\n    return result", "from typing import List\n\ndef insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n    result = []\n    start_pos = 0\n\n    while start_pos < len(intervals) and intervals[start_pos][1] < newInterval[0]:\n        result.append(intervals[start_pos])\n        start_pos += 1\n\n    while start_pos < len(intervals) and intervals[start_pos][0] <= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[start_pos][0])\n        newInterval[1] = max(newInterval[1], intervals[start_pos][1])\n        start_pos += 1\n\n    result.append(newInterval)\n\n    while start_pos < len(intervals):\n        result.append(intervals[start_pos])\n        start_pos += 1\n\n    return result", "def length_of_last_word(s: str) -> int:\n    length = 0\n    tail = len(s) - 1\n    while tail >= 0 and s[tail] == ' ':\n        tail -= 1\n    while tail >= 0 and s[tail] != ' ':\n        length += 1\n        tail -= 1\n    return length", "def generateMatrix(n: int) -> List[List[int]]:\n    matrix = [[0] * n for _ in range(n)]\n    value, top, bottom, left, right = 1, 0, n - 1, 0, n - 1\n\n    while value <= n * n:\n        for i in range(left, right + 1):\n            matrix[top][i] = value\n            value += 1\n\n        for i in range(top + 1, bottom + 1):\n            matrix[i][right] = value\n            value += 1\n\n        if top < bottom and left < right:\n            for i in range(right - 1, left - 1, -1):\n                matrix[bottom][i] = value\n                value += 1\n\n            for i in range(bottom - 1, top, -1):\n                matrix[i][left] = value\n                value += 1\n\n        top, bottom, left, right = top + 1, bottom - 1, left + 1, right - 1\n\n    return matrix", "def getPermutation(n, k):\n    factorials = [1]\n    nums = list(range(1, n + 1))\n    result = []\n\n    for i in range(1, n):\n        factorials.append(factorials[-1] * i)\n\n    k -= 1\n\n    for i in range(n, 0, -1):\n        index = k // factorials[i - 1]\n        k %= factorials[i - 1]\n        result.append(str(nums.pop(index)))\n\n    return ''.join(result)", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef rotateRight(head, k):\n    if not head or not head.next or k == 0:\n        return head\n\n    current = head\n    length = 1\n    while current.next:\n        length += 1\n        current = current.next\n    current.next = head\n    k = length - k % length\n\n    while k:\n        k -= 1\n        current = current.next\n    head = current.next\n    current.next = None\n\n    return head", "def uniquePaths(m, n):\n    dp = [[1] * n for _ in range(m)]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[m - 1][n - 1]", "def uniquePathsWithObstacles(grid):\n    m, n = len(grid), len(grid[0])\n    if grid[0][0] == 1:\n        return 0\n\n    grid[0][0] = 1\n    for i in range(1, m):\n        grid[i][0] = 1 if grid[i][0] == 0 and grid[i - 1][0] == 1 else 0\n    for i in range(1, n):\n        grid[0][i] = 1 if grid[0][i] == 0 and grid[0][i - 1] == 1 else 0\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 0:\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n            else:\n                grid[i][j] = 0\n\n    return grid[m - 1][n - 1]", "def minPathSum(grid):\n    m, n = len(grid), len(grid[0])\n\n    for i in range(1, m):\n        grid[i][0] += grid[i - 1][0]\n\n    for i in range(1, n):\n        grid[0][i] += grid[0][i - 1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n\n    return grid[m - 1][n - 1]", "import re\n\ndef is_number(s: str) -> bool:\n    pattern = re.compile(r'^[-+]?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(e[-+]?[0-9]+)?$')\n    return bool(pattern.match(s))", "def plusOne(digits: List[int]) -> List[int]:\n    n = len(digits)\n\n    for i in range(n - 1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n\n    digits.insert(0, 1)\n    return digits", "def addBinary(a: str, b: str) -> str:\n    result, carry, i, j = \"\", 0, len(a) - 1, len(b) - 1\n    while i >= 0 or j >= 0 or carry:\n        if i >= 0:\n            carry += int(a[i])\n            i -= 1\n        if j >= 0:\n            carry += int(b[j])\n            j -= 1\n        result = str(carry % 2) + result\n        carry //= 2\n    return result", "def fullJustify(words, maxWidth):\n    result = []\n    idx = 0\n    while idx < len(words):\n        total_chars = len(words[idx])\n        last = idx + 1\n        while last < len(words):\n            if total_chars + 1 + len(words[last]) > maxWidth:\n                break\n            total_chars += 1 + len(words[last])\n            last += 1\n        gaps = last - idx - 1\n        line = []\n        if last == len(words) or gaps == 0:\n            for i in range(idx, last):\n                line.append(words[i])\n                if i < last - 1:\n                    line.append(\" \")\n            while sum(len(w) for w in line) < maxWidth:\n                line.append(\" \")\n        else:\n            even_spaces = (maxWidth - total_chars) // gaps\n            extra_spaces = (maxWidth - total_chars) % gaps\n            for i in range(idx, last):\n                line.append(words[i])\n                if i < last - 1:\n                    line.append(\" \" * (even_spaces + (1 if i - idx < extra_spaces else 0)))\n        idx = last\n        result.append(\"\".join(line))\n    return result", "def mySqrt(x):\n    if x == 0 or x == 1:\n        return x\n    start, end, ans = 1, x, 0\n    while start <= end:\n        mid = (start + end) // 2\n        if mid * mid == x:\n            return mid\n        if mid * mid < x:\n            start = mid + 1\n            ans = mid\n        else:\n            end = mid - 1\n    return ans", "def climbStairs(n):\n    if n <= 2:\n        return n\n    a, b = 1, 2\n    for _ in range(3, n+1):\n        a, b = b, a + b\n    return b", "def simplifyPath(path: str) -> str:\n    stack = []\n    parts = path.split(\"/\")\n\n    for part in parts:\n        if not part or part == \".\":\n            continue\n        if part == \"..\":\n            if stack:\n                stack.pop()\n        else:\n            stack.append(part)\n\n    return \"/\" + \"/\".join(stack)", "def minDistance(word1: str, word2: str) -> int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n    \n    return dp[m][n]", "def setZeroes(matrix):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    firstRow, firstCol = False, False\n\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] == 0:\n                if i == 0: firstRow = True\n                if j == 0: firstCol = True\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if matrix[i][0] == 0 or matrix[0][j] == 0:\n                matrix[i][j] = 0\n\n    if firstRow:\n        for j in range(cols):\n            matrix[0][j] = 0\n\n    if firstCol:\n        for i in range(rows):\n            matrix[i][0] = 0", "def searchMatrix(matrix, target):\n    m, n = len(matrix), len(matrix[0])\n    l, r = 0, m * n - 1\n\n    while l <= r:\n        mid = l + (r - l) // 2\n        mid_val = matrix[mid // n][mid % n]\n\n        if mid_val == target:\n            return True\n        elif mid_val < target:\n            l = mid + 1\n        else:\n            r = mid - 1\n\n    return False", "def sortColors(nums: List[int]) -> None:\n    red, white, blue = 0, 0, len(nums) - 1\n    while white <= blue:\n        if nums[white] == 0:\n            nums[red], nums[white] = nums[white], nums[red]\n            red += 1\n            white += 1\n        elif nums[white] == 1:\n            white += 1\n        else:\n            nums[white], nums[blue] = nums[blue], nums[white]\n            blue -= 1", "from collections import Counter\n\ndef min_window(s, t):\n    need = Counter(t)\n    window = {}\n    \n    left = 0\n    right = 0\n    valid = 0\n    start = 0\n    length = float('inf')\n\n    while right < len(s):\n        c = s[right]\n        right += 1\n        if c in need:\n            window[c] = window.get(c, 0) + 1\n            if window[c] <= need[c]:\n                valid += 1\n\n        while valid == len(t):\n            if right - left < length:\n                start = left\n                length = right - left\n\n            d = s[left]\n            left += 1\n            if d in need:\n                if window[d] <= need[d]:\n                    valid -= 1\n                window[d] -= 1\n\n    return \"\" if length == float('inf') else s[start : start + length]", "from typing import List\n\ndef combine(n: int, k: int) -> List[List[int]]:\n    def backtrack(start, current_combination):\n        if len(current_combination) == k:\n            result.append(current_combination[:])\n\n        for i in range(start, n + 1):\n            current_combination.append(i)\n            backtrack(i + 1, current_combination)\n            current_combination.pop()\n\n    result = []\n    backtrack(1, [])\n    return result", "def subsets(nums):\n    n = len(nums)\n    num_subsets = 1 << n\n    result = []\n\n    for i in range(num_subsets):\n        subset = []\n        for j in range(n):\n            if i & (1 << j):\n                subset.append(nums[j])\n        result.append(subset)\n    return result", "def exist(board, word):\n    m, n = len(board), len(board[0])\n\n    def dfs(i, j, k):\n        if not 0 <= i < m or not 0 <= j < n or board[i][j] != word[k]:\n            return False\n        if k == len(word) - 1:\n            return True\n\n        tmp, board[i][j] = board[i][j], '/'\n        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n        board[i][j] = tmp\n        return res\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n    return False", "def remove_duplicates(nums):\n    i = 0\n    for num in nums:\n        if i < 2 or num > nums[i - 2]:\n            nums[i] = num\n            i += 1\n    return i", "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return True\n\n        if nums[mid] == nums[left]:\n            left += 1\n        elif nums[mid] > nums[left]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return False", "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef deleteDuplicates(head):\n    dummy = ListNode(0)\n    dummy.next = head\n    prev, curr = dummy, head\n    while curr:\n        while curr.next and curr.val == curr.next.val:\n            curr = curr.next\n        if prev.next == curr:\n            prev = prev.next\n        else:\n            prev.next = curr.next\n        curr = curr.next\n    return dummy.next", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef delete_duplicates(head):\n    current = head\n    while current and current.next:\n        if current.next.val == current.val:\n            current.next = current.next.next\n        else:\n            current = current.next\n    return head", "def largestRectangleArea(heights):\n    stack = []\n    max_area = 0\n    for i, h in enumerate(heights + [0]):\n        while stack and heights[stack[-1]] > h:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n    return max_area", "def maximalRectangle(matrix):\n    if not matrix:\n        return 0\n\n    m = len(matrix)\n    n = len(matrix[0])\n    height = [0] * (n + 1)\n    max_area = 0\n\n    for i in range(m):\n        s = []\n        for j in range(n + 1):\n            if j < n:\n                height[j] = height[j] + 1 if matrix[i][j] == '1' else 0\n            while s and height[j] < height[s[-1]]:\n                h = height[s.pop()]\n                w = j if not s else j - s[-1] - 1\n                max_area = max(max_area, h * w)\n            s.append(j)\n\n    return max_area", "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef partition(head, x):\n    less_head = ListNode(0)\n    more_head = ListNode(0)\n    less_ptr, more_ptr = less_head, more_head\n    \n    while head:\n        if head.val < x:\n            less_ptr.next = head\n            less_ptr = head\n        else:\n            more_ptr.next = head\n            more_ptr = head\n        head = head.next\n    \n    less_ptr.next = more_head.next\n    more_ptr.next = None\n    \n    return less_head.next", "def isScramble(s1: str, s2: str) -> bool:\n    if s1 == s2:\n        return True\n    if len(s1) != len(s2) or sorted(s1) != sorted(s2):\n        return False\n\n    for i in range(1, len(s1)):\n        if (isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:])) or \\\n           (isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i])):\n            return True\n    return False", "def merge(nums1, m, nums2, n):\n    i, j, k = m - 1, n - 1, m + n - 1\n    while i >= 0 and j >= 0:\n        if nums1[i] > nums2[j]:\n            nums1[k] = nums1[i]\n            i -= 1\n        else:\n            nums1[k] = nums2[j]\n            j -= 1\n        k -= 1\n    while j >= 0:\n        nums1[k] = nums2[j]\n        k -= 1\n        j -= 1", "def grayCode(n):\n    result = []\n    for i in range(1 << n):\n        result.append(i ^ (i >> 1))\n    return result", "from itertools import combinations\n\ndef subsetsWithDup(nums):\n    result = set()\n    nums.sort()\n    for i in range(len(nums) + 1):\n        for combo in combinations(nums, i):\n            result.add(combo)\n    return list(result)", "def numDecodings(s: str) -> int:\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1 if s[0] != '0' else 0\n\n    for i in range(2, n + 1):\n        one_digit = int(s[i - 1:i])\n        two_digits = int(s[i - 2:i])\n\n        if one_digit >= 1:\n            dp[i] += dp[i - 1]\n        if two_digits >= 10 and two_digits <= 26:\n            dp[i] += dp[i - 2]\n    return dp[n]", "def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\n    if not head or left == right:\n        return head\n    dummy = ListNode(0)\n    dummy.next = head\n    pre = dummy\n    for _ in range(left - 1):\n        pre = pre.next\n    cur = pre.next\n    for _ in range(left, right):\n        t = cur.next\n        cur.next = t.next\n        t.next = pre.next\n        pre.next = t\n    return dummy.next", "def restore_ip_addresses(s):\n    def dfs(s, start, ip, result, part):\n        if part == 4 and start == len(s):\n            result.append(ip[:-1])\n            return\n        if part == 4 or start >= len(s):\n            return\n\n        num = 0\n        for i in range(start, len(s)):\n            num = num * 10 + int(s[i])\n            if num > 255:\n                break\n            dfs(s, i + 1, ip + s[i] + \".\", result, part + 1)\n            if num == 0:\n                break\n\n    result = []\n    dfs(s, 0, \"\", result, 0)\n    return result", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef inorderTraversalHelper(root, result):\n    if not root:\n        return\n    inorderTraversalHelper(root.left, result)\n    result.append(root.val)\n    inorderTraversalHelper(root.right, result)\n\ndef inorderTraversal(root):\n    result = []\n    inorderTraversalHelper(root, result)\n    return result", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef generate_trees(start, end):\n    trees = []\n    if start > end:\n        trees.append(None)\n        return trees\n\n    for i in range(start, end + 1):\n        left_subtrees = generate_trees(start, i - 1)\n        right_subtrees = generate_trees(i + 1, end)\n\n        for left in left_subtrees:\n            for right in right_subtrees:\n                new_node = TreeNode(i)\n                new_node.left = left\n                new_node.right = right\n                trees.append(new_node)\n\n    return trees\n\ndef generate_trees(n):\n    if n == 0:\n        return []\n    return generate_trees(1, n)", "def numTrees(n):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n    return dp[n]", "def isInterleave(s1, s2, s3):\n    m, n = len(s1), len(s2)\n    if m + n != len(s3):\n        return False\n\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    for i in range(1, m + 1):\n        dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or \\\n                       (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isValidBSTHelper(node, min_val, max_val):\n    if node is None:\n        return True\n    if not min_val < node.val < max_val:\n        return False\n    return (isValidBSTHelper(node.left, min_val, node.val) and\n            isValidBSTHelper(node.right, node.val, max_val))\n\ndef isValidBST(root):\n    return isValidBSTHelper(root, float('-inf'), float('inf'))", "def inorder(node, nodes):\n    if not node: return\n    inorder(node.left, nodes)\n    if nodes[1] and nodes[1].val > node.val:\n        if not nodes[0]: nodes[0] = nodes[1]\n        nodes[2] = node\n    nodes[1] = node\n    inorder(node.right, nodes)\n\ndef recoverTree(root):\n    nodes = [None, None, None]\n    inorder(root, nodes)\n    nodes[0].val, nodes[2].val = nodes[2].val, nodes[0].val", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_same_tree(p, q):\n    if p is None and q is None:\n        return True\n    if p is None or q is None:\n        return False\n    if p.val != q.val:\n        return False\n    return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)", "def isSymmetric(root):\n    return checkSymmetry(root, root)\n\ndef checkSymmetry(node1, node2):\n    if not node1 and not node2:\n        return True\n    if not node1 or not node2:\n        return False\n    return (node1.val == node2.val) and checkSymmetry(node1.right, node2.left) and checkSymmetry(node1.left, node2.right)", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrder(root):\n    if not root:\n        return []\n\n    result = []\n    queue = [root]\n\n    while queue:\n        level = []\n        for i in range(len(queue)):\n            node = queue.pop(0)\n\n            if node.left:\n                queue.append(node.left)\n\n            if node.right:\n                queue.append(node.right)\n\n            level.append(node.val)\n\n        result.append(level)\n\n    return result", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef zigzagLevelOrder(root):\n    if not root:\n        return []\n\n    result = []\n    queue = [root]\n    zigzag = False\n\n    while queue:\n        level = []\n        for i in range(len(queue)):\n            node = queue.pop(0)\n\n            if zigzag:\n                level.insert(0, node.val)\n            else:\n                level.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(level)\n        zigzag = not zigzag\n\n    return result", "def maxDepth(root):\n    if root is None:\n        return 0\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_tree(preorder, inorder):\n    def construct_tree(in_left, in_right):\n        nonlocal pre_idx\n        if in_left > in_right:\n            return None\n\n        root_val = preorder[pre_idx]\n        root = TreeNode(root_val)\n        idx = in_map[root_val]\n\n        pre_idx += 1\n        root.left = construct_tree(in_left, idx - 1)\n        root.right = construct_tree(idx + 1, in_right)\n\n        return root\n\n    in_map = {val: idx for idx, val in enumerate(inorder)}\n    pre_idx = 0\n    return construct_tree(0, len(inorder) - 1)", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def buildTree(self, inorder, postorder):\n        def _build(in_left, in_right, post_root):\n            if in_left > in_right:\n                return None\n            \n            root = TreeNode(postorder[post_root])\n\n            inorder_root_index = index_map[root.val]\n            left_tree_size = inorder_root_index - in_left\n\n            root.left = _build(in_left, inorder_root_index - 1, post_root - 1 - in_right + inorder_root_index)\n            root.right = _build(inorder_root_index + 1, in_right, post_root - 1)\n\n            return root\n\n        index_map = {val: i for i, val in enumerate(inorder)}\n        return _build(0, len(inorder) - 1, len(postorder) - 1)", "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrderBottom(root):\n    result = []\n    if not root:\n        return result\n\n    queue = deque([root])\n\n    while queue:\n        level = []\n        size = len(queue)\n\n        for i in range(size):\n            current = queue.popleft()\n            level.append(current.val)\n\n            if current.left:\n                queue.append(current.left)\n            if current.right:\n                queue.append(current.right)\n\n        result.insert(0, level)\n\n    return result", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef sorted_array_to_bst(nums):\n    def helper(start, end):\n        if start > end:\n            return None\n\n        mid = start + (end - start) // 2\n        node = TreeNode(nums[mid])\n        node.left = helper(start, mid - 1)\n        node.right = helper(mid + 1, end)\n\n        return node\n\n    return helper(0, len(nums) - 1)", "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef sortedListToBST(head):\n    if not head:\n        return None\n    if not head.next:\n        return TreeNode(head.val)\n    slow = head\n    fast = head\n    prev = None\n\n    while fast and fast.next:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n\n    prev.next = None\n\n    root = TreeNode(slow.val)\n    root.left = sortedListToBST(head)\n    root.right = sortedListToBST(slow.next)\n    return root", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef getHeight(node):\n    if not node:\n        return 0\n    left_height = getHeight(node.left)\n    right_height = getHeight(node.right)\n    if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1:\n        return -1\n    return 1 + max(left_height, right_height)\n\ndef isBalanced(root):\n    return getHeight(root) != -1", "def minDepth(root):\n    if not root:\n        return 0\n    left = minDepth(root.left)\n    right = minDepth(root.right)\n    return (left == 0 or right == 0) and left + right + 1 or min(left, right) + 1", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef hasPathSum(root, targetSum):\n    if root is None:\n        return False\n    if root.left is None and root.right is None:\n        return targetSum - root.val == 0\n    return hasPathSum(root.left, targetSum - root.val) or hasPathSum(root.right, targetSum - root.val)", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef pathSum(root, targetSum):\n    def helper(root, targetSum, current, ans):\n        if not root:\n            return\n        current.append(root.val)\n        if not root.left and not root.right and targetSum == root.val:\n            ans.append(current[:])\n        helper(root.left, targetSum - root.val, current, ans)\n        helper(root.right, targetSum - root.val, current, ans)\n        current.pop()\n\n    ans = []\n    helper(root, targetSum, [], ans)\n    return ans", "def flatten(root):\n    if not root:\n        return\n    flatten(root.left)\n    flatten(root.right)\n    if root.left:\n        temp = root.right\n        root.right = root.left\n        root.left = None\n        while root.right:\n            root = root.right\n        root.right = temp", "def numDistinct(s: str, t: str) -> int:\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[m][n]", "def connect(self, root: 'Node') -> 'Node':\n    if not root or not root.left:\n        return root\n    root.left.next = root.right\n    if root.next:\n        root.right.next = root.next.left\n    self.connect(root.left)\n    self.connect(root.right)\n    return root", "class Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\ndef connect(root: 'Node') -> 'Node':\n    if not root:\n        return None\n\n    q = [root]\n\n    while q:\n        level_size = len(q)\n        prev = None\n\n        for i in range(level_size):\n            current_node = q.pop(0)\n\n            if prev:\n                prev.next = current_node\n            prev = current_node\n\n            if current_node.left:\n                q.append(current_node.left)\n            if current_node.right:\n                q.append(current_node.right)\n\n    return root", "def generate(numRows):\n    pascalsTriangle = []\n    for i in range(numRows):\n        row = [1]\n        if i > 0:\n            for j in range(1, i):\n                row.append(pascalsTriangle[i-1][j-1] + pascalsTriangle[i-1][j])\n            row.append(1)\n        pascalsTriangle.append(row)\n    return pascalsTriangle", "def get_row(rowIndex):\n    row = [1] * (rowIndex + 1)\n    for i in range(1, rowIndex + 1):\n        for j in range(i - 1, 0, -1):\n            row[j] += row[j - 1]\n    return row", "def minimumTotal(triangle):\n    for row in range(len(triangle) - 2, -1, -1):\n        for col in range(len(triangle[row])):\n            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])\n    return triangle[0][0]", "def maxProfit(prices):\n    minPrice = float('inf')\n    maxProfit = 0\n    for price in prices:\n        minPrice = min(minPrice, price)\n        maxProfit = max(maxProfit, price - minPrice)\n    return maxProfit", "def max_profit(prices):\n    max_profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            max_profit += prices[i] - prices[i - 1]\n    return max_profit", "def maxProfit(prices):\n    buy1, buy2 = float(\"inf\"), float(\"inf\")\n    profit1, profit2 = 0, 0\n\n    for price in prices:\n        buy1 = min(buy1, price)\n        profit1 = max(profit1, price - buy1)\n        buy2 = min(buy2, price - profit1)\n        profit2 = max(profit2, price - buy2)\n\n    return profit2", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxPathSum(root: TreeNode) -> int:\n    def helper(root):\n        nonlocal maxSum\n        if not root:\n            return 0\n\n        left = max(0, helper(root.left))\n        right = max(0, helper(root.right))\n\n        maxSum = max(maxSum, left + right + root.val)\n\n        return max(left, right) + root.val\n\n    maxSum = float('-inf')\n    helper(root)\n    return maxSum", "def isPalindrome(s: str) -> bool:\n    cleaned = \"\".join(c.lower() for c in s if c.isalnum())\n    left, right = 0, len(cleaned) - 1\n    while left < right:\n        if cleaned[left] != cleaned[right]:\n            return False\n        left += 1\n        right -= 1\n    return True", "from collections import defaultdict, deque\n\ndef findLadders(beginWord, endWord, wordList):\n    wordList = set(wordList)\n    if endWord not in wordList:\n        return []\n\n    adjacent = defaultdict(list)\n    distance = defaultdict(int)\n    queue = deque([beginWord])\n    distance[beginWord] = 0\n    \n    def neighbors(word):\n        for i in range(len(word)):\n            for j in range(ord('a'), ord('z') + 1):\n                yield word[:i] + chr(j) + word[i + 1:]\n                \n    while queue:\n        current = queue.popleft()\n        if current == endWord:\n            break\n        for neighbor in neighbors(current):\n            if neighbor not in wordList:\n                continue\n            if neighbor not in distance:\n                distance[neighbor] = distance[current] + 1\n                queue.append(neighbor)\n            if distance[neighbor] == distance[current] + 1:\n                adjacent[current].append(neighbor)\n\n    result = []\n    path = [beginWord]\n\n    def backtrack(word):\n        if word == endWord:\n            result.append(path[:])\n        else:\n            for next_word in adjacent[word]:\n                path.append(next_word)\n                backtrack(next_word)\n                path.pop()\n                \n    backtrack(beginWord)\n    return result", "from collections import deque\n\ndef ladderLength(beginWord, endWord, wordList):\n    word_set = set(wordList)\n    if endWord not in word_set:\n        return 0\n\n    q = deque([beginWord])\n    steps = 1\n\n    while q:\n        size = len(q)\n        current_level = set()\n        \n        for _ in range(size):\n            current_word = q.popleft()\n            if current_word == endWord:\n                return steps\n\n            word_chars = list(current_word)\n            for i in range(len(word_chars)):\n                original_char = word_chars[i]\n                for j in range(26):\n                    word_chars[i] = chr(ord('a') + j)\n                    new_word = ''.join(word_chars)\n                    if new_word in word_set:\n                        q.append(new_word)\n                        current_level.add(new_word)\n                        \n                word_chars[i] = original_char\n        \n        word_set -= current_level\n        steps += 1\n        \n    return 0", "def longest_consecutive(nums):\n    elements = set(nums)\n    longest_seq = 0\n\n    for num in nums:\n        if num - 1 not in elements:\n            current_num = num\n            current_seq = 1\n            \n            while current_num + 1 in elements:\n                current_num += 1\n                current_seq += 1\n\n            longest_seq = max(longest_seq, current_seq)\n    \n    return longest_seq", "def sumNumbers(root, cur=0):\n    if root is None: return 0\n    cur = cur * 10 + root.val\n    if root.left is None and root.right is None: return cur\n    return sumNumbers(root.left, cur) + sumNumbers(root.right, cur)", "class Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        if not board:\n            return\n        m, n = len(board), len(board[0])\n\n        def dfs(x, y):\n            if x < 0 or x >= m or y < 0 or y >= n or board[x][y] != 'O':\n                return\n            board[x][y] = '#'\n            dfs(x - 1, y)\n            dfs(x + 1, y)\n            dfs(x, y - 1)\n            dfs(x, y + 1)\n\n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        for i in range(n):\n            dfs(0, i)\n            dfs(m - 1, i)\n\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == '#':\n                    board[i][j] = 'O'\n                elif board[i][j] == 'O':\n                    board[i][j] = 'X'", "def isPalindrome(s, start, end):\n    while start < end:\n        if s[start] != s[end]:\n            return False\n        start += 1\n        end -= 1\n    return True\n\ndef dfs(s, start, results, current):\n    if start == len(s):\n        results.append(current[:])\n        return\n    \n    for end in range(start, len(s)):\n        if isPalindrome(s, start, end):\n            current.append(s[start:end+1])\n            dfs(s, end + 1, results, current)\n            current.pop()\n\ndef partition(s):\n    results = []\n    dfs(s, 0, results, [])\n    return results", "def minCut(s):\n    n = len(s)\n    dp = [i - 1 for i in range(n + 1)]\n    is_palindrome = [[False] * n for _ in range(n)]\n    \n    for j in range(1, n):\n        for i in range(j, -1, -1):\n            if s[i] == s[j] and (j - i < 2 or is_palindrome[i + 1][j - 1]):\n                is_palindrome[i][j] = True\n                dp[j + 1] = min(dp[j + 1], dp[i] + 1)\n                \n    return dp[n]", "class Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\ndef cloneGraph(node, visited=None):\n    if node is None:\n        return None\n\n    if visited is None:\n        visited = {}\n\n    if node in visited:\n        return visited[node]\n\n    cloneNode = Node(node.val)\n    visited[node] = cloneNode\n\n    for neighbor in node.neighbors:\n        cloneNode.neighbors.append(cloneGraph(neighbor, visited))\n\n    return cloneNode", "def can_complete_circuit(gas, cost):\n    total_gas, total_cost, start, gas_tank = 0, 0, 0, 0\n    for i in range(len(gas)):\n        total_gas += gas[i]\n        total_cost += cost[i]\n        gas_tank += gas[i] - cost[i]\n        if gas_tank < 0:\n            start = i + 1\n            gas_tank = 0\n    return -1 if total_gas < total_cost else start", "def min_candies(ratings):\n    n = len(ratings)\n    candies = [1] * n\n\n    for i in range(1, n):\n        if ratings[i] > ratings[i - 1]:\n            candies[i] = candies[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n        if ratings[i] > ratings[i + 1]:\n            candies[i] = max(candies[i], candies[i + 1] + 1)\n\n    return sum(candies)", "def singleNumber(nums):\n    result = 0\n    for num in nums:\n        result ^= num\n    return result", "def singleNumber(nums):\n    ones, twos = 0, 0\n    for n in nums:\n        ones = (ones ^ n) & ~twos\n        twos = (twos ^ n) & ~ones\n    return ones", "class Node:\n    def __init__(self, val, next=None, random=None):\n        self.val = val\n        self.next = next\n        self.random = random\n        \ndef copyRandomList(head):\n    if not head:\n        return None\n\n    curr = head\n    while curr:\n        temp = Node(curr.val)\n        temp.next = curr.next\n        curr.next = temp\n        curr = curr.next.next\n\n    curr = head\n    while curr:\n        if curr.random:\n            curr.next.random = curr.random.next\n        curr = curr.next.next\n\n    orig = head\n    copy = head.next\n    copy_head = copy\n\n    while orig and copy:\n        orig.next = copy.next\n        orig = orig.next\n        if orig:\n            copy.next = orig.next\n            copy = copy.next\n\n    return copy_head", "def word_break(s, word_dict):\n    word_set = set(word_dict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    return dp[len(s)]", "def word_break(s, word_dict):\n    def helper(s, dict, memo):\n        if s in memo:\n            return memo[s]\n\n        res = []\n        if s in dict:\n            res.append(s)\n\n        for i in range(1, len(s)):\n            prefix = s[:i]\n            if prefix not in dict:\n                continue\n            suffix = s[i:]\n            temp = helper(suffix, dict, memo)\n            for t in temp:\n                res.append(prefix + \" \" + t)\n\n        memo[s] = res\n        return res\n\n    word_set = set(word_dict)\n    memo = {}\n    return helper(s, word_set, memo)", "def hasCycle(head):\n    slow = fast = head\n    while fast is not None and fast.next is not None:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef detectCycle(head):\n    slow, fast = head, head\n    \n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        \n        if slow == fast:\n            start = head\n            while start != slow:\n                start = start.next\n                slow = slow.next\n            return start\n    \n    return None", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reorderList(head):\n    if not head or not head.next or not head.next.next:\n        return\n\n    # Find the middle node\n    slow = head\n    fast = head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    # Reverse the second half\n    prev = None\n    curr = slow.next\n    while curr:\n        next = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next\n    slow.next = None\n\n    # Merge two halves\n    first = head\n    second = prev\n    while second:\n        next = first.next\n        first.next = second\n        first = second\n        second = next", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef preorderTraversal(root):\n    if root is None:\n        return []\n        \n    return [root.val] + preorderTraversal(root.left) + preorderTraversal(root.right)", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef postorderTraversal(root):\n    if not root:\n        return []\n\n    result = []\n    s = [root]\n    while s:\n        current = s.pop()\n        result.insert(0, current.val)\n        if current.left:\n            s.append(current.left)\n        if current.right:\n            s.append(current.right)\n\n    return result", "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        value = self.cache.pop(key)\n        self.cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.pop(key)\n        elif len(self.cache) >= self.capacity:\n            self.cache.popitem(last=False)\n        self.cache[key] = value", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef insertionSortList(head):\n    dummy = ListNode(0)\n    cur = dummy\n\n    while head:\n        while cur.next and cur.next.val < head.val:\n            cur = cur.next\n        \n        temp = head.next\n        head.next = cur.next\n        cur.next = head\n        head = temp\n        cur = dummy\n\n    return dummy.next", "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef sortList(head):\n    if not head or not head.next:\n        return head\n\n    slow, fast = head, head.next\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    mid = slow.next\n    slow.next = None\n\n    return merge(sortList(head), sortList(mid))\n\ndef merge(left, right):\n    if not left:\n        return right\n    if not right:\n        return left\n    if left.val < right.val:\n        left.next = merge(left.next, right)\n        return left\n    else:\n        right.next = merge(left, right.next)\n        return right", "from math import gcd\nfrom collections import defaultdict\n\ndef maxPoints(points):\n    n = len(points)\n    if n <= 2:\n        return n\n\n    max_count = 0\n\n    for i in range(n):\n        slope_map = defaultdict(int)\n        duplicates = 0\n        local_max = 0\n\n        for j in range(i+1, n):\n            deltaX = points[j][0] - points[i][0]\n            deltaY = points[j][1] - points[i][1]\n\n            if deltaX == 0 and deltaY == 0:\n                duplicates += 1\n                continue\n\n            g = gcd(deltaX, deltaY)\n            deltaX = deltaX // g\n            deltaY = deltaY // g\n\n            key = f\"{deltaX}_{deltaY}\"\n            slope_map[key] += 1\n            local_max = max(local_max, slope_map[key])\n\n        max_count = max(max_count, local_max + duplicates + 1)\n\n    return max_count", "def evalRPN(tokens):\n    stack = []\n    for token in tokens:\n        if token in {\"+\", \"-\", \"*\", \"/\"}:\n            b = stack.pop()\n            a = stack.pop()\n            if token == \"+\":\n                stack.append(a + b)\n            elif token == \"-\":\n                stack.append(a - b)\n            elif token == \"*\":\n                stack.append(a * b)\n            else:\n                stack.append(int(a / b))\n        else:\n            stack.append(int(token))\n    return stack[-1]", "def reverseWords(s):\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)", "def maxProduct(nums):\n    max_so_far = min_so_far = result = nums[0]\n    \n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_so_far, min_so_far = min_so_far, max_so_far\n        \n        max_so_far = max(nums[i], max_so_far * nums[i])\n        min_so_far = min(nums[i], min_so_far * nums[i])\n        result = max(result, max_so_far)\n    \n    return result", "def find_min(nums):\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        mid = left + (right - left) // 2\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n    return nums[left]", "def findMin(nums):\n    low, high = 0, len(nums) - 1\n    \n    while low < high:\n        mid = low + (high - low) // 2\n        if nums[mid] > nums[high]:\n            low = mid + 1\n        elif nums[mid] < nums[high]:\n            high = mid\n        else:\n            high -= 1\n            \n    return nums[low]", "class MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n        \n    def push(self, val: int):\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n        \n    def pop(self):\n        if self.stack[-1] == self.min_stack[-1]:\n            self.min_stack.pop()\n        self.stack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1]\n\n    def getMin(self) -> int:\n        return self.min_stack[-1]", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef upside_down_binary_tree(root):\n    if not root or not root.left:\n        return root\n    new_root = upside_down_binary_tree(root.left)\n    root.left.right = root\n    root.left.left = root.right\n    root.left = None\n    root.right = None\n    return new_root", "def read4(buf4: List[str]) -> int:\n    pass\n\ndef read(buf: List[str], n: int) -> int:\n    total_read = 0\n    buf4 = [''] * 4\n\n    while total_read < n:\n        read4_count = read4(buf4)\n        for i in range(read4_count):\n            if total_read < n:\n                buf[total_read] = buf4[i]\n                total_read += 1\n            else:\n                break\n        if read4_count < 4:\n            break\n\n    return total_read", "class Solution:\n    def __init__(self):\n        self.buffer_index = 0\n        self.buffer_len = 0\n        self.buf4 = [None] * 4\n\n    def read(self, buf, n):\n        cnt = 0\n        while cnt < n:\n            if self.buffer_index == self.buffer_len:\n                self.buffer_len = self.read4(self.buf4)\n                self.buffer_index = 0\n            if self.buffer_len == 0:\n                break\n            while cnt < n and self.buffer_index < self.buffer_len:\n                buf[cnt] = self.buf4[self.buffer_index]\n                cnt += 1\n                self.buffer_index += 1\n        return cnt\n\n    def read4(self, buf4):\n        return 0", "def lengthOfLongestSubstringTwoDistinct(s: str) -> int:\n    l, r, max_len, cur_len = 0, 0, 0, 0\n    char_count = {}\n\n    while r < len(s):\n        if s[r] in char_count:\n            char_count[s[r]] += 1\n        else:\n            char_count[s[r]] = 1\n        if len(char_count) <= 2:\n            cur_len += 1\n        else:\n            while len(char_count) > 2 and l <= r:\n                char_count[s[l]] -= 1\n                if char_count[s[l]] == 0:\n                    del char_count[s[l]]\n                l += 1\n                cur_len -= 1\n            cur_len += 1\n        max_len = max(max_len, cur_len)\n        r += 1\n    return max_len", "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef getIntersectionNode(headA, headB):\n    pA, pB = headA, headB\n    while pA is not pB:\n        pA = pA.next if pA else headB\n        pB = pB.next if pB else headA\n    return pA", "def isOneEditDistance(s: str, t: str) -> bool:\n    m, n = len(s), len(t)\n    if m > n:\n        return isOneEditDistance(t, s)\n    if n - m > 1:\n        return False\n    for i in range(m):\n        if s[i] != t[i]:\n            return s[i + (m < n):] == t[i + 1:]\n    return m + 1 == n", "def findPeakElement(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = left + (right - left) // 2\n        if nums[mid] < nums[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "from typing import List\n\ndef find_missing_ranges(nums: List[int], lower: int, upper: int) -> List[str]:\n    result = []\n    prev = lower - 1\n\n    for i, num in enumerate(nums + [upper + 1]):\n        if num - prev >= 2:\n            result.append(f\"{prev + 1}\" + (\"\" if num - prev == 2 else \"->\") + f\"{num - 1}\")\n        prev = num\n\n    return result", "def maximumGap(nums):\n    if len(nums) < 2:\n        return 0\n\n    min_val = min(nums)\n    max_val = max(nums)\n    length = len(nums)\n    bucket_size = max(1, (max_val - min_val) // (length - 1))\n    bucket_num = (max_val - min_val) // bucket_size + 1\n    buckets = [[float(\"inf\"), float(\"-inf\")] for _ in range(bucket_num)]\n\n    for num in nums:\n        idx = (num - min_val) // bucket_size\n        buckets[idx][0] = min(buckets[idx][0], num)\n        buckets[idx][1] = max(buckets[idx][1], num)\n\n    max_gap = 0\n    prev_max = min_val\n    for bucket in buckets:\n        if bucket[0] == float(\"inf\"):\n            continue\n        max_gap = max(max_gap, bucket[0] - prev_max)\n        prev_max = bucket[1]\n    return max_gap", "def compare_version(version1, version2):\n    v1 = version1.split('.')\n    v2 = version2.split('.')\n    \n    while v1 or v2:\n        num1 = int(v1.pop(0)) if v1 else 0\n        num2 = int(v2.pop(0)) if v2 else 0\n        \n        if num1 < num2:\n            return -1\n        if num1 > num2:\n            return 1\n    return 0", "def fraction_to_decimal(numerator, denominator):\n    if numerator == 0:\n        return \"0\"\n    res = []\n    if (numerator > 0) ^ (denominator > 0):\n        res.append(\"-\")\n    num = abs(numerator)\n    den = abs(denominator)\n    res.append(str(num // den))\n    num %= den\n    if num == 0:\n        return \"\".join(res)\n    res.append(\".\")\n    map = {}\n    while num:\n        if num in map:\n            res.insert(map[num], \"(\")\n            res.append(\")\")\n            break\n        map[num] = len(res)\n        num *= 10\n        res.append(str(num // den))\n        num %= den\n    return \"\".join(res)", "def twoSum(numbers, target):\n    left, right = 0, len(numbers) - 1\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        if current_sum == target:\n            return [left + 1, right + 1]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []", "def convert_to_title(columnNumber: int) -> str:\n    result = \"\"\n    while columnNumber:\n        columnNumber -= 1\n        result = chr(columnNumber % 26 + ord('A')) + result\n        columnNumber //= 26\n    return result", "def majority_element(nums):\n    count = 0\n    candidate = None\n\n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += (num == candidate) - (num != candidate)\n\n    return candidate", "class TwoSum:\n\n    def __init__(self):\n        self.nums = {}\n\n    def add(self, number: int) -> None:\n        if number in self.nums:\n            self.nums[number] += 1\n        else:\n            self.nums[number] = 1\n\n    def find(self, value: int) -> bool:\n        for num in self.nums:\n            target = value - num\n            if target in self.nums:\n                if target != num or self.nums[num] > 1:\n                    return True\n        return False", "def title_to_number(column_title: str) -> int:\n    result = 0\n    for c in column_title:\n        result = result * 26 + (ord(c) - ord('A') + 1)\n    return result", "def trailing_zeroes(n: int) -> int:\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count", "class BSTIterator:\n\n    def __init__(self, root):\n        self.stack = []\n        self.push_left(root)\n\n    def next(self):\n        top = self.stack.pop()\n        self.push_left(top.right)\n        return top.val\n\n    def hasNext(self):\n        return len(self.stack) > 0\n\n    def push_left(self, node):\n        while node:\n            self.stack.append(node)\n            node = node.left", "def calculateMinimumHP(dungeon):\n    m, n = len(dungeon), len(dungeon[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if i == m - 1 and j == n - 1:\n                dp[i][j] = min(0, dungeon[i][j])\n            elif i == m - 1:\n                dp[i][j] = min(0, dp[i][j + 1] + dungeon[i][j])\n            elif j == n - 1:\n                dp[i][j] = min(0, dp[i + 1][j] + dungeon[i][j])\n            else:\n                dp[i][j] = min(0, max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j])\n\n    return abs(dp[0][0]) + 1", "from functools import cmp_to_key\n\ndef largestNumber(nums):\n    def comparator(a, b):\n        return -1 if a + b > b + a else int(a + b < b + a)\n\n    nums_as_str = list(map(str, nums))\n    nums_as_str.sort(key=cmp_to_key(comparator))\n    return '0' if nums_as_str[0] == \"0\" else \"\".join(nums_as_str)", "def reverseWords(s: list) -> None:\n    def reverse(s, start, end):\n        while start < end:\n            s[start], s[end] = s[end], s[start]\n            start += 1\n            end -= 1\n\n    reverse(s, 0, len(s)-1)\n    start = 0\n    for i, char in enumerate(s + [' ']):\n        if char == ' ':\n            reverse(s, start, i - 1)\n            start = i + 1", "from collections import defaultdict\n\ndef findRepeatedDnaSequences(s: str):\n    dna_counter = defaultdict(int)\n    result = []\n\n    for i in range(len(s) - 9):\n        sequence = s[i:i + 10]\n        dna_counter[sequence] += 1\n        if dna_counter[sequence] == 2:\n            result.append(sequence)\n\n    return result", "def maxProfit(k, prices):\n    n = len(prices)\n    if k > n // 2:\n        return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, n))\n\n    dp = [[0] * n for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - prices[j])\n    return dp[k][n - 1]", "def rotate(nums, k):\n    n = len(nums)\n    k %= n\n    nums[:] = nums[-k:] + nums[:-k]", "def reverse_bits(n: int) -> int:\n    res = 0\n    for _ in range(32):\n        res <<= 1\n        res |= n & 1\n        n >>= 1\n    return res", "def hamming_weight(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count", "def transpose(content):\n    data = [line.split(\" \") for line in content]\n    result = [\" \".join(data[j][i] for j in range(len(data))) for i in range(len(data[0]))]\n    return result", "def rob(nums):\n    prev1, prev2 = 0, 0\n    for num in nums:\n        prev1, prev2 = max(prev2 + num, prev1), prev1\n    return prev1", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef rightSideView(root):\n    if not root:\n        return []\n\n    result = []\n    queue = [root]\n\n    while queue:\n        level_size = len(queue)\n\n        for i in range(level_size):\n            current = queue.pop(0)\n\n            if i == level_size - 1:\n                result.append(current.val)\n            \n            if current.left:\n                queue.append(current.left)\n            if current.right:\n                queue.append(current.right)\n\n    return result", "def dfs(grid, i, j):\n    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':\n        return\n\n    grid[i][j] = '0'\n    dfs(grid, i + 1, j)\n    dfs(grid, i - 1, j)\n    dfs(grid, i, j + 1)\n    dfs(grid, i, j - 1)\n\ndef numIslands(grid):\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(grid, i, j)\n    return count", "def range_bitwise_and(left: int, right: int) -> int:\n    shift = 0\n    while left != right:\n        left >>= 1\n        right >>= 1\n        shift += 1\n    return left << shift", "def get_next(n):\n    sum = 0\n    while n > 0:\n        digit = n % 10\n        sum += digit * digit\n        n //= 10\n    return sum\n\ndef is_happy(n):\n    slow, fast = n, get_next(n)\n    while fast != 1 and slow != fast:\n        slow = get_next(slow)\n        fast = get_next(get_next(fast))\n    return fast == 1", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef remove_elements(head, val):\n    sentinel = ListNode(0)\n    sentinel.next = head\n    prev, curr = sentinel, head\n\n    while curr:\n        if curr.val == val:\n            prev.next = curr.next\n        else:\n            prev = curr\n        curr = curr.next\n\n    return sentinel.next", "def countPrimes(n: int) -> int:\n    if n <= 2:\n        return 0\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    return sum(is_prime)", "def is_isomorphic(s: str, t: str) -> bool:\n    map1, map2 = {}, {}\n    for char_s, char_t in zip(s, t):\n        if char_s not in map1:\n            map1[char_s] = char_t\n        if char_t not in map2:\n            map2[char_t] = char_s\n        if map1[char_s] != char_t or map2[char_t] != char_s:\n            return False\n    return True", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverse_list(head):\n    prev = None\n    current = head\n    while current is not None:\n        next = current.next\n        current.next = prev\n        prev = current\n        current = next\n    return prev", "from collections import defaultdict, deque\n\ndef canFinish(numCourses, prerequisites):\n    adj = defaultdict(list)\n    inDegree = [0] * numCourses\n    \n    for a, b in prerequisites:\n        adj[b].append(a)\n        inDegree[a] += 1\n    \n    q = deque([i for i in range(numCourses) if inDegree[i]==0])\n    \n    while q:\n        currCourse = q.popleft()\n        numCourses -= 1\n        \n        for nextCourse in adj[currCourse]:\n            inDegree[nextCourse] -= 1\n            if inDegree[nextCourse] == 0:\n                q.append(nextCourse)\n    \n    return numCourses == 0", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True", "def minSubArrayLen(target: int, nums: List[int]) -> int:\n    left, cur_sum, min_len = 0, 0, float('inf')\n    for right in range(len(nums)):\n        cur_sum += nums[right]\n        while cur_sum >= target:\n            min_len = min(min_len, right - left + 1)\n            cur_sum -= nums[left]\n            left += 1\n    return min_len if min_len != float('inf') else 0", "from collections import deque\n\ndef findOrder(numCourses, prerequisites):\n    in_degree = [0] * numCourses\n    adj_list = [[] for _ in range(numCourses)]\n    \n    for p in prerequisites:\n        adj_list[p[1]].append(p[0])\n        in_degree[p[0]] += 1\n    \n    q = deque([i for i in range(numCourses) if in_degree[i] == 0])\n    order = []\n    \n    while q:\n        curr = q.popleft()\n        order.append(curr)\n        for next in adj_list[curr]:\n            in_degree[next] -= 1\n            if in_degree[next] == 0:\n                q.append(next)\n    \n    return order if len(order) == numCourses else []", "class TrieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.is_word = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        current = self.root\n        for c in word:\n            index = ord(c) - ord('a')\n            if current.children[index] is None:\n                current.children[index] = TrieNode()\n            current = current.children[index]\n        current.is_word = True\n\n    def search(self, word: str) -> bool:\n        return self._search_helper(self.root, word, 0)\n\n    def _search_helper(self, node: TrieNode, word: str, index: int) -> bool:\n        if index == len(word):\n            return node.is_word\n\n        if word[index] == '.':\n            for child_node in node.children:\n                if child_node is not None and self._search_helper(child_node, word, index + 1):\n                    return True\n            return False\n        else:\n            child_node = node.children[ord(word[index]) - ord('a')]\n            if child_node is None:\n                return False\n            return self._search_helper(child_node, word, index + 1)", "def findWords(board, words):\n    def dfs(board, word, index, i, j, visited):\n        if index == len(word):\n            return True\n        if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or visited[i][j] or board[i][j] != word[index]:\n            return False\n        visited[i][j] = True\n        found = dfs(board, word, index + 1, i - 1, j, visited) or \\\n                dfs(board, word, index + 1, i + 1, j, visited) or \\\n                dfs(board, word, index + 1, i, j - 1, visited) or \\\n                dfs(board, word, index + 1, i, j + 1, visited)\n        visited[i][j] = False\n        return found\n\n    res = []\n    for word in words:\n        if any(dfs(board, word, 0, i, j, [[False] * len(board[0]) for _ in range(len(board))])\n               for i in range(len(board)) for j in range(len(board[0]))):\n            res.append(word)\n    return res", "def rob(nums):\n    if len(nums) == 1:\n        return nums[0]\n    prev, curr = 0, 0\n    for i in range(len(nums) - 1):\n        temp = max(curr, prev + nums[i])\n        prev, curr = curr, temp\n    res = curr\n    prev, curr = 0, 0\n    for i in range(1, len(nums)):\n        temp = max(curr, prev + nums[i])\n        prev, curr = curr, temp\n    return max(res, curr)", "def shortest_palindrome(s: str) -> str:\n    n = len(s)\n    rev_s = s[::-1]\n    \n    for i in range(n):\n        if s[:n - i] == rev_s[i:]:\n            return rev_s[:i] + s\n    return \"\"", "def findKthLargest(nums: List[int], k: int) -> int:\n    nums.sort(reverse=True)\n    return nums[k-1]", "def combinationSum3(k, n):\n    def helper(k, n, current, current_comb, result):\n        if k == 0 and n == 0:\n            result.append(list(current_comb))\n        elif k > 0 and n > 0:\n            for i in range(current + 1, 10):\n                current_comb.append(i)\n                helper(k - 1, n - i, i, current_comb, result)\n                current_comb.pop()\n\n    result = []\n    helper(k, n, 0, [], result)\n    return result", "def containsDuplicate(nums):\n    return len(nums) != len(set(nums))", "from sortedcontainers import SortedList\n\ndef getSkyline(buildings):\n    points = []\n    for l, r, h in buildings:\n        points.append((l, -h))\n        points.append((r, h))\n    points.sort()\n    heights = SortedList([0])\n    prev = 0\n    skyline = []\n    for x, h in points:\n        if h < 0:\n            heights.add(-h)\n        else:\n            heights.remove(h)\n        cur = heights[-1]\n        if cur != prev:\n            skyline.append([x, cur])\n            prev = cur\n    return skyline", "def containsNearbyDuplicate(nums, k):\n    value_index_map = {}\n    for i, num in enumerate(nums):\n        if num in value_index_map and i - value_index_map[num] <= k:\n            return True\n        value_index_map[num] = i\n    return False", "from sortedcontainers import SortedList\n\ndef containsNearbyAlmostDuplicate(nums, k, t):\n    window = SortedList()\n    for i in range(len(nums)):\n        if i > k:\n            window.remove(nums[i - k - 1])\n        pos = window.bisect_left(nums[i] - t)\n        if pos != len(window) and window[pos] - nums[i] <= t:\n            return True\n        window.add(nums[i])\n    return False", "def maximalSquare(matrix):\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    maxSize = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == '1':\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                maxSize = max(maxSize, dp[i][j])\n\n    return maxSize * maxSize", "class TreeNode:\n    def __init__(self, left=None, right=None):\n        self.left = left\n        self.right = right\n\ndef count_nodes(root):\n    if not root:\n        return 0\n    ld = rd = 0\n    l = r = root\n\n    while l:\n        l = l.left\n        ld += 1\n\n    while r:\n        r = r.right\n        rd += 1\n\n    if ld == rd:\n        return (1 << ld) - 1\n    return 1 + count_nodes(root.left) + count_nodes(root.right)", "def total_area(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):\n    area1 = (ax2 - ax1) * (ay2 - ay1)\n    area2 = (bx2 - bx1) * (by2 - by1)\n\n    overlap_width = min(ax2, bx2) - max(ax1, bx1)\n    overlap_height = min(ay2, by2) - max(ay1, by1)\n\n    overlap_area = max(overlap_width, 0) * max(overlap_height, 0)\n\n    return area1 + area2 - overlap_area", "def calculate(s: str) -> int:\n    result = 0\n    sign = 1\n    num = 0\n    st = []\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        else:\n            result += sign * num\n            num = 0\n            if c == '+':\n                sign = 1\n            elif c == '-':\n                sign = -1\n            elif c == '(':\n                st.append(result)\n                st.append(sign)\n                result = 0\n                sign = 1\n            elif c == ')':\n                prev_sign = st.pop()\n                prev_result = st.pop()\n                result = prev_result + prev_sign * result\n    result += sign * num\n    return result", "from collections import deque\n\nclass MyStack:\n\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        self.q2.append(x)\n        while self.q1:\n            self.q2.append(self.q1.popleft())\n        self.q1, self.q2 = self.q2, self.q1\n\n    def pop(self) -> int:\n        return self.q1.popleft()\n\n    def top(self) -> int:\n        return self.q1[0]\n\n    def empty(self) -> bool:\n        return not self.q1", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef invert_tree(root):\n    if root is None:\n        return None\n    root.left, root.right = invert_tree(root.right), invert_tree(root.left)\n    return root", "def calculate(s: str) -> int:\n    result, num, sign, stack = 0, 0, 1, []\n\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c == '+':\n            result += sign * num\n            num = 0\n            sign = 1\n        elif c == '-':\n            result += sign * num\n            num = 0\n            sign = -1\n        elif c == '(':\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif c == ')':\n            result += sign * num\n            num = 0\n            result *= stack.pop()\n            result += stack.pop()\n    \n    if num:\n        result += sign * num\n        \n    return result", "from typing import List\n\ndef find_ranges(nums: List[int]) -> List[str]:\n    result = []\n    n = len(nums)\n    if n == 0: \n        return result\n\n    start = nums[0]\n    for i in range(1, n):\n        if nums[i] > nums[i-1] + 1:\n            if start == nums[i-1]:\n                result.append(str(start))\n            else:\n                result.append(str(start) + \"->\" + str(nums[i-1]))\n            start = nums[i]\n\n    if start == nums[n-1]:\n        result.append(str(start))\n    else:\n        result.append(str(start) + \"->\" + str(nums[n-1]))\n\n    return result", "def majorityElement(nums):\n    n = len(nums)\n    count = {}\n    result = []\n\n    for num in nums:\n        if num not in count:\n            count[num] = 1\n        else:\n            count[num] += 1\n        if count[num] > n / 3 and num not in result:\n            result.append(num)\n\n    return result", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef kthSmallest(root, k):\n    stk = []\n    curr = root\n    \n    while True:\n        while curr:\n            stk.append(curr)\n            curr = curr.left\n        \n        curr = stk.pop()\n        \n        k -= 1\n        if k == 0:\n            return curr.val\n        \n        curr = curr.right", "def is_power_of_two(n):\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0", "class MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self) -> bool:\n        return not self.stack1 and not self.stack2", "def countDigitOne(n):\n    count = 0\n    i = 1\n    while i <= n:\n        divider = i * 10\n        count += (n // divider) * i + min(max(n % divider - i + 1, 0), i)\n        i *= 10\n    return count", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef isPalindrome(head):\n    if not head or not head.next:\n        return True\n\n    fast, slow, prev = head, head, None\n    while fast and fast.next:\n        fast = fast.next.next\n        temp = slow.next\n        slow.next = prev\n        prev = slow\n        slow = temp\n\n    if fast:\n        slow = slow.next\n\n    while prev and prev.val == slow.val:\n        prev = prev.next\n        slow = slow.next\n\n    return prev == None", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef lowest_common_ancestor(root, p, q):\n    if root is None or root == p or root == q:\n        return root\n\n    left = lowest_common_ancestor(root.left, p, q)\n    right = lowest_common_ancestor(root.right, p, q)\n\n    if left is not None and right is not None:\n        return root\n    else:\n        return left if left is not None else right", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef lowestCommonAncestor(root, p, q):\n    if not root or root == p or root == q:\n        return root\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n    return right if left is None else (left if right is None else root)", "def deleteNode(node):\n    next_node = node.next\n    node.val = next_node.val\n    node.next = next_node.next", "def productExceptSelf(nums):\n    n = len(nums)\n    answer = [1] * n\n    \n    left = 1\n    for i in range(n):\n        answer[i] *= left\n        left *= nums[i]\n    \n    right = 1\n    for i in range(n - 1, -1, -1):\n        answer[i] *= right\n        right *= nums[i]\n    \n    return answer", "from collections import deque\n\ndef maxSlidingWindow(nums, k):\n    dq = deque()\n    result = []\n\n    for i in range(len(nums)):\n        while dq and dq[0] < i - k + 1:\n            dq.popleft()\n\n        while dq and nums[dq[-1]] < nums[i]:\n            dq.pop()\n\n        dq.append(i)\n\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n\n    return result", "def searchMatrix(matrix, target):\n    row, col = len(matrix) - 1, 0\n    while row >= 0 and col < len(matrix[0]):\n        if matrix[row][col] > target:\n            row -= 1\n        elif matrix[row][col] < target:\n            col += 1\n        else:\n            return True\n    return False", "def diffWaysToCompute(input: str):\n    result = []\n    for i in range(len(input)):\n        c = input[i]\n        if c == '+' or c == '-' or c == '*':\n            left = diffWaysToCompute(input[:i])\n            right = diffWaysToCompute(input[i + 1:])\n            for l in left:\n                for r in right:\n                    if c == '+': result.append(l + r)\n                    elif c == '-': result.append(l - r)\n                    elif c == '*': result.append(l * r)\n    if not result:\n        result.append(int(input))\n    return result", "def is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n\n    counts = {}\n    for c in s:\n        if c in counts:\n            counts[c] += 1\n        else:\n            counts[c] = 1\n\n    for c in t:\n        if c not in counts or counts[c] == 0:\n            return False\n        counts[c] -= 1\n\n    return True", "def shortestDistance(wordsDict, word1, word2):\n    idx1, idx2, minDistance = -1, -1, float('inf')\n    for i, word in enumerate(wordsDict):\n        if word == word1:\n            idx1 = i\n        if word == word2:\n            idx2 = i\n        if idx1 != -1 and idx2 != -1:\n            minDistance = min(minDistance, abs(idx1 - idx2))\n    return minDistance", "class WordDistance:\n\n    def __init__(self, wordsDict):\n        self.word_indexes = {}\n        for i, word in enumerate(wordsDict):\n            if word not in self.word_indexes:\n                self.word_indexes[word] = []\n            self.word_indexes[word].append(i)\n\n    def shortest(self, word1, word2):\n        indexes1 = self.word_indexes[word1]\n        indexes2 = self.word_indexes[word2]\n        i, j, min_dist = 0, 0, float('inf')\n\n        while i < len(indexes1) and j < len(indexes2):\n            min_dist = min(min_dist, abs(indexes1[i] - indexes2[j]))\n            if indexes1[i] < indexes2[j]:\n                i += 1\n            else:\n                j += 1\n\n        return min_dist", "def shortest_distance(words_dict, word1, word2):\n    index1, index2, min_distance = -1, -1, float('inf')\n    for i, word in enumerate(words_dict):\n        if word == word1:\n            index1 = i\n        if word == word2:\n            index2 = i\n        if index1 != -1 and(index2 != -1):\n            min_distance = min(min_distance, abs(index1 - index2))\n    return min_distance", "def isStrobogrammatic(num: str) -> bool:\n    lookup = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}\n    left, right = 0, len(num) - 1\n    while left <= right:\n        if num[left] not in lookup or lookup[num[left]] != num[right]:\n            return False\n        left += 1\n        right -= 1\n    return True", "def findStrobogrammatic(n):\n    def helper(n, m):\n        if n == 0:\n            return [\"\"]\n        if n == 1:\n            return [\"0\", \"1\", \"8\"]\n\n        list = helper(n - 2, m)\n        res = []\n\n        for s in list:\n            if n != m:\n                res.append(\"0\" + s + \"0\")\n\n            res.append(\"1\" + s + \"1\")\n            res.append(\"6\" + s + \"9\")\n            res.append(\"8\" + s + \"8\")\n            res.append(\"9\" + s + \"6\")\n\n        return res\n\n    return helper(n, n)", "def strobogrammaticInRange(low, high):\n    count = 0\n    for len in range(len(low), len(high)+1):\n        count += 1 if low <= helper(len, len) <= high else 0\n    return count\n\ndef helper(m, n):\n    if m == 0:\n        return \"\"\n    if m == 1:\n        return \"0 1 8\"\n    if n == 0:\n        return \"11 69 88 96\"\n    res = \"\"\n    for a in helper(m-2, n).split():\n        if m != n:\n            res += a + \"0\" + a + \" \"\n        res += a + \"1\" + a + \" \"\n        res += a + \"6\" + a + \" \"\n        res += a + \"8\" + a + \" \"\n        res += a + \"9\" + a + \" \"\n    return res", "from collections import defaultdict\n\ndef groupStrings(strings):\n    groups = defaultdict(list)\n\n    for s in strings:\n        key = tuple((ord(c) - ord(s[0])) % 26 for c in s)\n        groups[key].append(s)\n\n    return list(groups.values())", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def countUnivalSubtrees(self, root: TreeNode) -> int:\n        count = 0\n\n        def helper(node):\n            nonlocal count\n            if node is None:\n                return True\n\n            left = helper(node.left)\n            right = helper(node.right)\n\n            if left and right:\n                if node.left and node.val != node.left.val:\n                    return False\n                if node.right and node.val != node.right.val:\n                    return False\n                count += 1\n                return True\n\n            return False\n\n        helper(root)\n        return count", "class Vector2D:\n    def __init__(self, vec):\n        self.vec = vec\n        self.row = 0\n        self.col = 0\n\n    def next(self):\n        val = self.vec[self.row][self.col]\n        self.col += 1\n        return val\n\n    def hasNext(self):\n        while self.row < len(self.vec):\n            if self.col < len(self.vec[self.row]):\n                return True\n            self.row += 1\n            self.col = 0\n        return False", "def can_attend_meetings(intervals):\n    intervals.sort()\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i - 1][1]:\n            return False\n\n    return True", "import heapq\n\ndef minMeetingRooms(intervals):\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n\n    min_heap = [intervals[0][1]]\n    for start, end in intervals[1:]:\n        if start >= min_heap[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, end)\n\n    return len(min_heap)", "def getFactors(n):\n    def helper(n, start, path, result):\n        if n == 1:\n            if len(path) > 1:\n                result.append(path[:])\n            return\n\n        for i in range(start, n + 1):\n            if n % i == 0:\n                path.append(i)\n                helper(n // i, i, path, result)\n                path.pop()\n\n    result = []\n    helper(n, 2, [], result)\n    return result", "def isValidPreorder(preorder: List[int]) -> bool:\n    stack = []\n    lower_bound = float('-inf')\n    for num in preorder:\n        if num < lower_bound:\n            return False\n        while stack and num > stack[-1]:\n            lower_bound = stack.pop()\n        stack.append(num)\n    return True", "def minCost(costs: List[List[int]]) -> int:\n    if not costs:\n        return 0\n    for i in range(1, len(costs)):\n        costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])\n        costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])\n        costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])\n    return min(costs[-1][0], costs[-1][1], costs[-1][2])", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef binary_tree_paths(root: TreeNode):\n    if not root:\n        return []\n    if not root.left and not root.right:\n        return [str(root.val)]\n    paths = []\n    for path in binary_tree_paths(root.left):\n        paths.append(str(root.val) + \"->\" + path)\n    for path in binary_tree_paths(root.right):\n        paths.append(str(root.val) + \"->\" + path)\n    return paths", "def addDigits(num: int) -> int:\n    return 1 + (num - 1) % 9", "def threeSumSmaller(nums, target):\n    count = 0\n    nums.sort()\n    for i in range(len(nums)):\n        j, k = i + 1, len(nums) - 1\n        while j < k:\n            if nums[i] + nums[j] + nums[k] < target:\n                count += k - j\n                j += 1\n            else:\n                k -= 1\n    return count", "def singleNumber(nums):\n    xor_all = 0\n    for num in nums:\n        xor_all ^= num\n\n    bit = xor_all & -xor_all\n    n1 = 0\n    n2 = 0\n    for num in nums:\n        if num & bit:\n            n1 ^= num\n        else:\n            n2 ^= num\n\n    return n1, n2", "from typing import List\n\ndef isTree(n: int, edges: List[List[int]]) -> bool:\n    neighbors = [[] for _ in range(n)]\n    for edge in edges:\n        neighbors[edge[0]].append(edge[1])\n        neighbors[edge[1]].append(edge[0])\n    visited = [False] * n\n    if hasCycle(neighbors, visited, -1, 0): return False\n    return all(visited)\n\ndef hasCycle(neighbors: List[List[int]], visited: List[bool], parent: int, node: int) -> bool:\n    visited[node] = True\n    for neighbor in neighbors[node]:\n        if (neighbor != parent and visited[neighbor]) or (not visited[neighbor] and hasCycle(neighbors, visited, node, neighbor)): return True\n    return False", "def is_ugly(n: int) -> bool:\n    if n <= 0:\n        return False\n    for factor in [2, 3, 5]:\n        while n % factor == 0:\n            n //= factor\n    return n == 1", "def nthUglyNumber(n: int) -> int:\n    ugly_numbers = [0] * n\n    ugly_numbers[0] = 1\n    i2, i3, i5 = 0, 0, 0\n\n    for i in range(1, n):\n        ugly_numbers[i] = min(ugly_numbers[i2] * 2, ugly_numbers[i3] * 3, ugly_numbers[i5] * 5)\n        if ugly_numbers[i] == ugly_numbers[i2] * 2: i2 += 1\n        if ugly_numbers[i] == ugly_numbers[i3] * 3: i3 += 1\n        if ugly_numbers[i] == ugly_numbers[i5] * 5: i5 += 1\n\n    return ugly_numbers[n - 1]", "def min_cost(costs: List[List[int]]) -> int:\n    if not costs:\n        return 0\n\n    n, k = len(costs), len(costs[0])\n\n    for i in range(1, n):\n        for j in range(k):\n            min_cost = float(\"inf\")\n            for l in range(k):\n                if l == j:\n                    continue\n                min_cost = min(min_cost, costs[i - 1][l])\n            costs[i][j] += min_cost\n\n    return min(costs[n - 1])", "def canPermutePalindrome(s: str) -> bool:\n    count = {}\n    for c in s:\n        if c in count:\n            count[c] += 1\n        else:\n            count[c] = 1\n    odd_count = 0\n    for value in count.values():\n        if value % 2:\n            odd_count += 1\n    return odd_count <= 1", "from collections import Counter\nfrom itertools import permutations\n\ndef generatePalindromes(s):\n    result = []\n    char_count = Counter(s)\n\n    mid_char = \"\"\n    half_str = []\n    num_ocurrences = 0\n\n    for char, count in char_count.items():\n        if count % 2 == 1:\n            num_ocurrences += 1\n            mid_char = char\n        half_str.extend([char] * (count // 2))\n\n        if num_ocurrences > 1:\n            return result\n\n    for perm in set(permutations(half_str)):\n        palindrome = \"\".join(perm) + mid_char + \"\".join(reversed(perm))\n        result.append(palindrome)\n\n    return result", "def missingNumber(nums):\n    n = len(nums)\n    expected_sum = (n * (n + 1)) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum", "from collections import deque, defaultdict, Counter\n\ndef alienOrder(words):\n    graph = defaultdict(set)\n    in_degree = Counter({c: 0 for word in words for c in word})\n    \n    for word1, word2 in zip(words, words[1:]):\n        found = False\n        for c1, c2 in zip(word1, word2):\n            if c1 != c2:\n                if c2 not in graph[c1]:\n                    graph[c1].add(c2)\n                    in_degree[c2] += 1\n                found = True\n                break\n        if not found and len(word1) > len(word2):\n            return \"\"\n    \n    q = deque([c for c in in_degree if in_degree[c] == 0])\n    result = []\n    while q:\n        c = q.popleft()\n        result.append(c)\n        \n        for neigh in graph[c]:\n            in_degree[neigh] -= 1\n            if in_degree[neigh] == 0:\n                q.append(neigh)\n                 \n    if len(result) < len(in_degree):\n        return \"\"\n    \n    return \"\".join(result)", "class Solution:\n    def closestValue(self, root: TreeNode, target: float) -> int:\n        closest = root.val\n        while root:\n            if abs(target - closest) > abs(target - root.val):\n                closest = root.val\n            root = root.left if target < root.val else root.right\n        return closest", "def encode(strs):\n    encoded_string = \"\"\n    for s in strs:\n        encoded_string += str(len(s)) + \"#\" + s\n    return encoded_string\n\ndef decode(s):\n    strs = []\n    i = 0\n    while i < len(s):\n        delimiter_pos = s.find('#', i)\n        length = int(s[i:delimiter_pos])\n        strs.append(s[delimiter_pos + 1:delimiter_pos + 1 + length])\n        i = delimiter_pos + 1 + length\n    return strs", "from heapq import heappush, heappop\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef closestKValues(root, target, k):\n    values = []\n    max_heap = []\n\n    def inorder_traverse(node):\n        if not node:\n            return\n        inorder_traverse(node.left)\n        heappush(max_heap, (-abs(node.val - target), node.val))\n        if len(max_heap) > k:\n            heappop(max_heap)\n        inorder_traverse(node.right)\n\n    inorder_traverse(root)\n    while max_heap:\n        _, val = heappop(max_heap)\n        values.append(val)\n    return values", "class Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n        LESS_THAN_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        TENS = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        THOUSANDS = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n\n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 20:\n                return LESS_THAN_20[num] + \" \"\n            elif num < 100:\n                return TENS[num // 10] + \" \" + helper(num % 10)\n            else:\n                return LESS_THAN_20[num // 100] + \" Hundred \" + helper(num % 100)\n\n        result = \"\"\n        i = 0\n        while num > 0:\n            if num % 1000 != 0:\n                result = helper(num % 1000) + THOUSANDS[i] + \" \" + result\n            num //= 1000\n            i += 1\n        return result.strip()", "def hIndex(citations: List[int]) -> int:\n    citations.sort(reverse=True)\n    h = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h = i + 1\n        else:\n            break\n    return h", "def hIndex(citations: List[int]) -> int:\n    n = len(citations)\n    left, right = 0, n - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if citations[mid] == n - mid:\n            return n - mid\n        elif citations[mid] < n - mid:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return n - left", "def numWays(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    same = k\n    different = k * (k - 1)\n    for i in range(2, n):\n        temp = different\n        different = (same + different) * (k - 1)\n        same = temp\n    return same + different", "def knows(a: int, b:int) -> bool:\n    pass\n\ndef findCelebrity(n: int) -> int:\n    candidate = 0\n    for i in range(1, n):\n        if knows(candidate, i):\n            candidate = i\n    \n    for i in range(n):\n        if i != candidate and (knows(candidate, i) or not knows(i, candidate)):\n            return -1\n    return candidate", "def first_bad_version(n):\n    left, right = 1, n\n    while left < right:\n        mid = left + (right - left) // 2\n        if is_bad_version(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left", "def numSquares(n):\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n            j += 1\n            \n    return dp[n]", "def wiggleSort(nums):\n    for i in range(1, len(nums)):\n        if (i % 2 == 0 and nums[i] > nums[i-1]) or (i % 2 == 1 and nums[i] < nums[i-1]):\n            nums[i], nums[i-1] = nums[i-1], nums[i]", "class ZigzagIterator:\n\n    def __init__(self, v1: List[int], v2: List[int]):\n        self.v1, self.v2 = v1, v2\n        self.index1, self.index2 = 0, 0\n\n    def next(self) -> int:\n        if self.index1 < len(self.v1) and (self.index1 <= self.index2 or self.index2 == len(self.v2)):\n            result = self.v1[self.index1]\n            self.index1 += 1\n            return result\n        if self.index2 < len(self.v2) and (self.index2 < self.index1 or self.index1 == len(self.v1)):\n            result = self.v2[self.index2]\n            self.index2 += 1\n            return result\n\n    def hasNext(self) -> bool:\n        return self.index1 < len(self.v1) or self.index2 < len(self.v2)", "from typing import List\n\ndef addOperators(num: str, target: int) -> List[str]:\n    def helper(num, target, pos, currVal, prevVal, currExpr):\n        if pos == len(num):\n            if currVal == target:\n                res.append(currExpr)\n            return\n\n        for i in range(pos, len(num)):\n            if i != pos and num[pos] == '0':\n                break\n\n            val = int(num[pos:i + 1])\n            if pos == 0:\n                helper(num, target, i + 1, val, val, currExpr + num[pos:i + 1])\n            else:\n                helper(num, target, i + 1, currVal + val, val, currExpr + \"+\" + num[pos:i + 1])\n                helper(num, target, i + 1, currVal - val, -val, currExpr + \"-\" + num[pos:i + 1])\n                helper(num, target, i + 1, currVal - prevVal + prevVal * val, prevVal * val, currExpr + \"*\" + num[pos:i + 1])\n\n    res = []\n    helper(num, target, 0, 0, 0, \"\")\n    return res", "def moveZeroes(nums):\n    index = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[index] = nums[i]\n            index += 1\n    for i in range(index, len(nums)):\n        nums[i] = 0", "class PeekingIterator:\n    def __init__(self, iterator):\n        self.iterator = iterator\n        self.next_val = next(self.iterator, None)\n\n    def peek(self):\n        return self.next_val\n\n    def next(self):\n        current_val = self.next_val\n        self.next_val = next(self.iterator, None)\n        return current_val\n\n    def hasNext(self):\n        return self.next_val is not None", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef inorder_successor(root: TreeNode, p: TreeNode) -> TreeNode:\n    successor = None\n    while root:\n        if root.val > p.val:\n            successor = root\n            root = root.left\n        else:\n            root = root.right\n    return successor", "from collections import deque\n\ndef wallsAndGates(rooms):\n    m, n = len(rooms), len(rooms[0])\n    q = deque()\n    INF = 2147483647\n\n    for i in range(m):\n        for j in range(n):\n            if rooms[i][j] == 0:\n                q.append((i, j))\n\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    while q:\n        i, j = q.popleft()\n\n        for d in directions:\n            ni, nj = i + d[0], j + d[1]\n\n            if 0 <= ni < m and 0 <= nj < n and rooms[ni][nj] == INF:\n                rooms[ni][nj] = rooms[i][j] + 1\n                q.append((ni, nj))", "def findDuplicate(nums):\n    slow = nums[0]\n    fast = nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow", "class ValidWordAbbr:\n\n    def __init__(self, dictionary):\n        self.word_map = {}\n        for word in dictionary:\n            abbr = self.get_abbreviation(word)\n            if abbr not in self.word_map:\n                self.word_map[abbr] = {word}\n            else:\n                self.word_map[abbr].add(word)\n\n    def isUnique(self, word):\n        abbr = self.get_abbreviation(word)\n        abbr_group = self.word_map.get(abbr, set())\n        return len(abbr_group) == 0 or (len(abbr_group) == 1 and word in abbr_group)\n\n    def get_abbreviation(self, word):\n        n = len(word)\n        return word if n <= 2 else word[0] + str(n - 2) + word[-1]", "def gameOfLife(board):\n    m, n = len(board), len(board[0])\n    result = [[0] * n for _ in range(m)]\n    dirs = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n    \n    for i in range(m):\n        for j in range(n):\n            liveNeighbors = 0\n            \n            for dir in dirs:\n                newRow = i + dir[0]\n                newCol = j + dir[1]\n                \n                if newRow >= 0 and newRow < m and newCol >= 0 and newCol < n and board[newRow][newCol] == 1:\n                    liveNeighbors += 1\n            \n            if board[i][j] == 1 and (liveNeighbors == 2 or liveNeighbors == 3):\n                result[i][j] = 1\n            elif board[i][j] == 0 and liveNeighbors == 3:\n                result[i][j] = 1\n                \n    return result", "def word_pattern(pattern, s):\n    words = s.split()\n    if len(pattern) != len(words):\n        return False\n\n    char_map, word_map = {}, {}\n    for c, word in zip(pattern, words):\n        if c not in char_map and word not in word_map:\n            char_map[c] = word\n            word_map[word] = c\n        else:\n            if char_map.get(c) != word or word_map.get(word) != c:\n                return False\n\n    return True", "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(p_index, s_index, pattern_map, words):\n        if p_index == len(pattern) and s_index == len(s):\n            return True\n        if p_index == len(pattern) or s_index == len(s):\n            return False\n\n        p = pattern[p_index]\n        if p in pattern_map:\n            word = pattern_map[p]\n            if not s.startswith(word, s_index):\n                return False\n            return backtrack(p_index + 1, s_index + len(word), pattern_map, words)\n        else:\n            for length in range(1, len(s) - s_index + 1):\n                word = s[s_index : s_index + length]\n                if word in words:\n                    continue\n                pattern_map[p] = word\n                words.add(word)\n                if backtrack(p_index + 1, s_index + length, pattern_map, words):\n                    return True\n                pattern_map.pop(p)\n                words.remove(word)\n        return False\n\n    return backtrack(0, 0, {}, set())", "def canWinNim(n):\n    return n % 4 != 0", "def generate_possible_next_moves(current_state):\n    result = []\n    for i in range(1, len(current_state)):\n        if current_state[i] == '+' and current_state[i - 1] == '+':\n            result.append(current_state[:i - 1] + '--' + current_state[i + 1:])\n    return result", "def canWin(currentState: str) -> bool:\n    for i in range(len(currentState) - 1):\n        if currentState[i] == '+' and currentState[i + 1] == '+':\n            temp = currentState[:i] + \"--\" + currentState[i + 2:]\n            if not canWin(temp):\n                return True\n    return False", "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.left = []  # max heap\n        self.right = []  # min heap\n\n    def addNum(self, num: int) -> None:\n        if not self.left or num <= -self.left[0]:\n            heapq.heappush(self.left, -num)\n        else:\n            heapq.heappush(self.right, num)\n        \n        if len(self.left) < len(self.right):\n            heapq.heappush(self.left, -heapq.heappop(self.right))\n        elif len(self.left) > len(self.right) + 1:\n            heapq.heappush(self.right, -heapq.heappop(self.left))\n\n    def findMedian(self) -> float:\n        if len(self.left) == len(self.right):\n            return (-self.left[0] + self.right[0]) / 2\n        else:\n            return -self.left[0]", "def minTotalDistance(grid):\n    m, n = len(grid), len(grid[0])\n    rows, cols = [], []\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                rows.append(i)\n                cols.append(j)\n\n    cols.sort()\n    row_median, col_median = rows[len(rows) // 2], cols[len(cols) // 2]\n    distance = sum(abs(i - row_median) for i in rows) + sum(abs(j - col_median) for j in cols)\n    return distance", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef serialize(root):\n    if not root: return \"null,\"\n    return str(root.val) + \",\" + serialize(root.left) + serialize(root.right)\n\ndef deserialize(data):\n    def deserialize_helper(values):\n        val = values.pop(0)\n        if val == 'null': return None\n        root = TreeNode(int(val))\n        root.left = deserialize_helper(values)\n        root.right = deserialize_helper(values)\n        return root\n\n    values = data.split(\",\")\n    return deserialize_helper(values[:-1])  # Excluding the last empty element", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef longest_consecutive_sequence(root, longest_path):\n    if root is None:\n        return 0\n    left = longest_consecutive_sequence(root.left, longest_path)\n    right = longest_consecutive_sequence(root.right, longest_path)\n    curr_path = 1\n    if root.left and root.left.val == root.val + 1:\n        curr_path = max(curr_path, left + 1)\n    if root.right and root.right.val == root.val + 1:\n        curr_path = max(curr_path, right + 1)\n    longest_path[0] = max(longest_path[0], curr_path)\n    return curr_path\n\ndef longest_consecutive(root):\n    longest_path = [0]\n    longest_consecutive_sequence(root, longest_path)\n    return longest_path[0]", "def get_hint(secret: str, guess: str) -> str:\n    bulls = cows = 0\n    secret_count = [0] * 10\n    guess_count = [0] * 10\n\n    for i in range(len(secret)):\n        if secret[i] == guess[i]:\n            bulls += 1\n        else:\n            secret_count[int(secret[i])] += 1\n            guess_count[int(guess[i])] += 1\n   \n    for i in range(10):\n        cows += min(secret_count[i], guess_count[i])\n    \n    return f\"{bulls}A{cows}B\"", "def lengthOfLIS(nums):\n    dp = [1] * len(nums)\n    max_length = 1\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n        max_length = max(max_length, dp[i])\n    return max_length", "from collections import deque\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        visited = set()\n        queue = deque([s])\n        result = []\n        found = False\n\n        while queue:\n            cur = queue.popleft()\n\n            if self.is_valid(cur):\n                found = True\n                result.append(cur)\n\n            if found: continue\n\n            for i in range(len(cur)):\n                if cur[i] == '(' or cur[i] == ')':\n                    next_str = cur[:i] + cur[i+1:]\n                    if next_str not in visited:\n                        visited.add(next_str)\n                        queue.append(next_str)\n\n        return result\n\n    def is_valid(self, s: str) -> bool:\n        count = 0\n        for c in s:\n            if c == '(': count += 1\n            if c == ')':\n                count -= 1\n                if count < 0: return False\n        return count == 0", "def minArea(image, x, y):\n    top, bottom, left, right = x, x, y, y\n    for i, row in enumerate(image):\n        for j, cell in enumerate(row):\n            if cell == '1':\n                top, bottom = min(top, i), max(bottom, i)\n                left, right = min(left, j), max(right, j)\n    return (bottom - top + 1) * (right - left + 1)", "class NumArray:\n\n    def __init__(self, nums: List[int]):\n        self.pSum = [0] * (len(nums) + 1)\n        for i, num in enumerate(nums):\n            self.pSum[i + 1] = self.pSum[i] + num\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.pSum[right + 1] - self.pSum[left]", "class NumMatrix:\n\n    def __init__(self, matrix: List[List[int]]):\n        m, n = len(matrix), len(matrix[0])\n        self.dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                self.dp[i][j] = self.dp[i - 1][j] + self.dp[i][j - 1] - self.dp[i - 1][j - 1] + matrix[i - 1][j - 1]\n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n        return self.dp[row2 + 1][col2 + 1] - self.dp[row1][col2 + 1] - self.dp[row2 + 1][col1] + self.dp[row1][col1]", "def numIslands2(m: int, n: int, positions: List[List[int]]) -> List[int]:\n    def index(x: int, y: int) -> int:\n        return x * n + y\n    \n    def find(x: int) -> int:\n        if roots[x] != x:\n            roots[x] = find(roots[x])\n        return roots[x]\n\n    roots = [-1] * (m * n)\n    dirs = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n    islandCount = 0\n    result = []\n\n    for i, j in positions:\n        idx = index(i, j)\n        if roots[idx] != -1:\n            result.append(islandCount)\n            continue\n        islandCount += 1\n        roots[idx] = idx\n        for dx, dy in dirs:\n            ni, nj = i + dx, j + dy\n            neighbor = index(ni, nj)\n            if 0 <= ni < m and 0 <= nj < n and roots[neighbor] != -1:\n                root_neighbor = find(neighbor)\n                if idx != root_neighbor:\n                    roots[root_neighbor] = idx\n                    islandCount -= 1\n        result.append(islandCount)\n    return result", "def isAdditiveNumber(num):\n    for i in range(1, len(num) // 2 + 1):\n        for j in range(1, (len(num) - i) // 2 + 1):\n            if check(num[:i], num[i:i+j], num[i+j:]):\n                return True\n    return False\n\ndef check(num1, num2, remaining):\n    if (len(num1) > 1 and num1[0] == '0') or (len(num2) > 1 and num2[0] == '0'):\n        return False\n    _sum = add(num1, num2)\n    if remaining == _sum:\n        return True\n    if not remaining.startswith(_sum):\n        return False\n    return check(num2, _sum, remaining[len(_sum):])\n\ndef add(num1, num2):\n    carry, result = 0, []\n    i, j = len(num1) - 1, len(num2) - 1\n    while i >= 0 or j >= 0 or carry > 0:\n        n1 = int(num1[i]) if i >= 0 else 0\n        n2 = int(num2[j]) if j >= 0 else 0\n        _sum = n1 + n2 + carry\n        carry = _sum // 10\n        result.append(str(_sum % 10))\n        i, j = i - 1, j - 1\n    return ''.join(result[::-1])", "class NumArray:\n\n    def __init__(self, nums: List[int]):\n        self.prefix_sum = [0] * (len(nums) + 1)\n        for i in range(len(nums)):\n            self.prefix_sum[i + 1] = self.prefix_sum[i] + nums[i]\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.prefix_sum[right + 1] - self.prefix_sum[left]", "class NumMatrix:\n\n    def __init__(self, matrix: List[List[int]]):\n        self.dp = [[0] * (len(matrix[0]) + 1) for _ in range(len(matrix) + 1)]\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                self.dp[i + 1][j + 1] = self.dp[i + 1][j] + self.dp[i][j + 1] - self.dp[i][j] + matrix[i][j]\n                \n    def update(self, row: int, col: int, val: int) -> None:\n        oldValue = self.dp[row + 1][col + 1] - self.dp[row + 1][col] - self.dp[row][col + 1] + self.dp[row][col]\n        delta = val - oldValue\n        for i in range(row + 1, len(self.dp)):\n            for j in range(col + 1, len(self.dp[0])):\n                self.dp[i][j] += delta\n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n        return self.dp[row2 + 1][col2 + 1] - self.dp[row2 + 1][col1] - self.dp[row1][col2 + 1] + self.dp[row1][col1]", "def maxProfit(prices):\n    profit = 0\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n    return profit", "from collections import deque\nfrom typing import List\n\ndef find_min_height_trees(n: int, edges: List[List[int]]) -> List[int]:\n    if n == 1:\n        return [0]\n\n    adj_list = [set() for _ in range(n)]\n    for a, b in edges:\n        adj_list[a].add(b)\n        adj_list[b].add(a)\n\n    leaves = deque(i for i in range(n) if len(adj_list[i]) == 1)\n\n    while n > 2:\n        leaves_size = len(leaves)\n        n -= leaves_size\n        for _ in range(leaves_size):\n            leaf = leaves.popleft()\n            for neighbor in adj_list[leaf]:\n                adj_list[neighbor].remove(leaf)\n                if len(adj_list[neighbor]) == 1:\n                    leaves.append(neighbor)\n\n    return list(leaves)", "def multiply(mat1, mat2):\n    m, k, n = len(mat1), len(mat1[0]), len(mat2[0])\n    result = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(k):\n            if mat1[i][j] != 0:\n                for l in range(n):\n                    result[i][l] += mat1[i][j] * mat2[j][l]\n    return result", "def maxCoins(nums):\n    nums = [1] + nums + [1]\n    n = len(nums)\n    dp = [[0] * n for _ in range(n)]\n\n    for length in range(1, n - 1):\n        for left in range(1, n - length):\n            right = left + length - 1\n            for i in range(left, right + 1):\n                dp[left][right] = max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right])\n\n    return dp[1][n - 2]", "def nthSuperUglyNumber(n, primes):\n    ugly = [0] * n\n    ugly[0] = 1\n    indices = [0] * len(primes)\n\n    for i in range(1, n):\n        min_val = float(\"inf\")\n\n        for j in range(len(primes)):\n            min_val = min(min_val, ugly[indices[j]] * primes[j])\n\n        ugly[i] = min_val\n\n        for j in range(len(primes)):\n            if ugly[i] == ugly[indices[j]] * primes[j]:\n                indices[j] += 1\n\n    return ugly[-1]", "from collections import defaultdict, deque\nfrom typing import List, Optional\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef verticalOrder(root: Optional[TreeNode]) -> List[List[int]]:\n    if not root: return []\n\n    column_table = defaultdict(list)\n    q = deque([(root, 0)])\n\n    while q:\n        cur_node, column = q.popleft()\n\n        if cur_node:\n            column_table[column].append(cur_node.val)\n            q.append((cur_node.left, column - 1))\n            q.append((cur_node.right, column + 1))\n\n    return [column_table[key] for key in sorted(column_table)]", "def countSmaller(nums):\n    def merge_sort(indices):\n        if len(indices) <= 1:\n            return indices\n        mid = len(indices) // 2\n        left = merge_sort(indices[:mid])\n        right = merge_sort(indices[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        merged, count = [], 0\n        while left and right:\n            if nums[left[0]] <= nums[right[0]]:\n                counts[left[0]] += count\n                merged.append(left.pop(0))\n            else:\n                count += len(left)\n                merged.append(right.pop(0))\n        for i in left:\n            counts[i] += count\n        return merged + left + right\n\n    counts = [0] * len(nums)\n    merge_sort(list(range(len(nums))))\n    return counts", "def removeDuplicateLetters(s):\n    count = [0] * 256\n    visited = [False] * 256\n    st = []\n\n    for ch in s:\n        count[ord(ch)] += 1\n\n    for ch in s:\n        count[ord(ch)] -= 1\n        if visited[ord(ch)]:\n            continue\n        while st and ch < st[-1] and count[ord(st[-1])] > 0:\n            visited[ord(st.pop())] = False\n        st.append(ch)\n        visited[ord(ch)] = True\n\n    return \"\".join(st)", "from collections import deque\n\ndef shortestDistance(grid: list[list[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n\n    total_count = [[0] * n for _ in range(m)]\n    dist_sum = [[0] * n for _ in range(m)]\n    house_count = 0\n\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                house_count += 1\n                q = deque([(i, j)])\n                visited = [[False] * n for _ in range(m)]\n                level = 1\n                while q:\n                    for _ in range(len(q)):\n                        x, y = q.popleft()\n                        for dx, dy in dirs:\n                            x_new, y_new = x + dx, y + dy\n                            if 0 <= x_new < m and 0 <= y_new < n and not visited[x_new][y_new] and grid[x_new][y_new] == 0:\n                                visited[x_new][y_new] = True\n                                q.append((x_new, y_new))\n                                dist_sum[x_new][y_new] += level\n                                total_count[x_new][y_new] += 1\n                    level += 1\n\n    min_dist = float(\"inf\")\n    for i in range(m):\n        for j in range(n):\n            if total_count[i][j] == house_count:\n                min_dist = min(min_dist, dist_sum[i][j])\n\n    return -1 if min_dist == float(\"inf\") else min_dist", "def maxProduct(words):\n    n = len(words)\n    mask = [0] * n\n    for i, word in enumerate(words):\n        for c in word:\n            mask[i] |= (1 << (ord(c) - ord('a')))\n    \n    max_product = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (mask[i] & mask[j]) == 0:\n                max_product = max(max_product, len(words[i]) * len(words[j]))\n    \n    return max_product", "def bulbSwitch(n):\n    return int(n**0.5)", "def generateAbbreviations(word):\n    if not word:\n        return [\"\"]\n    res = []\n    for i in range(len(word) + 1):\n        for item in generateAbbreviations(word[i+1:]):\n            if i == 0 or not item or not item[0].isdigit():\n                res.append(word[:i+1] + item)\n            if item and item[0].isdigit():\n                res.append(word[:i] + '1' + item)\n    return res", "def coinChange(coins, amount):\n    dp = [amount + 1] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount] if dp[amount] <= amount else -1", "def countComponents(n, edges):\n    adj_list = [[] for _ in range(n)]\n    for edge in edges:\n        adj_list[edge[0]].append(edge[1])\n        adj_list[edge[1]].append(edge[0])\n\n    visited = [False] * n\n    connected_components = 0\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            connected_components += 1\n\n    return connected_components", "def wiggleSort(nums):\n    nums.sort()\n    for i in range(1, len(nums) - 1, 2):\n        nums[i], nums[i + 1] = nums[i + 1], nums[i]", "def maxSubArrayLen(nums: List[int], k: int) -> int:\n    sum_index = {}\n    maxLength = sum = 0\n    for i, num in enumerate(nums):\n        sum += num\n        if sum == k:\n            maxLength = i + 1\n        if sum - k in sum_index:\n            maxLength = max(maxLength, i - sum_index[sum - k])\n        if sum not in sum_index:\n            sum_index[sum] = i\n    return maxLength", "def is_power_of_three(n: int) -> bool:\n    if n < 1:\n        return False\n    \n    while n % 3 == 0:\n        n //= 3\n    \n    return n == 1", "def countRangeSum(nums, lower, upper):\n    sums = [0] * (len(nums) + 1)\n    for i in range(len(nums)):\n        sums[i + 1] = sums[i] + nums[i]\n\n    def mergeSort(start, end):\n        if start == end:\n            return 0\n        mid = start + (end - start) // 2\n        count = mergeSort(start, mid) + mergeSort(mid + 1, end)\n\n        j, k = mid + 1, mid + 1\n        for i in range(start, mid + 1):\n            while j <= end and sums[j] - sums[i] < lower: j += 1\n            while k <= end and sums[k] - sums[i] <= upper: k += 1\n            count += k - j\n\n        sums[start:end + 1] = sorted(sums[start:end + 1])\n        return count\n\n    return mergeSort(0, len(nums))", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef odd_even_list(head: ListNode) -> ListNode:\n    if not head:\n        return None\n    odd, even, even_head = head, head.next, head.next\n    while even and even.next:\n        odd.next = even.next\n        odd = odd.next\n        even.next = odd.next\n        even = even.next\n    odd.next = even_head\n    return head", "dx = (0, 0, 1, -1)\ndy = (1, -1, 0, 0)\n\ndef dfs(matrix, memo, i, j):\n    if memo[i][j] != 0:\n        return memo[i][j]\n    \n    max_len = 0\n    for k in range(4):\n        ni, nj = i + dx[k], j + dy[k]\n        if (0 <= ni < len(matrix) and 0 <= nj < len(matrix[0]) and matrix[ni][nj] > matrix[i][j]):\n            max_len = max(max_len, dfs(matrix, memo, ni, nj))\n    \n    memo[i][j] = max_len + 1\n    return memo[i][j]\n\ndef longest_increasing_path(matrix):\n    m, n = len(matrix), len(matrix[0])\n    \n    memo = [[0] * n for _ in range(m)]\n    \n    ans = 0\n    for i in range(m):\n        for j in range(n):\n            ans = max(ans, dfs(matrix, memo, i, j))\n    \n    return ans", "def minPatches(nums, n):\n    max_sum = 0\n    patches = 0\n    i = 0\n\n    while max_sum < n:\n        if i < len(nums) and nums[i] <= max_sum + 1:\n            max_sum += nums[i]\n            i += 1\n        else:\n            max_sum += max_sum + 1\n            patches += 1\n\n    return patches", "def is_valid_serialization(preorder: str) -> bool:\n    nodes = preorder.split(',')\n    node_count = 1\n\n    for node in nodes:\n        node_count -= 1\n        if node_count < 0:\n            return False\n        if node != '#':\n            node_count += 2\n\n    return node_count == 0", "from collections import defaultdict\n\ndef findItinerary(tickets):\n    flights = defaultdict(list)\n    itinerary = []\n\n    for ticket in tickets:\n        flights[ticket[0]].append(ticket[1])\n        flights[ticket[0]].sort(reverse=True)\n\n    def dfs(airport):\n        while flights[airport]:\n            dfs(flights[airport].pop())\n        itinerary.append(airport)\n\n    dfs(\"JFK\")\n    \n    return itinerary[::-1]", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef largestBSTSubtree(root: TreeNode) -> int:\n    def largestBSTUtil(root):\n        if not root:\n            return True, 0, float('inf'), float('-inf')\n        \n        left = largestBSTUtil(root.left)\n        right = largestBSTUtil(root.right)\n        \n        if left[0] and root.val > left[3] and right[0] and root.val < right[2]:\n            largestBST[0] = max(largestBST[0], left[1] + 1 + right[1])\n            return True, left[1] + 1 + right[1], min(root.val, left[2]), max(root.val, right[3])\n        \n        return False, -1, float('inf'), float('-inf')\n    \n    largestBST = [0]\n    largestBSTUtil(root)\n    \n    return largestBST[0]", "def findTriplets(nums: List[int]) -> bool:\n    first = float('inf')\n    second = float('inf')\n\n    for num in nums:\n        if num <= first:\n            first = num\n        elif num <= second:\n            second = num\n        else:\n            return True\n    return False", "def is_path_crossing(distance):\n    visited = set([(0, 0)])\n    x, y = 0, 0\n    directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]\n    \n    for i, d in enumerate(distance):\n        dx, dy = directions[i % 4]\n        for _ in range(d):\n            x += dx\n            y += dy\n            if (x, y) in visited:\n                return True\n            visited.add((x, y))\n    return False", "def palindrome_pairs(words):\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    result = []\n    for i in range(len(words)):\n        for j in range(len(words)):\n            if i == j:\n                continue\n            concat = words[i] + words[j]\n            if is_palindrome(concat):\n                result.append([i, j])\n    return result", "def rob(self, root: TreeNode) -> int:\n    def rob_helper(node):\n        if not node:\n            return 0, 0\n\n        left_with_node, left_without_node = rob_helper(node.left)\n        right_with_node, right_without_node = rob_helper(node.right)\n\n        with_node = node.val + left_without_node + right_without_node\n        without_node = max(left_with_node, left_without_node) + max(right_with_node, right_without_node)\n        return with_node, without_node\n\n    return max(rob_helper(root))", "def countBits(n):\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        ans[i] = ans[i & (i - 1)] + 1\n    return ans", "from typing import List, Union\n\ndef depth_sum(nested_list: List[Union[int, List]]) -> int:\n    def depth_sum_helper(nested_list: List[Union[int, List]], depth: int) -> int:\n        return sum(element * depth if isinstance(element, int) else depth_sum_helper(element, depth + 1) for element in nested_list)\n\n    return depth_sum_helper(nested_list, 1)", "def length_of_longest_substring_k_distinct(s: str, k: int) -> int:\n    char_count = {}\n    left = 0\n    max_length = 0\n\n    for right, char in enumerate(s):\n        char_count[char] = char_count.get(char, 0) + 1\n\n        while len(char_count) > k:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n\n        max_length = max(max_length, right - left + 1)\n\n    return max_length", "class NestedIterator:\n    def __init__(self, nestedList):\n        def flatten(nestedList, flatList):\n            for item in nestedList:\n                if isinstance(item, int):\n                    flatList.append(item)\n                else:\n                    flatten(item, flatList)\n        self.flatList = []\n        flatten(nestedList, self.flatList)\n        self.index = 0\n\n    def next(self):\n        result = self.flatList[self.index]\n        self.index += 1\n        return result\n\n    def hasNext(self):\n        return self.index < len(self.flatList)", "def isPowerOfFour(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n % 4 == 0:\n        n //= 4\n    return n == 1", "def integer_break(n):\n    if n <= 3:\n        return n - 1\n    product = 1\n    while n > 4:\n        product *= 3\n        n -= 3\n    return product * n", "def reverseString(s: List[str]) -> None:\n    left, right = 0, len(s) - 1\n    while left < right:\n        s[left], s[right] = s[right], s[left]\n        left, right = left + 1, right - 1", "def reverseVowels(s: str) -> str:\n    vowels = set('aeiouAEIOU')\n    s_list = list(s)\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s_list[i] not in vowels:\n            i += 1\n        elif s_list[j] not in vowels:\n            j -= 1\n        else:\n            s_list[i], s_list[j] = s_list[j], s_list[i]\n            i += 1\n            j -= 1\n    return ''.join(s_list)", "from collections import deque\n\nclass MovingAverage:\n    def __init__(self, size: int):\n        self.queue = deque()\n        self.maxSize = size\n        self.sum = 0.0\n\n    def next(self, val: int) -> float:\n        if len(self.queue) == self.maxSize:\n            self.sum -= self.queue.popleft()\n        self.queue.append(val)\n        self.sum += val\n        return self.sum / len(self.queue)", "from heapq import heappush, heappop\nfrom collections import Counter\n\ndef k_most_frequent(nums, k):\n    frequency = Counter(nums)\n    min_heap = []\n\n    for num, freq in frequency.items():\n        heappush(min_heap, (freq, num))\n        if len(min_heap) > k:\n            heappop(min_heap)\n\n    return [heappop(min_heap)[1] for _ in range(k)]", "class TicTacToe:\n    def __init__(self, n: int):\n        self.rows, self.cols = [0] * n, [0] * n\n        self.diagonal = self.anti_diagonal = self.n = n\n\n    def move(self, row: int, col: int, player: int) -> int:\n        to_add = 1 if player == 1 else -1\n\n        self.rows[row] += to_add\n        self.cols[col] += to_add\n\n        if row == col:\n            self.diagonal += to_add\n        if row + col == self.n - 1:\n            self.anti_diagonal += to_add\n\n        if (abs(self.rows[row]) == self.n or abs(self.cols[col]) == self.n\n                or abs(self.diagonal) == self.n or abs(self.anti_diagonal) == self.n):\n            return player\n\n        return 0", "def intersection(nums1, nums2):\n    set1 = set(nums1)\n    result = set1.intersection(nums2)\n    return list(result)", "def intersect(nums1, nums2):\n    count_map = {}\n    result = []\n    \n    for num in nums1:\n        count_map[num] = count_map.get(num, 0) + 1\n    \n    for num in nums2:\n        if count_map.get(num, 0) > 0:\n            result.append(num)\n            count_map[num] -= 1\n\n    return result", "def numberOfPatterns(m: int, n: int) -> int:\n    def dfs(curr, remaining):\n        if remaining < 0:\n            return 0\n        if remaining == 0:\n            return 1\n\n        visited[curr] = True\n        cnt = 0\n        for next in range(1, 10):\n            if not visited[next] and (jumps[curr][next] == 0 or visited[jumps[curr][next]]):\n                cnt += dfs(next, remaining - 1)\n        visited[curr] = False\n\n        return cnt\n\n    jumps = [[0] * 10 for _ in range(10)]\n    jumps[1][3] = jumps[3][1] = 2\n    jumps[1][7] = jumps[7][1] = 4\n    jumps[3][9] = jumps[9][3] = 6\n    jumps[7][9] = jumps[9][7] = 8\n    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5\n\n    visited = [False] * 10\n\n    cnt = 0\n    for i in range(m, n + 1):\n        cnt += dfs(1, i - 1) * 4  # 1, 3, 7, 9\n        cnt += dfs(2, i - 1) * 4  # 2, 4, 6, 8\n        cnt += dfs(5, i - 1)      # 5\n\n    return cnt", "from collections import OrderedDict\n\nclass SummaryRanges:\n\n    def __init__(self):\n        self.intervals = OrderedDict()\n\n    def addNum(self, val: int) -> None:\n        if not self.intervals or next(iter(self.intervals)) > val + 1:\n            self.intervals[val] = val\n        else:\n            keys = list(self.intervals.keys())\n            idx = bisect_left(keys, val)\n            if idx > 0 and keys[idx - 1] <= val <= self.intervals[keys[idx - 1]]:\n                pass\n            elif idx < len(keys) and val + 1 == keys[idx]:\n                self.intervals[val] = self.intervals[keys[idx]]\n                del self.intervals[keys[idx]]\n            else:\n                self.intervals[val] = val\n\n    def getIntervals(self):\n        return list(self.intervals.items())", "from collections import deque\n\nclass SnakeGame:\n    def __init__(self, width: int, height: int, food: List[List[int]]):\n        self.width = width\n        self.height = height\n        self.food = food\n        self.pos = 0\n        self.score = 0\n        self.snake = deque([(0, 0)])\n        self.occupied = {(0, 0)}\n        self.dx = {'U': -1, 'D': 1, 'L': 0, 'R': 0}\n        self.dy = {'U': 0, 'D': 0, 'L': -1, 'R': 1}\n\n    def move(self, direction: str) -> int:\n        new_x = self.snake[-1][0] + self.dx[direction]\n        new_y = self.snake[-1][1] + self.dy[direction]\n\n        if new_x < 0 or new_x >= self.height or new_y < 0 or new_y >= self.width:\n            return -1\n\n        new_head = (new_x, new_y)\n        tail = self.snake.popleft()\n\n        if self.pos < len(self.food) and self.food[self.pos] == list(new_head):\n            self.score += 1\n            self.pos += 1\n        else:\n            self.occupied.remove(tail)\n\n        if new_head in self.occupied:\n            return -1\n\n        self.snake.append(new_head)\n        self.occupied.add(new_head)\n        return self.score", "from bisect import bisect_left\n\ndef max_envelopes(envelopes):\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []\n    \n    for _, h in envelopes:\n        idx = bisect_left(dp, h)\n        if idx == len(dp):\n            dp.append(h)\n        else:\n            dp[idx] = h\n\n    return len(dp)", "from collections import defaultdict\nfrom typing import List\n\nclass Twitter:\n\n    class Tweet:\n        def __init__(self, time, tweetId):\n            self.time = time\n            self.tweetId = tweetId\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n        self.following = defaultdict(set)\n        self.timeStamp = 0\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.tweets[userId].append(self.Tweet(self.timeStamp, tweetId))\n        self.timeStamp += 1\n\n    def getNewsFeed(self, userId: int) -> List[int]:\n        feed = self.tweets[userId][:]\n        for user in self.following[userId]:\n            feed.extend(self.tweets[user])\n\n        feed.sort(key=lambda x: x.time, reverse=True)\n        return [t.tweetId for t in feed[:10]]\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        if followerId != followeeId:\n            self.following[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        self.following[followerId].discard(followeeId)", "def isReflected(points):\n    min_x = min(point[0] for point in points)\n    max_x = max(point[0] for point in points)\n    point_set = {(point[0], point[1]) for point in points}\n    \n    sum_x = min_x + max_x\n    for point in points:\n        if (sum_x - point[0], point[1]) not in point_set:\n            return False\n\n    return True", "def countNumbersWithUniqueDigits(n):\n    if n == 0:\n        return 1\n    \n    total = 10\n    unique_digits = 9\n    current_available_digits = 9\n    \n    while n > 1 and current_available_digits > 0:\n        unique_digits *= current_available_digits\n        total += unique_digits\n        current_available_digits -= 1\n        n -= 1\n        \n    return total", "import heapq\nfrom collections import Counter\n\ndef rearrange_string(s, k):\n    if k == 0:\n        return s\n\n    counter = Counter(s)\n    max_heap = [(-count, char) for char, count in counter.items()]\n    heapq.heapify(max_heap)\n\n    result = []\n    while max_heap:\n        temp = []\n\n        for _ in range(k):\n            if not max_heap:\n                break\n\n            count, char = heapq.heappop(max_heap)\n            result.append(char)\n\n            if count + 1 < 0:\n                temp.append((count + 1, char))\n\n        for item in temp:\n            heapq.heappush(max_heap, item)\n\n        if not max_heap:\n            break\n\n        if len(result) < len(s):\n            result.extend([' '] * (k - len(temp)))\n\n    if len(result) < len(s):\n        return \"\"\n    return \"\".join(result)", "class Logger:\n    def __init__(self):\n        self.message_timestamps = {}\n\n    def shouldPrintMessage(self, timestamp: int, message: str) -> bool:\n        if message not in self.message_timestamps or timestamp - self.message_timestamps[message] >= 10:\n            self.message_timestamps[message] = timestamp\n            return True\n        return False", "def sort_transformed_array(nums, a, b, c):\n    result = [0] * len(nums)\n    i, j = 0, len(nums) - 1\n    index = len(nums) - 1 if a >= 0 else 0\n    \n    while i <= j:\n        left = nums[i] * nums[i] * a + nums[i] * b + c\n        right = nums[j] * nums[j] * a + nums[j] * b + c\n        \n        if a >= 0:\n            if left >= right:\n                result[index] = left\n                index -= 1\n                i += 1\n            else:\n                result[index] = right\n                index -= 1\n                j -= 1\n        else:\n            if left <= right:\n                result[index] = left\n                index += 1\n                i += 1\n            else:\n                result[index] = right\n                index += 1\n                j -= 1\n    return result", "def maxKilledEnemies(grid):\n    if not grid: return 0\n    m, n, result, rowhits = len(grid), len(grid[0]), 0, 0\n    colhits = [0] * n\n    for i in range(m):\n        for j in range(n):\n            if j == 0 or grid[i][j - 1] == 'W':\n                rowhits = 0\n                k = j\n                while k < n and grid[i][k] != 'W':\n                    rowhits += grid[i][k] == 'E'\n                    k += 1\n            if i == 0 or grid[i - 1][j] == 'W':\n                colhits[j] = 0\n                k = i\n                while k < m and grid[k][j] != 'W':\n                    colhits[j] += grid[k][j] == 'E'\n                    k += 1\n            if grid[i][j] == '0':\n                result = max(result, rowhits + colhits[j])\n    return result", "from collections import deque\n\nclass HitCounter:\n\n    def __init__(self):\n        self.queue = deque()\n\n    def hit(self, timestamp: int) -> None:\n        self.queue.append(timestamp)\n\n    def getHits(self, timestamp: int) -> int:\n        while self.queue and self.queue[0] <= timestamp - 300:\n            self.queue.popleft()\n        return len(self.queue)", "from sortedcontainers import SortedList\n\ndef maxSumSubmatrix(matrix, k):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    max_sum = float('-inf')\n\n    for l in range(cols):\n        sums = [0] * rows\n        for r in range(l, cols):\n            for i in range(rows):\n                sums[i] += matrix[i][r]\n\n            sorted_sums = SortedList()\n            sorted_sums.add(0)\n            curr_sum = 0\n            for sum in sums:\n                curr_sum += sum\n                it = sorted_sums.bisect_left(curr_sum - k)\n                if it != len(sorted_sums):\n                    max_sum = max(max_sum, curr_sum - sorted_sums[it])\n                sorted_sums.add(curr_sum)\n\n    return max_sum", "from typing import List, Union\n\nNestedInteger = Union[int, List[Union[int, \"NestedInteger\"]]]\n\ndef depthSumInverse(nestedList: List[NestedInteger]) -> int:\n    max_depth = max_depth_helper(nestedList)\n    return sum_helper(nestedList, max_depth)\n\ndef max_depth_helper(nested_list: List[NestedInteger]) -> int:\n    depth = 1\n    for nested in nested_list:\n        if isinstance(nested, list):\n            depth = max(depth, 1 + max_depth_helper(nested))\n    return depth\n\ndef sum_helper(nested_list: List[NestedInteger], depth: int) -> int:\n    sum = 0\n    for nested in nested_list:\n        if isinstance(nested, int):\n            sum += depth * nested\n        else:\n            sum += sum_helper(nested, depth - 1)\n    return sum", "def canMeasureWater(jug1Capacity, jug2Capacity, targetCapacity):\n    if targetCapacity > jug1Capacity + jug2Capacity:\n        return False\n    if jug1Capacity == targetCapacity or jug2Capacity == targetCapacity or jug1Capacity + jug2Capacity == targetCapacity:\n        return True\n    return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef find_leaves(node, result, level):\n    if not node:\n        return -1\n    left_level = find_leaves(node.left, result, level + 1)\n    right_level = find_leaves(node.right, result, level + 1)\n    level = max(left_level, right_level) + 1\n    if len(result) <= level:\n        result.append([])\n    result[level].append(node.val)\n    return level\n\ndef findLeaves(root):\n    result = []\n    find_leaves(root, result, 0)\n    return result", "def is_perfect_square(num: int) -> bool:\n    if num < 2:\n        return True\n    left, right = 2, num // 2\n    while left <= right:\n        mid = left + (right - left) // 2\n        square = mid * mid\n        if square == num:\n            return True\n        if square > num:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return False", "def largestDivisibleSubset(nums):\n    nums.sort()\n    n = len(nums)\n    count = [1] * n\n    prev = [-1] * n\n\n    max_idx = 0\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] % nums[j] == 0 and count[i] < count[j] + 1:\n                count[i] = count[j] + 1\n                prev[i] = j\n        if count[max_idx] < count[i]:\n            max_idx = i\n\n    res = []\n    i = max_idx\n    while i >= 0:\n        res.append(nums[i])\n        i = prev[i]\n\n    return res", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef plusOne(head: ListNode) -> ListNode:\n    def plusOneDfs(node):\n        if not node:\n            return 1\n        carry = plusOneDfs(node.next)\n        if carry + node.val == 10:\n            node.val = 0\n            return 1\n        else:\n            node.val += carry\n            return 0\n\n    if not head:\n        return head\n    carry = plusOneDfs(head)\n    if carry == 1:\n        new_head = ListNode(1)\n        new_head.next = head\n        return new_head\n    return head", "def get_updated_array(length, updates):\n    arr = [0] * length\n\n    for start, end, inc in updates:\n        arr[start] += inc\n        if end + 1 < length:\n            arr[end + 1] -= inc\n\n    for i in range(1, length):\n        arr[i] += arr[i - 1]\n\n    return arr", "def add(a, b):\n    MAX = 0x7FFFFFFF\n    MASK = 0xFFFFFFFF\n    while b:\n        a, b = (a ^ b) & MASK, ((a & b) << 1) & MASK\n    return a if a <= MAX else ~(a ^ MASK)", "def powmod(a, b):\n    if b == 0:\n        return 1\n    res = powmod(a, b // 2)\n    return res * res % 1337 * a % 1337 if b % 2 else res * res % 1337\n\ndef superPow(a, b):\n    n = 0\n    for bi in b:\n        n = (n * 10 + bi) % 1140\n    return powmod(a % 1337, n + 1140)", "import heapq\n\ndef kSmallestPairs(nums1, nums2, k):\n    if not nums1 or not nums2:\n        return []\n    \n    heap = [(nums1[i] + nums2[0], i, 0) for i in range(min(k, len(nums1)))]\n    heapq.heapify(heap)\n    result = []\n\n    while k > 0 and heap:\n        s, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n        k -= 1\n\n    return result", "def guessNumber(n):\n    low, high = 1, n\n    while low <= high:\n        mid = low + (high - low) // 2\n        result = guess(mid)\n        if result == 0:\n            return mid\n        elif result < 0:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1", "def getMoneyAmount(n: int) -> int:\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, 0, -1):\n        for j in range(i + 1, n + 1):\n            min_cost = float(\"inf\")\n            for k in range(i, j):\n                cost = k + max(dp[i][k - 1], dp[k + 1][j])\n                min_cost = min(min_cost, cost)\n            dp[i][j] = min_cost\n    return dp[1][n]", "def wiggleMaxLength(nums):\n    if len(nums) < 2:\n        return len(nums)\n\n    up, down = 1, 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            up = down + 1\n        elif nums[i] < nums[i - 1]:\n            down = up + 1\n    return max(up, down)", "def combination_sum(nums, target):\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] += dp[i - num]\n\n    return dp[target]", "import heapq\n\ndef kthSmallest(matrix, k):\n    n = len(matrix)\n    min_heap = []\n\n    for i in range(n):\n        heapq.heappush(min_heap, (matrix[i][0], i, 0))\n\n    while k > 1:\n        val, row, col = heapq.heappop(min_heap)\n\n        if col + 1 < n:\n            heapq.heappush(min_heap, (matrix[row][col + 1], row, col + 1))\n\n        k -= 1\n\n    return min_heap[0][0]", "from collections import deque\n\nclass PhoneDirectory:\n    def __init__(self, maxNumbers: int):\n        self.available = [True] * maxNumbers\n        self.released = deque()\n    \n    def get(self) -> int:\n        if self.released:\n            number = self.released.popleft()\n            self.available[number] = False\n            return number\n        for i in range(len(self.available)):\n            if self.available[i]:\n                self.available[i] = False\n                return i\n        return -1\n    \n    def check(self, number: int) -> bool:\n        return self.available[number]\n    \n    def release(self, number: int) -> None:\n        if not self.available[number]:\n            self.available[number] = True\n            self.released.append(number)", "import random\n\nclass RandomizedSet:\n    def __init__(self):\n        self.index_map = {}\n        self.nums = []\n\n    def insert(self, val: int) -> bool:\n        if val in self.index_map:\n            return False\n\n        self.index_map[val] = len(self.nums)\n        self.nums.append(val)\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.index_map:\n            return False\n\n        last = self.nums[-1]\n        self.index_map[last] = self.index_map[val]\n        self.nums[self.index_map[val]] = last\n\n        self.nums.pop()\n        del self.index_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        return self.nums[random.randint(0, len(self.nums) - 1)]", "import random\nfrom collections import defaultdict\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.indices = defaultdict(set)\n        self.nums = []\n\n    def insert(self, val):\n        self.nums.append(val)\n        self.indices[val].add(len(self.nums) - 1)\n        return len(self.indices[val]) == 1\n\n    def remove(self, val):\n        if not self.indices[val]:\n            return False\n\n        idx = self.indices[val].pop()\n        if idx < len(self.nums) - 1:\n            last = self.nums[-1]\n            self.nums[idx] = last\n            self.indices[last].remove(len(self.nums) - 1)\n            self.indices[last].add(idx)\n        self.nums.pop()\n        return True\n\n    def getRandom(self):\n        return self.nums[random.randint(0, len(self.nums) - 1)]", "import random\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def __init__(self, head: ListNode):\n        self.head = head\n\n    def getRandom(self) -> int:\n        current, result = self.head, 0\n        for i, node in enumerate(self.iterate_nodes(current)):\n            if random.randint(0, i) == 0:\n                result = node.val\n        return result\n\n    def iterate_nodes(self, current):\n        while current:\n            yield current\n            current = current.next", "def can_construct(ransom_note, magazine):\n    letter_count = {}\n    \n    for c in magazine:\n        letter_count[c] = letter_count.get(c, 0) + 1\n        \n    for c in ransom_note:\n        if c not in letter_count or letter_count[c] == 0:\n            return False\n        letter_count[c] -= 1\n        \n    return True", "import random\n\nclass Solution:\n    def __init__(self, nums):\n        self.original = nums\n\n    def reset(self):\n        return self.original\n\n    def shuffle(self):\n        shuffled = self.original[:]\n        for i in range(len(shuffled) - 1, 0, -1):\n            j = random.randint(0, i)\n            shuffled[i], shuffled[j] = shuffled[j], shuffled[i]\n        return shuffled", "class NestedInteger:\n    def __init__(self, value=None):\n        pass\n\n    def add(self, ni):\n        pass\n\ndef deserialize(s: str) -> NestedInteger:\n    if s[0] != '[':\n        return NestedInteger(int(s))\n\n    stack = []\n    curr, start = None, 0\n\n    for i, c in enumerate(s):\n        if c == '[':\n            if curr:\n                stack.append(curr)\n            curr = NestedInteger()\n            start = i + 1\n        elif c == ',' or c == ']':\n            if i > start:\n                curr.add(NestedInteger(int(s[start:i])))\n            start = i + 1\n\n            if c == ']' and stack:\n                popped = stack.pop()\n                popped.add(curr)\n                curr = popped\n\n    return curr", "def lexicographical_order_helper(current, n, result):\n    if current > n:\n        return\n\n    result.append(current)\n    for i in range(10):\n        lexicographical_order_helper(current * 10 + i, n, result)\n\ndef lexical_order(n):\n    result = []\n    for i in range(1, 10):\n        lexicographical_order_helper(i, n, result)\n    return result", "def firstUniqChar(s):\n    char_count = {}\n    for c in s:\n        char_count[c] = char_count.get(c, 0) + 1\n    for i in range(len(s)):\n        if char_count[s[i]] == 1:\n            return i\n    return -1", "def length_longest_path(input: str) -> int:\n    dir_length_stack = []\n    max_file_length = 0\n    lines = input.split('\\n')\n\n    for line in lines:\n        level = line.count('\\t')\n        line = line.lstrip('\\t')\n\n        while len(dir_length_stack) > level:\n            dir_length_stack.pop()\n\n        if dir_length_stack:\n            length = dir_length_stack[-1] + len(line) + 1\n        else:\n            length = len(line)\n        dir_length_stack.append(length)\n\n        if '.' in line:\n            max_file_length = max(max_file_length, length)\n            \n    return max_file_length", "def findTheDifference(s: str, t: str) -> str:\n    return chr(sum(ord(c) for c in t) - sum(ord(c) for c in s))", "def last_remaining(n: int) -> int:\n    direction = True\n    head = 1\n    remaining = n\n    step = 1\n\n    while remaining > 1:\n        if direction or remaining % 2 == 1:\n            head += step\n        remaining //= 2\n        step *= 2\n        direction = not direction\n\n    return head", "def isRectangleCover(rectangles):\n    area = 0\n    points = set()\n    lx, ly, rx, ry = float('inf'), float('inf'), float('-inf'), float('-inf')\n\n    for rect in rectangles:\n        lx, ly = min(lx, rect[0]), min(ly, rect[1])\n        rx, ry = max(rx, rect[2]), max(ry, rect[3])\n\n        area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n\n        p1, p2, p3, p4 = (rect[0], rect[1]), (rect[0], rect[3]), (rect[2], rect[1]), (rect[2], rect[3])\n\n        points ^= {p1, p2, p3, p4}\n\n    return len(points) == 4 and area == (rx - lx) * (ry - ly) and (lx, ly) in points and \\\n           (lx, ry) in points and (rx, ly) in points and (rx, ry) in points", "def is_subsequence(s, t):\n    si, ti = 0, 0\n\n    while si < len(s) and ti < len(t):\n        if s[si] == t[ti]:\n            si += 1\n        ti += 1\n\n    return si == len(s)", "def validUtf8(data):\n    count = 0\n    for byte in data:\n        if count == 0:\n            if byte >> 5 == 0b110:\n                count = 1\n            elif byte >> 4 == 0b1110:\n                count = 2\n            elif byte >> 3 == 0b11110:\n                count = 3\n            elif byte >> 7:\n                return False\n        else:\n            if byte >> 6 != 0b10:\n                return False\n            count -= 1\n    return count == 0", "def decodeString(s):\n    counts = []\n    results = []\n    current = \"\"\n    ptr = 0\n\n    while ptr < len(s):\n        if s[ptr].isdigit():\n            count = 0\n            while s[ptr].isdigit():\n                count = count * 10 + int(s[ptr])\n                ptr += 1\n            counts.append(count)\n        elif s[ptr] == '[':\n            results.append(current)\n            current = \"\"\n            ptr += 1\n        elif s[ptr] == ']':\n            prev = results.pop()\n            count = counts.pop()\n            current = prev + current * count\n            ptr += 1\n        else:\n            current += s[ptr]\n            ptr += 1\n\n    return current", "def longestSubstring(s: str, k: int) -> int:\n    if not s or k <= 0:\n        return 0\n\n    char_count = {}\n    for ch in s:\n        char_count[ch] = char_count.get(ch, 0) + 1\n\n    for char, count in char_count.items():\n        if count < k:\n            return max(longestSubstring(sub_s, k) for sub_s in s.split(char))\n    return len(s)", "def maxRotateFunction(nums):\n    n = len(nums)\n    total_sum = sum(nums)\n    f = sum(i * num for i, num in enumerate(nums))\n\n    max_f = f\n    for i in range(1, n):\n        f += total_sum - n * nums[-i]\n        max_f = max(max_f, f)\n\n    return max_f", "def min_operations(n):\n    steps = 0\n    while n > 1:\n        n = n // 2 if n % 2 == 0 else n - 1\n        steps += 1\n    return steps", "import random\n\nclass Solution:\n\n    def __init__(self, nums):\n        self.nums = nums\n\n    def pick(self, target):\n        count, res = 0, 0\n        for i, num in enumerate(self.nums):\n            if num == target:\n                count += 1\n                if random.randint(0, count - 1) == 0:\n                    res = i\n        return res", "from collections import defaultdict\n\ndef dfs(s1, s2, graph):\n    if s1 not in graph or s2 not in graph:\n        return -1.0\n    if s1 == s2:\n        return 1.0\n    \n    for neighbor, weight in graph[s1]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            temp = dfs(neighbor, s2, graph)\n            if temp > 0:\n                return weight * temp\n    return -1.0\n\ndef calcEquation(equations, values, queries):\n    graph = defaultdict(list)\n    for (s1, s2), value in zip(equations, values):\n        graph[s1].append((s2, value))\n        graph[s2].append((s1, 1 / value))\n    \n    ans = []\n    for s1, s2 in queries:\n        visited = set()\n        ans.append(dfs(s1, s2, graph))\n    return ans", "def findNthDigit(n):\n    size = 1\n    length = 9\n    start = 1\n\n    while n > length * size:\n        n -= length * size\n        size += 1\n        length *= 10\n        start *= 10\n\n    start += (n - 1) // size\n    s = str(start)\n    return int(s[(n - 1) % size])", "def readBinaryWatch(turnedOn: int):\n    def count_bits(n):\n        return bin(n).count('1')\n\n    times = []\n    for h in range(12):\n        for m in range(60):\n            if count_bits(h) + count_bits(m) == turnedOn:\n                times.append(f\"{h}:{m:02d}\")\n    return times", "def remove_k_digits(num, k):\n    stack = []\n    for c in num:\n        while k > 0 and stack and stack[-1] > c:\n            stack.pop()\n            k -= 1\n        stack.append(c)\n    while k > 0:\n        stack.pop()\n        k -= 1\n    return ''.join(stack).lstrip('0') or '0'", "def can_cross(stones):\n    dp = {stone: set() for stone in stones}\n    dp[0].add(0)\n\n    for stone in stones:\n        for k in dp[stone]:\n            for jump in (k - 1, k, k + 1):\n                if jump > 0 and stone + jump in dp:\n                    dp[stone + jump].add(jump)\n\n    return bool(dp[stones[-1]])", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef sum_of_left_leaves(root):\n    if not root:\n        return 0\n    left_sum = 0\n    if root.left and not root.left.left and not root.left.right:\n        left_sum += root.left.val\n    return left_sum + sum_of_left_leaves(root.left) + sum_of_left_leaves(root.right)", "def to_hex(num: int) -> str:\n    if num == 0:\n        return '0'\n    hex_str = ''\n    hex_digits = '0123456789abcdef'\n    n = num & 0xffffffff\n    while n:\n        hex_str = hex_digits[n & 0xf] + hex_str\n        n >>= 4\n    return hex_str", "from typing import List\n\ndef reconstructQueue(people: List[List[int]]) -> List[List[int]]:\n    people.sort(key=lambda x: (-x[0], x[1]))\n\n    result = []\n    for p in people:\n        result.insert(p[1], p)\n    return result", "import heapq\n\ndef trapRainWater(heightMap):\n    m, n = len(heightMap), len(heightMap[0])\n    pq = []\n    visited = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n        heapq.heappush(pq, (heightMap[i][0], i, 0))\n        heapq.heappush(pq, (heightMap[i][n - 1], i, n - 1))\n        visited[i][0] = visited[i][n - 1] = True\n\n    for i in range(1, n - 1):\n        heapq.heappush(pq, (heightMap[0][i], 0, i))\n        heapq.heappush(pq, (heightMap[m - 1][i], m - 1, i))\n        visited[0][i] = visited[m - 1][i] = True\n\n    water, maxHeight = 0, 0\n    dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))\n\n    while pq:\n        h, r, c = heapq.heappop(pq)\n        maxHeight = max(maxHeight, h)\n        for dx, dy in dirs:\n            x, y = r + dx, c + dy\n            if x < 0 or x >= m or y < 0 or y >= n or visited[x][y]:\n                continue\n            if heightMap[x][y] < maxHeight:\n                water += maxHeight - heightMap[x][y]\n            heapq.heappush(pq, (heightMap[x][y], x, y))\n            visited[x][y] = True\n\n    return water", "def validWordAbbreviation(word, abbr):\n    i, j = 0, 0\n    while i < len(word) and j < len(abbr):\n        if abbr[j].isdigit():\n            if abbr[j] == '0': return False  # leading zero\n            num = 0\n            while j < len(abbr) and abbr[j].isdigit():\n                num = num * 10 + int(abbr[j])\n                j += 1\n            i += num\n        else:\n            if word[i] != abbr[j]: return False\n            i, j = i + 1, j + 1\n    return i == len(word) and j == len(abbr)", "def longestPalindrome(s: str) -> int:\n    charCount = [0] * 128\n    result = 0\n    for c in s:\n        charCount[ord(c)] += 1\n    for count in charCount:\n        result += count // 2 * 2\n        if result % 2 == 0 and count % 2 == 1:\n            result += 1\n    return result", "def splitArray(nums, m):\n    left, right = max(nums), sum(nums)\n\n    while left < right:\n        mid = (left + right) // 2\n        count, cur_sum = 1, 0\n        for num in nums:\n            cur_sum += num\n            if cur_sum > mid:\n                cur_sum = num\n                count += 1\n\n        if count > m:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left", "def abbreviate(s, k, i):\n    if i == len(s):\n        return str(k) if k > 0 else \"\"\n    if k == 0:\n        return s[i:] + (abbreviate(s, 1, i + 1) if i + 1 < len(s) else \"\")\n    return str(k) + s[i] + (abbreviate(s, 1, i + 1) if i + 1 < len(s) else \"\")\n\ndef is_abbreviation(target, word):\n    i, j = 0, 0\n    while i < len(target) and j < len(word):\n        if target[i] == word[j]:\n            i, j = i + 1, j + 1\n        elif target[i].isdigit():\n            k = 0\n            while i < len(target) and target[i].isdigit():\n                k = k * 10 + int(target[i])\n                i += 1\n            j += k\n        else:\n            return False\n    return i == len(target) and j == len(word)\n\ndef min_abbreviation(target, dictionary):\n    ans = target\n    for k in range(0, len(target) + 1):\n        for i in range(0, len(target) - k + 1):\n            current = abbreviate(target, k, i)\n            if len(current) < len(ans):\n                valid = True\n                for word in dictionary:\n                    if is_abbreviation(current, word):\n                        valid = False\n                        break\n                if valid:\n                    ans = current\n    return ans", "def fizzBuzz(n):\n    result = []\n    for i in range(1, n + 1):\n        if i % 15 == 0:\n            result.append(\"FizzBuzz\")\n        elif i % 3 == 0:\n            result.append(\"Fizz\")\n        elif i % 5 == 0:\n            result.append(\"Buzz\")\n        else:\n            result.append(str(i))\n    return result", "def numberOfArithmeticSlices(nums):\n    n = len(nums)\n    count, cur = 0, 0\n    for i in range(2, n):\n        if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n            cur += 1\n            count += cur\n        else:\n            cur = 0\n    return count", "def third_max(nums):\n    top3 = set()\n    for num in nums:\n        top3.add(num)\n        if len(top3) > 3:\n            top3.remove(min(top3))\n    return min(top3) if len(top3) == 3 else max(top3)", "def addStrings(num1: str, num2: str) -> str:\n    i, j, carry, result = len(num1) - 1, len(num2) - 1, 0, []\n\n    while i >= 0 or j >= 0 or carry:\n        sum = carry\n\n        if i >= 0:\n            sum += int(num1[i])\n            i -= 1\n        if j >= 0:\n            sum += int(num2[j])\n            j -= 1\n\n        carry = sum // 10\n        result.append(str(sum % 10))\n\n    return ''.join(result[::-1])", "def canPartition(nums):\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    \n    target = total_sum // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    \n    for num in nums:\n        for i in range(target, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    \n    return dp[target]", "def pacificAtlantic(heights):\n    def dfs(r, c, prev_height, visited):\n        if not (0 <= r < len(heights)) or not (0 <= c < len(heights[0])):\n            return\n        if heights[r][c] >= prev_height and not visited[r][c]:\n            visited[r][c] = True\n            dfs(r - 1, c, heights[r][c], visited)\n            dfs(r + 1, c, heights[r][c], visited)\n            dfs(r, c - 1, heights[r][c], visited)\n            dfs(r, c + 1, heights[r][c], visited)\n\n    m, n = len(heights), len(heights[0])\n    pacific = [[False] * n for _ in range(m)]\n    atlantic = [[False] * n for _ in range(m)]\n\n    for r in range(m):\n        dfs(r, 0, -1, pacific)\n        dfs(r, n - 1, -1, atlantic)\n    for c in range(n):\n        dfs(0, c, -1, pacific)\n        dfs(m - 1, c, -1, atlantic)\n\n    result = []\n    for r in range(m):\n        for c in range(n):\n            if pacific[r][c] and atlantic[r][c]:\n                result.append([r, c])\n    return result", "def words_typing(sentence, rows, cols):\n    total_chars = sum(len(word) + 1 for word in sentence)\n\n    result = 0\n    index = 0\n    for _ in range(rows):\n        remaining_cols = cols\n        while True:\n            word_len = len(sentence[index])\n            if remaining_cols >= word_len:\n                remaining_cols -= word_len + 1\n                index = (index + 1) % len(sentence)\n                if index == 0:\n                    result += 1\n            else:\n                break\n\n    return result", "def countBattleships(board):\n    count = 0\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if (board[i][j] == 'X' and\n                (i == 0 or board[i - 1][j] == '.') and\n                (j == 0 or board[i][j - 1] == '.')):\n                count += 1\n    return count", "def strong_password(password):\n    missing_lower = 1\n    missing_upper = 1\n    missing_digit = 1\n    total = len(password)\n    \n    for c in password:\n        if c.islower(): missing_lower = 0\n        if c.isupper(): missing_upper = 0\n        if c.isdigit(): missing_digit = 0\n    \n    missing = missing_lower + missing_upper + missing_digit\n    if total < 6: return max(missing, 6 - total)\n    if total > 20: return missing + total - 20\n\n    return missing", "def findMaximumXOR(nums):\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n\n        possible_max = max_xor | (1 << i)\n\n        for prefix in prefixes:\n            if prefix ^ possible_max in prefixes:\n                max_xor = possible_max\n                break\n\n    return max_xor", "def valid_word_square(words):\n    for i in range(len(words)):\n        for j in range(len(words[i])):\n            if j >= len(words) or i >= len(words[j]) or words[i][j] != words[j][i]:\n                return False\n    return True", "def find_digits_in_ascending_order(s):\n    count = [0] * 10\n    for c in s:\n        if c == 'z': count[0] += 1\n        if c == 'w': count[2] += 1\n        if c == 'u': count[4] += 1\n        if c == 'x': count[6] += 1\n        if c == 'g': count[8] += 1\n        if c == 'o': count[1] += 1\n        if c == 'h': count[3] += 1\n        if c == 'f': count[5] += 1\n        if c == 's': count[7] += 1\n        if c == 'i': count[9] += 1\n    count[1] -= count[0] + count[2] + count[4]\n    count[3] -= count[8]\n    count[5] -= count[4]\n    count[7] -= count[6]\n    count[9] -= count[5] + count[6] + count[8]\n    \n    res = []\n    for i in range(10):\n        res.extend([str(i)] * count[i])\n    return ''.join(res)", "def characterReplacement(s:str, k:int) -> int:\n    n = len(s)\n    left = 0\n    right = 0\n    maxFreq = 0\n    result = 0\n    freq = [0] * 26\n\n    for right in range(n):\n        freq[ord(s[right]) - ord('A')] += 1\n        maxFreq = max(maxFreq, freq[ord(s[right]) - ord('A')])\n\n        if right - left + 1 - maxFreq > k:\n            freq[ord(s[left]) - ord('A')] -= 1\n            left += 1\n\n        result = max(result, right - left + 1)\n\n    return result", "from collections import defaultdict\n\ndef wordSquares(words):\n    def build(row, squares, word_lens):\n        if row == word_lens:\n            res.append(list(squares))\n            return\n        prefix = ''.join(squares[i][row] for i in range(row))\n        for w in prefixes[prefix]:\n            squares[row] = w\n            build(row+1, squares, word_lens)\n\n    if not words: return []\n    res = []\n    word_lens = len(words[0])\n    \n    prefixes = defaultdict(list)\n    for word in words:\n        for i in range(word_lens+1):\n            prefixes[word[:i]].append(word)\n            \n    for word in words:\n        build(1, [word] + [None]*(word_lens-1), word_lens)\n        \n    return res", "class Node:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def treeToDoublyList(self, root: 'Node') -> 'Node':\n        if not root:\n            return None\n\n        first = None\n        last = None\n        \n        def inOrder(node):\n            nonlocal first, last\n            \n            if not node:\n                return\n\n            inOrder(node.left)\n\n            if last:\n                last.right = node\n                node.left = last\n            else:\n                first = node\n            \n            last = node\n\n            inOrder(node.right)\n\n        inOrder(root)\n\n        first.left = last\n        last.right = first\n\n        return first", "class Node:\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n\ndef build(grid, row, col, size):\n    if size == 1:\n        return Node(grid[row][col] == 1, True, None, None, None, None)\n    half = size // 2\n    topLeft = build(grid, row, col, half)\n    topRight = build(grid, row, col + half, half)\n    bottomLeft = build(grid, row + half, col, half)\n    bottomRight = build(grid, row + half, col + half, half)\n    if topLeft.isLeaf and topRight.isLeaf and bottomLeft.isLeaf and bottomRight.isLeaf and topLeft.val == topRight.val and topLeft.val == bottomLeft.val and topLeft.val == bottomRight.val:\n        return topLeft\n    return Node(False, False, topLeft, topRight, bottomLeft, bottomRight)\n\ndef construct(grid):\n    return build(grid, 0, 0, len(grid))", "class Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\nclass Codec:\n    def serialize(self, root):\n        if root is None:\n            return \"\"\n        \n        data = str(root.val) + \" \"\n        for child in root.children:\n            data += self.serialize(child)\n        data += \"# \"\n        return data\n\n    def deserialize(self, data):\n        def dfs(iter_data):\n            val = next(iter_data)\n            if val == \"#\":\n                return None\n            \n            node = Node(int(val))\n            while True:\n                child = dfs(iter_data)\n                if child is None:\n                    break\n                node.children.append(child)\n            return node\n\n        return dfs(iter(data.split()))", "class Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\ndef levelOrder(root):\n    if not root:\n        return []\n    \n    result = []\n    queue = [root]\n    \n    while queue:\n        currentLevel = []\n        nextLevel = []\n        \n        for node in queue:\n            currentLevel.append(node.val)\n            nextLevel.extend(node.children)\n            \n        result.append(currentLevel)\n        queue = nextLevel\n            \n    return result", "class Node:\n    def __init__(self, val, prev, next, child):\n        self.val = val\n        self.prev = prev\n        self.next = next\n        self.child = child\n\ndef flatten(head: Node) -> Node:\n    if not head:\n        return None\n    \n    cur, prev, next_node = head, None, None\n\n    while cur:\n        next_node = cur.next\n\n        if cur.child:\n            cur.next = flatten(cur.child)\n            cur.child.prev = cur\n            cur.child = None\n\n            if next_node:\n                prev = cur\n                while cur.next:\n                    cur = cur.next\n                    prev = prev.next\n\n                cur.next = next_node\n                next_node.prev = prev\n\n        cur = next_node\n\n    return head", "class NaryTreeNode:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\nclass BinaryTreeNode:\n    def __init__(self, val=None, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef encode(root: NaryTreeNode) -> BinaryTreeNode:\n    if not root:\n        return None\n    binary_root = BinaryTreeNode(root.val)\n    if root.children:\n        binary_root.left = encode(root.children[0])\n    sibling = binary_root.left\n    for child in root.children[1:]:\n        sibling.right = encode(child)\n        sibling = sibling.right\n    return binary_root\n\ndef decode(root: BinaryTreeNode) -> NaryTreeNode:\n    if not root:\n        return None\n    nary_root = NaryTreeNode(root.val)\n    sibling = root.left\n    while sibling:\n        nary_root.children.append(decode(sibling))\n        sibling = sibling.right\n    return nary_root", "class AllOne:\n    def __init__(self):\n        self.data = dict()\n\n    def inc(self, key: str) -> None:\n        self.data[key] = self.data.get(key, 0) + 1\n\n    def dec(self, key: str) -> None:\n        self.data[key] = self.data.get(key, 0) - 1\n        if self.data[key] == 0:\n            del self.data[key]\n\n    def getMaxKey(self) -> str:\n        if not self.data:\n            return \"\"\n        return max(self.data, key=lambda x: self.data[x])\n\n    def getMinKey(self) -> str:\n        if not self.data:\n            return \"\"\n        return min(self.data, key=lambda x: self.data[x])", "from collections import deque\n\ndef minMutation(start, end, bank):\n    q = deque([start])\n    visited = set([start])\n    depth = 0\n\n    while q:\n        levelSize = len(q)\n        for _ in range(levelSize):\n            current = q.popleft()\n            if current == end:\n                return depth\n\n            for gene in bank:\n                if gene not in visited:\n                    diff = sum(1 for j in range(8) if current[j] != gene[j])\n                    if diff == 1:\n                        q.append(gene)\n                        visited.add(gene)\n        depth += 1\n    return -1", "def count_segments(s: str) -> int:\n    return len(s.split())", "def eraseOverlapIntervals(intervals):\n    if not intervals:\n        return 0\n    \n    intervals.sort(key=lambda x: x[1])\n    \n    count = 0\n    prev_end = intervals[0][1]\n    \n    for i in range(1, len(intervals)):\n        if intervals[i][0] < prev_end:\n            count += 1\n        else:\n            prev_end = intervals[i][1]\n    \n    return count", "def findRightInterval(intervals):\n    starts = {interval[0]: index for index, interval in enumerate(intervals)}\n    res = []\n\n    for interval in intervals:\n        right = min(filter(lambda x: x >= interval[1], starts.keys()), default=-1)\n        res.append(starts[right] if right != -1 else -1)\n\n    return res", "def path_sum_helper(node, target_sum, current_sum):\n    if node is None:\n        return 0\n\n    current_sum += node.val\n    total_paths = 1 if current_sum == target_sum else 0\n    total_paths += path_sum_helper(node.left, target_sum, current_sum)\n    total_paths += path_sum_helper(node.right, target_sum, current_sum)\n    return total_paths\n\ndef path_sum(root, target_sum):\n    if root is None:\n        return 0\n\n    return path_sum_helper(root, target_sum, 0) + path_sum(root.left, target_sum) + path_sum(root.right, target_sum)", "def find_anagrams(s, p):\n    if len(s) < len(p):\n        return []\n\n    s_count = [0] * 26\n    p_count = [0] * 26\n    for c in p:\n        p_count[ord(c) - ord('a')] += 1\n\n    result = []\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n\n    return result", "def parseTernary(expression: str) -> str:\n    stack = []\n    for c in reversed(expression):\n        if stack and stack[-1] == '?':\n            stack.pop()  # Pop '?'\n            first = stack.pop()\n            stack.pop()  # Pop ':'\n            second = stack.pop()\n            stack.append(first if c == 'T' else second)\n        else:\n            stack.append(c)\n    return stack[-1]", "def find_kth_number(n, k):\n    nums = [i for i in range(1, n + 1)]\n    nums.sort(key=lambda x: str(x))\n    return nums[k - 1]", "def arrange_coins(n: int) -> int:\n    k = 0\n    while n > k:\n        k += 1\n        n -= k\n    return k", "def find_duplicates(nums):\n    duplicates = []\n    for i in range(len(nums)):\n        index = abs(nums[i]) - 1\n        if nums[index] < 0:\n            duplicates.append(abs(nums[i]))\n        else:\n            nums[index] *= -1\n    return duplicates", "def compress(chars):\n    index, i = 0, 0\n    \n    while i < len(chars):\n        count = 1\n        while i + count < len(chars) and chars[i] == chars[i + count]:\n            count += 1\n            \n        chars[index] = chars[i]\n        index += 1\n        \n        if count > 1:\n            count_str = str(count)\n            for c in count_str:\n                chars[index] = c\n                index += 1\n                \n        i += count\n        \n    return index", "def is_shortest_and_unique_supersequence(nums, sequences):\n    pos = {val: idx for idx, val in enumerate(nums)}\n\n    for seq in sequences:\n        if pos[seq[0]] > pos[seq[-1]]:\n            return False\n    return True", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef addTwoNumbers(l1, l2):\n    result = ListNode(0)\n    current = result\n    carry = 0\n    while l1 or l2 or carry:\n        sum = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\n        carry = sum // 10\n        current.next = ListNode(sum % 10)\n        current = current.next\n        if l1: l1 = l1.next\n        if l2: l2 = l2.next\n    return result.next", "def numberOfArithmeticSlices(nums):\n    res = 0\n    n = len(nums)\n    dp = [dict() for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            if diff <= -2**31 or diff > 2**31:\n                continue\n\n            dp[i][diff] = dp[i].get(diff, 0) + 1\n\n            if diff in dp[j]:\n                res += dp[j][diff]\n                dp[i][diff] += dp[j][diff]\n\n    return res", "def numberOfBoomerangs(points):\n    count = 0\n\n    for i in points:\n        group_count = {}\n        for j in points:\n            dx, dy = i[0] - j[0], i[1] - j[1]\n            dist = dx * dx + dy * dy\n            group_count[dist] = group_count.get(dist, 0) + 1\n\n        for g in group_count.values():\n            count += g * (g - 1)\n\n    return count", "def find_disappeared_numbers(nums):\n    result = []\n    \n    for num in nums:\n        index = abs(num) - 1\n        nums[index] = -abs(nums[index])\n\n    for i, num in enumerate(nums):\n        if num > 0:\n            result.append(i + 1)\n\n    return result", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef serialize(root):\n    if not root:\n        return \"#\"\n    return str(root.val) + \",\" + serialize(root.left) + \",\" + serialize(root.right)\n\ndef deserialize(data):\n    def deserialize_helper(values):\n        val = next(values)\n        if val == \"#\":\n            return None\n        node = TreeNode(int(val))\n        node.left = deserialize_helper(values)\n        node.right = deserialize_helper(values)\n        return node\n\n    values = iter(data.split(\",\"))\n    return deserialize_helper(values)", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef deleteNode(root, key):\n    if root is None:\n        return None\n\n    if key < root.val:\n        root.left = deleteNode(root.left, key)\n    elif key > root.val:\n        root.right = deleteNode(root.right, key)\n    else:\n        if root.left is None:\n            return root.right\n        elif root.right is None:\n            return root.left\n        else:\n            temp = root.right\n            while temp.left is not None:\n                temp = temp.left\n            root.val = temp.val\n            root.right = deleteNode(root.right, temp.val)\n\n    return root", "from collections import Counter\n\ndef sort_by_frequency(s):\n    freq = Counter(s)\n    chars = list(s)\n    chars.sort(key=lambda c: freq[c], reverse=True)\n    return ''.join(chars)", "def findMinArrowShots(points):\n    if not points:\n        return 0\n    points.sort(key=lambda x: x[1])\n\n    arrows = 1\n    end = points[0][1]\n\n    for i in range(1, len(points)):\n        if points[i][0] > end:\n            arrows += 1\n            end = points[i][1]\n\n    return arrows", "def min_moves(nums):\n    min_element = min(nums)\n    moves = sum(num - min_element for num in nums)\n    return moves", "def fourSumCount(nums1, nums2, nums3, nums4):\n    hashMap = {}\n    count = 0\n\n    for i in nums1:\n        for j in nums2:\n            hashMap[i + j] = hashMap.get(i + j, 0) + 1\n\n    for k in nums3:\n        for l in nums4:\n            count += hashMap.get(-(k + l), 0)\n\n    return count", "def find_content_children(g, s):\n    g.sort()\n    s.sort()\n    i = j = 0\n\n    while i < len(g) and j < len(s):\n        if s[j] >= g[i]:\n            i += 1\n\n        j += 1\n\n    return i", "def find132pattern(nums):\n    third, stack = float('-inf'), []\n    for num in reversed(nums):\n        if num < third:\n            return True\n        while stack and stack[-1] < num:\n            third = stack.pop()\n        stack.append(num)\n    return False", "def circularArrayLoop(nums: List[int]) -> bool:\n    N = len(nums)\n    for i in range(N):\n        slow, fast = i, i\n        while True:\n            slow = getNextIndex(slow, nums)\n            fast = getNextIndex(getNextIndex(fast, nums), nums)\n            if slow != fast and nums[slow] * nums[fast] > 0:\n                break\n            if slow == fast:\n                break\n        else:\n            continue\n        cycle = False\n        start = slow\n        while start != slow:\n            cycle |= getNextIndex(start, nums) == start\n            start = getNextIndex(start, nums)\n        if not cycle:\n            return True\n    return False\n\ndef getNextIndex(idx: int, nums: List[int]) -> int:\n    N = len(nums)\n    return (idx + nums[idx]) % N", "def poor_pigs(buckets, minutes_to_die, minutes_to_test):\n    pigs = 0\n    while (minutes_to_test // minutes_to_die + 1) ** pigs < buckets:\n        pigs += 1\n    return pigs", "def can_construct(s):\n    n = len(s)\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            substr = s[:i]\n            flag = True\n            for j in range(i, n, i):\n                if s[j:j+i] != substr:\n                    flag = False\n                    break\n\n            if flag:\n                return True\n\n    return False", "class LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_value = {}\n        self.key_freq = {}\n        self.freq_list = {1: []}\n\n    def get(self, key: int) -> int:\n        if key not in self.key_value:\n            return -1\n        count = self.key_freq[key]\n        self.key_freq[key] += 1\n        self.freq_list[count].remove(key)\n\n        if count == self.min_freq and not self.freq_list[count]:\n            self.min_freq += 1\n\n        if count + 1 not in self.freq_list:\n            self.freq_list[count + 1] = []\n        self.freq_list[count + 1].append(key)\n\n        return self.key_value[key]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity <= 0:\n            return\n        if key in self.key_value:\n            self.key_value[key] = value\n            self.get(key)\n            return\n        \n        if len(self.key_value) >= self.capacity:\n            evict = self.freq_list[self.min_freq][0]\n            self.freq_list[self.min_freq].pop(0)\n            del self.key_value[evict]\n\n        self.key_value[key] = value\n        self.key_freq[key] = 1\n        self.min_freq = 1\n        self.freq_list[1].append(key)", "def hammingDistance(x: int, y: int) -> int:\n    xorResult = x ^ y\n    dist = 0\n    while xorResult:\n        dist += xorResult & 1\n        xorResult >>= 1\n    return dist", "def min_moves2(nums):\n    nums.sort()\n    mid = nums[len(nums) // 2]\n    moves = 0\n    for num in nums:\n        moves += abs(num - mid)\n    return moves", "def islandPerimeter(grid):\n    perimeter = 0\n    for row in range(len(grid)):\n        for col in range(len(grid[row])):\n            if grid[row][col] == 1:\n                perimeter += 4\n                if row > 0 and grid[row - 1][col] == 1:\n                    perimeter -= 2\n                if col > 0 and grid[row][col - 1] == 1:\n                    perimeter -= 2\n    return perimeter", "def canIWin(maxChoosableInteger, desiredTotal):\n    if maxChoosableInteger >= desiredTotal: return True\n    if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal: return False\n\n    memo = {}\n        \n    def canWin(state):\n        if state in memo:\n            return memo[state]\n        for i in range(1, maxChoosableInteger + 1):\n            bitCheck = 1 << i\n            if (state & bitCheck) == 0:\n                if not canWin(state | bitCheck):\n                    memo[state] = True\n                    return True\n    \n        memo[state] = False\n        return False\n\n    return canWin(0)", "from collections import defaultdict\n\ndef minTransfers(transactions):\n    balances = defaultdict(int)\n    for transaction in transactions:\n        balances[transaction[0]] -= transaction[2]\n        balances[transaction[1]] += transaction[2]\n\n    debts = [balance for balance in balances.values() if balance != 0]\n    return dfs(debts, 0)\n\ndef dfs(debts, start):\n    while start < len(debts) and debts[start] == 0:\n        start += 1\n    if start == len(debts):\n        return 0\n    result = float('inf')\n    for i in range(start + 1, len(debts)):\n        if (debts[start] > 0) != (debts[i] > 0):\n            debts[i] += debts[start]\n            result = min(result, 1 + dfs(debts, start + 1))\n            debts[i] -= debts[start]\n    return result", "def getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:\n    count1, count2, i, j = 0, 0, 0, 0\n    while count1 < n1:\n        if s1[i] == s2[j]:\n            j += 1\n            if j == len(s2):\n                j = 0\n                count2 += 1\n        i += 1\n        if i == len(s1):\n            i = 0\n            count1 += 1\n    return count2 // n2", "def findSubstringInWraproundString(p: str) -> int:\n    cnt = [0] * 26\n    length = 0\n\n    for i in range(len(p)):\n        if i > 0 and (p[i] == chr(ord(p[i - 1]) + 1) or ord(p[i - 1]) - ord(p[i]) == 25):\n            length += 1\n        else:\n            length = 1\n        cnt[ord(p[i]) - ord('a')] = max(cnt[ord(p[i]) - ord('a')], length)\n\n    return sum(cnt)", "def validateIP(queryIP):\n    ipv4_parts = queryIP.split('.')\n    ipv6_parts = queryIP.split(':')\n\n    if len(ipv4_parts) == 4:\n        if is_valid_ipv4(ipv4_parts):\n            return \"IPv4\"\n    elif len(ipv6_parts) == 8:\n        if is_valid_ipv6(ipv6_parts):\n            return \"IPv6\"\n\n    return \"Neither\"\n\ndef is_valid_ipv4(parts):\n    for part in parts:\n        if not part or len(part) > 3 or (len(part) > 1 and part[0] == '0'):\n            return False\n\n        if not part.isdigit() or int(part) < 0 or int(part) > 255:\n            return False\n\n    return True\n\ndef is_valid_ipv6(parts):\n    for part in parts:\n        if not part or len(part) > 4:\n            return False\n\n        for ch in part:\n            if not ch.isdigit() and not (ch.lower() >= 'a' and ch.lower() <= 'f'):\n                return False\n\n    return True", "def isConvex(points):\n    n = len(points)\n    pre = cur = 0\n\n    for i in range(n):\n        x1 = points[(i + 1) % n][0] - points[i][0]\n        y1 = points[(i + 1) % n][1] - points[i][1]\n        x2 = points[(i + 2) % n][0] - points[(i + 1) % n][0]\n        y2 = points[(i + 2) % n][1] - points[(i + 1) % n][1]\n        cur = x1 * y2 - x2 * y1\n\n        if cur == 0:\n            continue\n        if cur * pre < 0:\n            return False\n        pre = cur\n\n    return True", "def rand7():\n    pass  # Provided API\n\ndef rand10():\n    result = None\n    while True:\n        result = (rand7() - 1) * 7 + rand7()\n        if result <= 40:\n            break\n    return result % 10 + 1", "def encode(s: str) -> str:\n    n = len(s)\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            reps = n // i\n            sub = s[:i]\n            composed = sub * reps\n            if s == composed:\n                return f\"{reps}[{sub}]\"\n    return s", "def is_concatenated(word, word_dict):\n    n = len(word)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and word[j:i] in word_dict:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\ndef find_all_concatenated_words(words):\n    word_dict = set(words)\n    result = []\n\n    for word in words:\n        if is_concatenated(word, word_dict):\n            result.append(word)\n\n    return result", "from itertools import chain\n\ndef makesquare(matchsticks):\n    if len(matchsticks) < 4:\n        return False\n    total = sum(matchsticks)\n    if total % 4:\n        return False\n    target = total // 4\n    matchsticks.sort(reverse=True)\n    sums = [0]*4\n    return dfs(matchsticks, sums, target, 0)\n\ndef dfs(matchsticks, sums, target, index):\n    if index == len(matchsticks):\n        return sums[0] == target and sums[1] == target and sums[2] == target\n    for i in range(4):\n        if sums[i] + matchsticks[index] <= target:\n            sums[i] += matchsticks[index]\n            if dfs(matchsticks, sums, target, index + 1):\n                return True\n            sums[i] -= matchsticks[index]\n    return False", "def findMaxForm(strs, m, n):\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for s in strs:\n        ones = s.count('1')\n        zeros = len(s) - ones\n        \n        for i in range(m, zeros - 1, -1):\n            for j in range(n, ones - 1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n    \n    return dp[m][n]", "def findRadius(houses, heaters):\n    houses.sort()\n    heaters.sort()\n    result, i = 0, 0\n\n    for house in houses:\n        while i < len(heaters) - 1 and abs(heaters[i + 1] - house) <= abs(heaters[i] - house):\n            i += 1\n        result = max(result, abs(heaters[i] - house))\n\n    return result", "def find_complement(num: int) -> int:\n    bit_length = 0\n    mask = num\n    while mask > 0:\n        mask >>= 1\n        bit_length += 1\n    all_ones = (1 << bit_length) - 1\n\n    return num ^ all_ones", "def total_hamming_distance(nums):\n    total_distance = 0\n    n = len(nums)\n\n    for i in range(32):\n        bit_count = sum(((num >> i) & 1) for num in nums)\n        total_distance += bit_count * (n - bit_count)\n\n    return total_distance", "import random\nfrom math import sqrt, pi, cos, sin\n\nclass Solution:\n\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        r = sqrt(random.random()) * self.radius\n        theta = random.random() * 2 * pi\n        return [self.x_center + r * cos(theta), self.y_center + r * sin(theta)]", "def largestPalindrome(n):\n    if n == 1: \n        return 9\n    upper_limit = 10**n - 1\n    lower_limit = upper_limit // 10\n    for i in range(upper_limit, lower_limit, -1):\n        temp = i\n        reverse = 0\n        while temp != 0:\n            reverse = reverse * 10 + temp % 10\n            temp //= 10\n        palindrome = i * (10**n) + reverse\n        for j in range(upper_limit, lower_limit, -1):\n            product = palindrome // j\n            if palindrome % j == 0 and product <= upper_limit:\n                return palindrome % 1337\n    return -1", "from sortedcontainers import SortedList\n\ndef medianSlidingWindow(nums, k):\n    window = SortedList(nums[:k])\n    medians = []\n    \n    for i in range(k, len(nums) + 1):\n        medians.append((window[k // 2 - 1] + window[k // 2]) / 2 if k % 2 == 0 else float(window[k // 2]))\n        \n        if i < len(nums):\n            window.remove(nums[i - k])\n            window.add(nums[i])\n\n    return medians", "def magical_string(n: int) -> int:\n    if n == 0:\n        return 0\n    if n <= 3:\n        return 1\n\n    magic = [1, 2, 2]\n    count_ones = 1\n    index = 2\n    value = 1\n\n    while len(magic) < n:\n        for _ in range(magic[index]):\n            magic.append(value)\n            if value == 1 and len(magic) <= n:\n                count_ones += 1\n        value = 3 - value\n        index += 1\n\n    return count_ones", "def license_key_formatting(s: str, k: int) -> str:\n    result = []\n    count = 0\n    for c in reversed(s):\n        if c != '-':\n            if count == k:\n                result.append('-')\n                count = 0\n            result.append(c.upper())\n            count += 1\n    return ''.join(reversed(result))", "def smallest_good_base(n: str) -> str:\n    num_n = int(n)\n\n    for m in range(int(num_n.bit_length()), 0, -1):\n        k = int(num_n ** (1.0 / m))\n        if sum(k**i for i in range(m+1)) == num_n:\n            return str(k)\n\n    return \"-1\"", "def findPermutation(s: str) -> list[int]:\n    perm = [0] * (len(s) + 1)\n    left = 1\n    i = 0\n    while i < len(s):\n        if s[i] == 'I':\n            perm[i] = left\n            left += 1\n            while i + 1 < len(s) and s[i + 1] == 'D':\n                i += 1\n        i += 1\n    perm[len(s)] = left\n    left += 1\n    for i in reversed(range(len(s))):\n        if s[i] == 'D':\n            perm[i] = left\n            left += 1\n    return perm", "def findMaxConsecutiveOnes(nums):\n    max_consecutive, current_consecutive = 0, 0\n    for num in nums:\n        current_consecutive = current_consecutive + 1 if num == 1 else 0\n        max_consecutive = max(max_consecutive, current_consecutive)\n    return max_consecutive", "def can_win(nums):\n    n = len(nums)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = nums[i]\n    for len in range(1, n):\n        for i in range(n - len):\n            j = i + len\n            dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])\n    return dp[0][n - 1] >= 0", "def findMaxConsecutiveOnes(nums: List[int]) -> int:\n    max_count, count_zeros, left = 0, 0, 0\n    for right in range(len(nums)):\n        if nums[right] == 0:\n            count_zeros += 1\n        while count_zeros > 1:\n            if nums[left] == 0:\n                count_zeros -= 1\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count", "from collections import Counter\n\ndef find_min_step(board: str, hand: str) -> int:\n    def find_min_step_helper(board, memo, hand):\n        if not board:\n            return 0\n        if board in memo:\n            return memo[board]\n\n        result = float('inf')\n        i = 0\n        while i < len(board):\n            j = i\n            while j < len(board) and board[i] == board[j]:\n                j += 1            \n\n            color = board[i]\n            required = 3 - (j - i)\n            if hand[color] >= required:\n                hand[color] -= required\n                next_board = board[:i] + board[j:]\n                tmp = find_min_step_helper(next_board, memo, hand)\n                if tmp != -1:\n                    result = min(result, tmp + required)\n                hand[color] += required\n            i = j\n\n        memo[board] = -1 if result == float('inf') else result\n        return memo[board]\n\n    hand_count = Counter(hand)\n    memo = {}\n    return find_min_step_helper(board, memo, hand_count)", "from math import comb\n\ndef kthSmallestPath(destination, k):\n    row, col = destination\n    ans = \"\"\n\n    for i in range(row + col):\n        if row == 0:\n            ans += 'H'\n            col -= 1\n        elif col == 0:\n            ans += 'V'\n            row -= 1\n        elif k <= comb(row + col - 1, row - 1):\n            ans += 'H'\n            col -= 1\n        else:\n            ans += 'V'\n            k -= comb(row + col - 1, row - 1)\n            row -= 1\n\n    return ans", "def hasPath(maze, start, destination):\n    dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    q = [start]\n    while q:\n        x, y = q.pop(0)\n        if x == destination[0] and y == destination[1]:\n            return True\n        for dx, dy in dirs:\n            i, j = x, y\n            while 0 <= i + dx < len(maze) and 0 <= j + dy < len(maze[0]) and maze[i + dx][j + dy] == 0:\n                i += dx\n                j += dy\n            if maze[i][j] == 0:\n                maze[i][j] = 1\n                q.append((i, j))\n    return False", "from typing import List\n\ndef findSubsequences(nums: List[int]) -> List[List[int]]:\n    res = set()\n    dfs(nums, 0, [], res)\n    return list(res)\n\ndef dfs(nums, start, path, res):\n    if len(path) >= 2:\n        res.add(tuple(path))\n    for i in range(start, len(nums)):\n        if path and path[-1] > nums[i]:\n            continue\n        dfs(nums, i + 1, path + [nums[i]], res)", "def constructRectangle(area: int) -> List[int]:\n    width = int(area**0.5)\n    while area % width != 0:\n        width -= 1\n    length = area // width\n    return [length, width]", "def reversePairs(nums):\n    def mergeSort(l, r):\n        if l >= r:\n            return 0\n        \n        mid = (l + r) // 2\n        count = mergeSort(l, mid) + mergeSort(mid + 1, r)\n        j = mid + 1\n        for i in range(l, mid + 1):\n            while j <= r and nums[i] > 2 * nums[j]:\n                j += 1\n            count += j - (mid + 1)\n        \n        nums[l:r + 1] = sorted(nums[l:r + 1])\n        \n        return count\n    \n    return mergeSort(0, len(nums) - 1)", "def findTargetSumWays(nums, target):\n    total_sum = sum(nums)\n    if total_sum < target or (total_sum + target) % 2 != 0:\n        return 0\n    target_sum = (total_sum + target) // 2\n    dp = [0] * (target_sum + 1)\n    dp[0] = 1\n    for num in nums:\n        for j in range(target_sum, num - 1, -1):\n            dp[j] += dp[j - num]\n    return dp[target_sum]", "def find_poisoned_duration(time_series, duration):\n    if not time_series:\n        return 0\n    total = 0\n    for i in range(1, len(time_series)):\n        total += min(time_series[i] - time_series[i - 1], duration)\n    return total + duration", "def next_greater_element(nums1, nums2):\n    next_greater = {}\n    stack = []\n\n    for num in nums2:\n        while stack and stack[-1] < num:\n            next_greater[stack.pop()] = num\n        stack.append(num)\n\n    return [next_greater.get(n, -1) for n in nums1]", "import random\nfrom typing import List\n\nclass Solution:\n    def __init__(self, rects: List[List[int]]):\n        self.rects = rects\n        self.areas = [0] * len(rects)\n        self.total_area = 0\n\n        for i, rect in enumerate(rects):\n            area = (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1)\n            self.areas[i] = area\n            self.total_area += area\n\n    def pick(self) -> List[int]:\n        rnd = random.randint(0, self.total_area - 1)\n        idx = 0\n        while rnd >= self.areas[idx]:\n            rnd -= self.areas[idx]\n            idx += 1\n\n        x = random.randint(self.rects[idx][0], self.rects[idx][2])\n        y = random.randint(self.rects[idx][1], self.rects[idx][3])\n        \n        return [x, y]", "from typing import List\n\ndef findDiagonalOrder(mat: List[List[int]]) -> List[int]:\n    m, n = len(mat), len(mat[0])\n    result = [0] * (m * n)\n    row, col = 0, 0\n    for i in range(m * n):\n        result[i] = mat[row][col]\n        if (row + col) % 2 == 0:\n            if col == n - 1:\n                row += 1\n            elif row == 0:\n                col += 1\n            else:\n                row -= 1\n                col += 1\n        else:\n            if row == m - 1:\n                col += 1\n            elif col == 0:\n                row += 1\n            else:\n                row += 1\n                col -= 1\n    return result", "from heapq import heappush, heappop\n\nclass Solution:\n    def findShortestWay(self, maze: List[List[int]], ball: List[int], hole: List[int]) -> str:\n        m, n = len(maze), len(maze[0])\n        dist = [[float(\"inf\")] * n for _ in range(m)]\n        dirs = [\"d\", \"l\", \"r\", \"u\"]\n        dirs_vector = [[1, 0], [0, -1], [0, 1], [-1, 0]]\n        dist[ball[0]][ball[1]] = 0\n        pq = [(0, \"\", ball[0], ball[1])]\n        \n        while pq:\n            cur_dist, cur_path, x, y = heappop(pq)\n            if [x, y] == hole:\n                return cur_path\n\n            for k, d in enumerate(dirs):\n                dist_move, r, c = 0, x + dirs_vector[k][0], y + dirs_vector[k][1]\n                while 0 <= r < m and 0 <= c < n and maze[r][c] == 0 and [r, c] != hole:\n                    r += dirs_vector[k][0]\n                    c += dirs_vector[k][1]\n                    dist_move += 1\n                r -= dirs_vector[k][0]\n                c -= dirs_vector[k][1]\n                dist_move -= 1\n                \n                if dist[x][y] + dist_move < dist[r][c]:\n                    dist[r][c] = dist[x][y] + dist_move\n                    heappush(pq, (cur_dist + dist_move, cur_path + d, r, c))\n        \n        return \"impossible\"", "def find_words(words):\n    rows = [\n        set(\"qwertyuiopQWERTYUIOP\"),\n        set(\"asdfghjklASDFGHJKL\"),\n        set(\"zxcvbnmZXCVBNM\")\n    ]\n    res = []\n\n    for word in words:\n        row = -1\n        for i in range(3):\n            if word[0] in rows[i]:\n                row = i\n                break\n\n        if all(c in rows[row] for c in word):\n            res.append(word)\n\n    return res", "def findMode(root):\n    def InOrder(node):\n        if not node: return\n        yield from InOrder(node.left)\n        yield node.val\n        yield from InOrder(node.right)\n        \n    counts = collections.Counter(InOrder(root))\n    max_count = max(counts.values(), default=0)\n    return [k for k, v in counts.items() if v == max_count]", "import heapq\n\ndef findMaximizedCapital(k: int, w: int, profits, capital) -> int:\n    project_pool = list(zip(capital, profits))\n    project_pool.sort(reverse=True)\n    \n    profit_pool = []\n    \n    while k:\n        while project_pool and project_pool[-1][0] <= w:\n            heapq.heappush(profit_pool, -project_pool.pop()[1])\n        \n        if not profit_pool:\n            break\n        \n        w -= heapq.heappop(profit_pool)\n        k -= 1\n        \n    return w", "def nextGreaterElements(nums):\n    result = [-1] * len(nums)\n    stack = []\n\n    for i in range(len(nums) * 2):\n        index = i % len(nums)\n        while stack and nums[stack[-1]] < nums[index]:\n            result[stack.pop()] = nums[index]\n        if i < len(nums):\n            stack.append(index)\n\n    return result", "def convert_to_base7(num: int) -> str:\n    if num == 0:\n        return \"0\"\n    result = \"\"\n    negative = num < 0\n    if negative:\n        num *= -1\n    while num > 0:\n        result = str(num % 7) + result\n        num //= 7\n    return \"-\" + result if negative else result", "from queue import PriorityQueue\n\ndef shortestDistance(maze, start, destination):\n    m, n = len(maze), len(maze[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    dist = [[-1 for _ in range(n)] for _ in range(m)]\n\n    q = PriorityQueue()\n\n    dist[start[0]][start[1]] = 0\n    q.put((0, start[0], start[1]))\n\n    while not q.empty():\n        cur = q.get()\n        x, y = cur[1], cur[2]\n\n        for dir in directions:\n            newX, newY = x + dir[0], y + dir[1]\n            step = 0\n\n            while 0 <= newX < m and 0 <= newY < n and maze[newX][newY] == 0:\n                newX += dir[0]\n                newY += dir[1]\n                step += 1\n\n            newX -= dir[0]\n            newY -= dir[1]\n\n            if dist[newX][newY] == -1 or dist[x][y] + step < dist[newX][newY]:\n                dist[newX][newY] = dist[x][y] + step\n                q.put((dist[newX][newY], newX, newY))\n\n    return dist[destination[0]][destination[1]]", "def find_relative_ranks(score):\n    rank_sort = sorted(range(len(score)), key=lambda i: score[i], reverse=True)\n    result = [0] * len(score)\n    for i, rank in enumerate(rank_sort):\n        result[rank] = i + 1\n    return result", "def checkPerfectNumber(num: int) -> bool:\n    if num <= 1:\n        return False\n    sum = 1\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            sum += i\n            if i * i != num:\n                sum += num // i\n        i += 1\n    return sum == num", "from collections import defaultdict\n\ndef helper(node, counts):\n    if not node: return 0\n    val = node.val + helper(node.left, counts) + helper(node.right, counts)\n    counts[val] += 1\n    return val\n\ndef findFrequentTreeSum(root):\n    counts = defaultdict(int)\n    helper(root, counts)\n    max_count = max(counts.values(), default=0)\n    return [s for s, c in counts.items() if c == max_count]", "def fib(n: int) -> int:\n    if n < 2:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b", "class Node:\n    def __init__(self, val, left=None, right=None, parent=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.parent = parent\n\ndef inorder_successor(node: Node) -> Node:\n    if node.right:\n        node = node.right\n        while node.left:\n            node = node.left\n        return node\n\n    while node.parent and node == node.parent.right:\n        node = node.parent\n\n    return node.parent", "def findBottomLeftValue(self, root: TreeNode) -> int:\n    result = [0, 0] # [depth, value]\n    self.helper(root, 1, result)\n    return result[1]\n\ndef helper(self, node, depth, result):\n    if not node:\n        return\n    if depth > result[0]:\n        result[0] = depth\n        result[1] = node.val\n\n    self.helper(node.left, depth+1, result)\n    self.helper(node.right, depth+1, result)", "def find_rotate_steps(ring: str, key: str) -> int:\n    n, m = len(ring), len(key)\n    dp = [[0] * n for _ in range(m + 1)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n):\n            dp[i][j] = float('inf')\n            for k in range(n):\n                if ring[k] == key[i]:\n                    diff = abs(j - k)\n                    step = min(diff, n - diff)\n                    dp[i][j] = min(dp[i][j], step + dp[i + 1][k])\n\n    return dp[0][0] + m", "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef largestValues(root: TreeNode):\n    if not root:\n        return []\n    result = []\n    queue = deque([root])\n\n    while queue:\n        size = len(queue)\n        max_val = float('-inf')\n        for _ in range(size):\n            node = queue.popleft()\n            max_val = max(max_val, node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        result.append(max_val)\n\n    return result", "def longestPalindromeSubseq(s: str) -> int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n                \n    return dp[0][n - 1]", "def find_min_moves(machines):\n    n = len(machines)\n    total_dresses = sum(machines)\n    if total_dresses % n != 0:\n        return -1\n    average = total_dresses // n\n    moves = 0\n    imbalance = 0\n    \n    for i in range(n):\n        imbalance += machines[i] - average\n        moves = max(moves, abs(imbalance), machines[i] - average)\n        \n    return moves", "def change(amount, coins):\n    dp = [1] + [0] * amount\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] += dp[i - coin]\n    return dp[amount]", "import random\n\nclass Solution:\n    def __init__(self, m: int, n: int):\n        self.m, self.n = m, n\n        self.total = m * n\n        self.matrix = [[0] * n for _ in range(m)]\n\n    def flip(self):\n        idx = random.randint(0, self.total - 1)\n        self.total -= 1\n\n        for i in range(self.m):\n            for j in range(self.n):\n                if self.matrix[i][j] == 0:\n                    if idx == 0:\n                        self.matrix[i][j] = 1\n                        return [i, j]\n                    idx -= 1\n        return [-1, -1] # This line should never be reached\n\n    def reset(self):\n        self.total = self.m * self.n\n        for row in self.matrix:\n            for j in range(self.n):\n                row[j] = 0", "def detectCapitalUse(word: str) -> bool:\n    numCapital = sum(1 for c in word if c.isupper())\n    return numCapital == 0 or numCapital == len(word) or (numCapital == 1 and word[0].isupper())", "def findLUSlength(a: str, b: str) -> int:\n    if a == b:\n        return -1\n    return max(len(a), len(b))", "def find_lus_length(strs):\n    max_length = -1\n    for i in range(len(strs)):\n        is_uncommon = True\n        for j in range(len(strs)):\n            if i != j and strs[i] in strs[j]:\n                is_uncommon = False\n                break\n        if is_uncommon:\n            max_length = max(max_length, len(strs[i]))\n    return max_length", "def checkSubarraySum(nums, k):\n    n, sum_ = len(nums), 0\n    mp = {0: -1}\n    for i, num in enumerate(nums):\n        sum_ += num\n        if k != 0:\n            sum_ %= k\n        if sum_ in mp:\n            if i - mp[sum_] > 1:\n                return True\n        else:\n            mp[sum_] = i\n    return False", "def findLongestWord(s, dictionary):\n    def is_subsequence(target, source):\n        iter_source = iter(source)\n        return all(char in iter_source for char in target)\n\n    dictionary = sorted(dictionary)\n    longest = ''\n    for word in dictionary:\n        if is_subsequence(word, s) and len(word) > len(longest):\n            longest = word\n    return longest", "def findMaxLength(nums):\n    counts = {0: -1}\n    max_len = count = 0\n    for i, num in enumerate(nums):\n        count += 1 if num == 1 else -1\n        if count in counts:\n            max_len = max(max_len, i - counts[count])\n        else:\n            counts[count] = i\n    return max_len", "def countArrangement(n: int) -> int:\n    def helper(idx: int, visited: List[bool], n: int) -> int:\n        if idx > n:\n            return 1\n\n        count = 0\n        for i in range(1, n+1):\n            if not visited[i] and (idx % i == 0 or i % idx == 0):\n                visited[i] = True\n                count += helper(idx+1, visited, n)\n                visited[i] = False\n\n        return count\n\n    visited = [False] * (n+1)\n    return helper(1, visited, n)", "def wordsAbbreviation(words):\n    def abbrev(word, k):\n        return word[:k+1] + str(len(word) - k - 2) + word[-1] if k < len(word) - 2 else word\n\n    n = len(words)\n    abbr = [abbrev(word, 1) for word in words]\n    prefix_len = [1] * n\n\n    for i in range(n):\n        while abbr.count(abbr[i]) > 1:\n            groups = {}\n            for j in range(i + 1, n):\n                if abbr[i] == abbr[j]:\n                    if abbr[j] not in groups:\n                        groups[abbr[j]] = []\n                    groups[abbr[j]].append(j)\n            for group_members in groups.values():\n                for j in group_members:\n                    abbr[j] = abbrev(words[j], prefix_len[j] + 1)\n                    prefix_len[j] += 1\n            abbr[i] = abbrev(words[i], prefix_len[i] + 1)\n            prefix_len[i] += 1\n\n    return abbr", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef swapNodes(head, k):\n    first, second, temp = head, head, head\n    for _ in range(k - 1):\n        temp = temp.next\n    first = temp\n    temp = temp.next\n    while temp:\n        temp = temp.next\n        second = second.next\n\n    first.val, second.val = second.val, first.val\n    return head", "from typing import List\n\ndef reveal(board: List[List[str]], row: int, col: int, directions: List[List[int]]) -> None:\n    if row < 0 or row >= len(board) or col < 0 or col >= len(board[0]) or board[row][col] != 'E':\n        return\n\n    mines = 0\n    for dir in directions:\n        newRow, newCol = row + dir[0], col + dir[1]\n        if newRow >= 0 and newRow < len(board) and newCol >= 0 and newCol < len(board[0]) and board[newRow][newCol] == 'M':\n            mines += 1\n\n    if mines > 0:\n        board[row][col] = str(mines)\n    else:\n        board[row][col] = 'B'\n        for dir in directions:\n            reveal(board, row + dir[0], col + dir[1], directions)\n\ndef updateBoard(board: List[List[str]], click: List[int]) -> List[List[str]]:\n    row, col = click\n\n    if board[row][col] == 'M':\n        board[row][col] = 'X'\n    else:\n        directions = [[1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1]]\n        reveal(board, row, col, directions)\n\n    return board", "class TreeNode:\n    def __init__(self, x: int):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def getMinimumDifference(self, root: TreeNode) -> int:\n        result = float('inf')\n        prev = None\n\n        def inorderTraversal(node):\n            nonlocal result, prev\n            if node is None:\n                return\n            inorderTraversal(node.left)\n            if prev is not None:\n                result = min(result, node.val - prev.val)\n            prev = node\n            inorderTraversal(node.right)\n\n        inorderTraversal(root)\n        return result", "def findLonelyPixel(picture):\n    m, n = len(picture), len(picture[0])\n    row, col = [0] * m, [0] * n\n    \n    for i in range(m):\n        for j in range(n):\n            if picture[i][j] == 'B':\n                row[i] += 1\n                col[j] += 1\n                \n    lonely = 0\n    for i in range(m):\n        for j in range(n):\n            if picture[i][j] == 'B' and row[i] == 1 and col[j] == 1:\n                lonely += 1\n                \n    return lonely", "def find_pairs(nums, k):\n    if k < 0:\n        return 0\n    starters = set()\n    occurrences = {}\n    for num in nums:\n        if num + k in occurrences:\n            starters.add(num)\n        if num - k in occurrences:\n            starters.add(num - k)\n        occurrences[num] = occurrences.get(num, 0) + 1\n    return len(starters)", "def findBlackPixel(picture, target):\n    m, n = len(picture), len(picture[0])\n    rows = [0] * m\n    cols = [0] * n\n    rowCounts = {}\n    for i in range(m):\n        row = \"\"\n        for j in range(n):\n            if picture[i][j] == 'B':\n                rows[i] += 1\n                cols[j] += 1\n            row += picture[i][j]\n        if rows[i] == target:\n            rowCounts[row] = rowCounts.get(row, 0) + 1\n    ans = 0\n    for row, count in rowCounts.items():\n        if count == target:\n            for j in range(n):\n                if row[j] == 'B' and cols[j] == target:\n                    ans += count\n    return ans", "import random\nimport string\n\nclass Solution:\n    def __init__(self):\n        self.url_map = {}\n        self.alphabet = string.ascii_letters + string.digits\n\n    def encode(self, longUrl: str) -> str:\n        key = ''.join(random.choices(self.alphabet, k=6))\n\n        while key in self.url_map:\n            key = ''.join(random.choices(self.alphabet, k=6))\n\n        self.url_map[key] = longUrl\n        return \"http://tinyurl.com/\" + key\n\n    def decode(self, shortUrl: str) -> str:\n        return self.url_map[shortUrl[-6:]]", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def str2tree(self, s: str) -> TreeNode:\n        def str2tree_helper(idx):\n            if idx[0] >= len(s):\n                return None\n\n            sign = 1\n            if s[idx[0]] == '-':\n                sign = -1\n                idx[0] += 1\n                \n            num = 0\n            while idx[0] < len(s) and s[idx[0]].isdigit():\n                num = num * 10 + int(s[idx[0]])\n                idx[0] += 1\n\n            node = TreeNode(sign * num)\n\n            if idx[0] < len(s) and s[idx[0]] == '(':\n                idx[0] += 1\n                node.left = str2tree_helper(idx)\n                idx[0] += 1\n            if idx[0] < len(s) and s[idx[0]] == '(':\n                idx[0] += 1\n                node.right = str2tree_helper(idx)\n                idx[0] += 1\n\n            return node\n\n        idx = [0]\n        return str2tree_helper(idx)", "def complexNumberMultiply(num1: str, num2: str) -> str:\n    real1, imag1 = map(int, num1[:-1].split('+'))\n    real2, imag2 = map(int, num2[:-1].split('+'))\n\n    real = real1 * real2 - imag1 * imag2\n    imag = real1 * imag2 + real2 * imag1\n\n    return f\"{real}+{imag}i\"", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def __init__(self):\n        self.sum = 0\n\n    def convertBST(self, root: TreeNode) -> TreeNode:\n        if root:\n            self.convertBST(root.right)\n            self.sum += root.val\n            root.val = self.sum\n            self.convertBST(root.left)\n        \n        return root", "def findMinDifference(timePoints):\n    timePoints.sort()\n    min_difference = float('inf')\n\n    for i in range(len(timePoints)):\n        h1, m1 = map(int, timePoints[i].split(':'))\n        h2, m2 = map(int, timePoints[(i+1)%len(timePoints)].split(':'))\n        cur_difference = abs((h1 * 60 + m1) - (h2 * 60 + m2))\n        min_difference = min(min_difference, 1440 - cur_difference if cur_difference > 720 else cur_difference)\n\n    return min_difference", "def singleNonDuplicate(nums):\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = low + (high - low) // 2\n        if mid % 2 == 1:\n            mid -= 1\n        if nums[mid] == nums[mid + 1]:\n            low = mid + 2\n        else:\n            high = mid\n    return nums[low]", "def reverseStr(s, k):\n    chars = list(s)\n    for i in range(0, len(chars), 2 * k):\n        chars[i:i + k] = reversed(chars[i:i + k])\n    return \"\".join(chars)", "from collections import deque\n\ndef updateMatrix(mat):\n    m, n = len(mat), len(mat[0])\n    distance = [[0 if mat[i][j] == 0 else float('inf') for j in range(n)] for i in range(m)]\n    queue = deque([(i, j) for i in range(m) for j in range(n) if mat[i][j] == 0])\n\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            newX, newY = x + dx, y + dy\n            if 0 <= newX < m and 0 <= newY < n and distance[newX][newY] > distance[x][y] + 1:\n                distance[newX][newY] = distance[x][y] + 1\n                queue.append((newX, newY))\n\n    return distance", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef diameter_of_binary_tree(root):\n    def _diameter_of_binary_tree(node):\n        if not node:\n            return 0, 0\n        left_height, left_diameter = _diameter_of_binary_tree(node.left)\n        right_height, right_diameter = _diameter_of_binary_tree(node.right)\n        height = 1 + max(left_height, right_height)\n        diameter = max(left_height + right_height, max(left_diameter, right_diameter))\n        return height, diameter\n\n    return _diameter_of_binary_tree(root)[1]", "def findContestMatch(n):\n    matches = [str(i) for i in range(1, n + 1)]\n\n    while n > 1:\n        for i in range(n // 2):\n            matches[i] = \"(\" + matches[i] + \",\" + matches[n - 1 - i] + \")\"\n        n //= 2\n\n    return matches[0]", "class Solution:\n    def leftBoundary(self, node, boundary):\n        if not node or not (node.left or node.right):\n            return\n        boundary.append(node.val)\n        if node.left:\n            self.leftBoundary(node.left, boundary)\n        else:\n            self.leftBoundary(node.right, boundary)\n\n    def rightBoundary(self, node, boundary):\n        if not node or not (node.left or node.right):\n            return\n        if node.right:\n            self.rightBoundary(node.right, boundary)\n        else:\n            self.rightBoundary(node.left, boundary)\n        boundary.append(node.val)\n\n    def leaves(self, node, boundary):\n        if not node:\n            return\n        if not (node.left or node.right):\n            boundary.append(node.val)\n        self.leaves(node.left, boundary)\n        self.leaves(node.right, boundary)\n\n    def boundaryOfBinaryTree(self, root):\n        res = []\n        if not root:\n            return res\n        res.append(root.val)\n        self.leftBoundary(root.left, res)\n        self.leaves(root, res)\n        self.rightBoundary(root.right, res)\n        return res", "def removeBoxes(boxes):\n    def dfs(l, r, k):\n        if l > r: return 0\n        if dp[l][r][k] != 0: return dp[l][r][k]\n\n        while r > l and boxes[r] == boxes[r - 1]:\n            r -= 1\n            k += 1\n            \n        dp[l][r][k] = (k + 1) * (k + 1) + dfs(l, r - 1, 0)\n\n        for i in range(l, r):\n            if boxes[i] == boxes[r]:\n                dp[l][r][k] = max(dp[l][r][k], dfs(l, i, k + 1) + dfs(i + 1, r - 1, 0))\n                \n        return dp[l][r][k]\n\n    dp = [[[0] * 100 for _ in xrange(100)] for _ in xrange(100)]\n    return dfs(0, len(boxes) - 1, 0)", "def findCircleNum(isConnected):\n    def dfs(isConnected, visited, i):\n        visited[i] = True\n        for j in range(len(isConnected)):\n            if isConnected[i][j] == 1 and not visited[j]:\n                dfs(isConnected, visited, j)\n\n    provinces = 0\n    visited = [False] * len(isConnected)\n    for i in range(len(isConnected)):\n        if not visited[i]:\n            dfs(isConnected, visited, i)\n            provinces += 1\n    return provinces", "def find_triplet_equal_sum(nums):\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n\n    for i in range(1, n - 2):\n        for j in range(i + 2, n - 1):\n            for k in range(j + 2, n):\n                s1 = prefix_sum[i]\n                s2 = prefix_sum[j] - prefix_sum[i + 1]\n                s3 = prefix_sum[k] - prefix_sum[j + 1]\n                s4 = prefix_sum[n] - prefix_sum[k + 1]\n                if s1 == s2 == s3 == s4:\n                    return True\n    return False", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef longest_consecutive(root: TreeNode) -> int:\n    def longest_consecutive_path_util(node, max_length):\n        if not node:\n            return 0\n        left = longest_consecutive_path_util(node.left, max_length) + 1\n        right = longest_consecutive_path_util(node.right, max_length) + 1\n        if node.left and node.left.val != node.val + 1:\n            left = 1\n        if node.right and node.right.val != node.val + 1:\n            right = 1\n        length = max(left, right)\n        max_length[0] = max(max_length[0], left + right - 1)\n        return length\n\n    max_length = [0]\n    longest_consecutive_path_util(root, max_length)\n    return max_length[0]", "def checkRecord(s: str) -> bool:\n    late, absent = 0, 0\n    for c in s:\n        if c == 'A':\n            absent += 1\n            late = 0\n        elif c == 'L':\n            late += 1\n        else:\n            late = 0\n\n        if absent >= 2 or late >= 3:\n            return False\n    return True", "def checkRecord(n: int) -> int:\n    M = 1000000007\n    dp = [1] * 6  # [latent state 0, latent state 1, ..., latent state 5]\n    while n:\n        next_dp = [0] * 6\n        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M\n        next_dp[1] = dp[0]\n        next_dp[2] = dp[1]\n        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M\n        next_dp[4] = dp[3]\n        next_dp[5] = dp[4]\n        dp = next_dp\n        n -= 1\n    return sum(dp) % M", "def optimal_division(nums):\n    n = len(nums)\n    if n == 1:\n        return str(nums[0])\n    if n == 2:\n        return str(nums[0]) + '/' + str(nums[1])\n    res = str(nums[0]) + '/('\n    for i in range(1, n - 1):\n        res += str(nums[i]) + '/'\n    res += str(nums[n - 1]) + ')'\n    return res", "from collections import defaultdict\n\ndef least_bricks(wall):\n    edge_count = defaultdict(int)\n    max_count = 0\n\n    for row in wall:\n        edge_position = 0\n        for i in range(len(row) - 1):\n            edge_position += row[i]\n            edge_count[edge_position] += 1\n            max_count = max(max_count, edge_count[edge_position])\n\n    return len(wall) - max_count", "def splitLoopedString(strs):\n    ans = ''\n    cur = ''.join(max(s, s[::-1]) for s in strs)\n    \n    for i, s in enumerate(strs):\n        for xstr in (s, s[::-1]):\n            for j in range(len(xstr)):\n                t = xstr[j:] + cur[len(xstr):] + cur[:len(xstr)] + xstr[:j]\n                ans = max(ans, t)\n        cur = cur[len(s):] + cur[:len(s)]\n    \n    return ans", "from itertools import permutations\n\ndef nextGreaterElement(n: int) -> int:\n    num_str = str(n)\n    num_permutations = sorted(set(int(\"\".join(p)) for p in permutations(num_str)))\n    index = num_permutations.index(n)\n    if index + 1 < len(num_permutations) and num_permutations[index + 1] <= 2**31 - 1:\n        return num_permutations[index + 1]\n    return -1", "def reverse_words_in_string(s: str) -> str:\n    return \" \".join(word[::-1] for word in s.split(\" \"))", "class Node:\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n\nclass Solution:\n    def intersect(self, quadTree1: 'Node', quadTree2: 'Node') -> 'Node':\n        if quadTree1.isLeaf:\n            return quadTree1 if quadTree1.val else quadTree2\n        if quadTree2.isLeaf:\n            return quadTree2 if quadTree2.val else quadTree1\n        \n        quadTree1.topLeft = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\n        quadTree1.topRight = self.intersect(quadTree1.topRight, quadTree2.topRight)\n        quadTree1.bottomLeft = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\n        quadTree1.bottomRight = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\n        \n        if (quadTree1.topLeft.isLeaf and quadTree1.topRight.isLeaf and\n            quadTree1.bottomLeft.isLeaf and quadTree1.bottomRight.isLeaf and\n            quadTree1.topLeft.val == quadTree1.topRight.val and\n            quadTree1.topLeft.val == quadTree1.bottomLeft.val and\n            quadTree1.topLeft.val == quadTree1.bottomRight.val):\n            quadTree1.isLeaf = True\n            quadTree1.val = quadTree1.topLeft.val\n        \n        return quadTree1", "class Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\ndef max_depth(root):\n    if root is None:\n        return 0\n    max_depth = 0\n    for child in root.children:\n        max_depth = max(max_depth, max_depth(child))\n    return max_depth + 1", "def subarraySum(nums, k):\n    prefix_sum_frequency = {0: 1}\n    prefix_sum, result = 0, 0\n    \n    for num in nums:\n        prefix_sum += num\n        result += prefix_sum_frequency.get(prefix_sum - k, 0)\n        prefix_sum_frequency[prefix_sum] = prefix_sum_frequency.get(prefix_sum, 0) + 1\n\n    return result", "def array_pair_sum(nums):\n    nums.sort()\n    return sum(nums[::2])", "def longestLine(mat):\n    rows, cols = len(mat), len(mat[0])\n    max_length = 0\n    dp = [[[0, 0, 0, 0] for _ in range(cols)] for _ in range(rows)]\n\n    for r in range(rows):\n        for c in range(cols):\n            if mat[r][c] == 1:\n                dp[r][c][0] = dp[r - 1][c][0] + 1 if r > 0 else 1\n                dp[r][c][1] = dp[r][c - 1][1] + 1 if c > 0 else 1\n                dp[r][c][2] = dp[r - 1][c - 1][2] + 1 if r > 0 and c > 0 else 1\n                dp[r][c][3] = dp[r - 1][c + 1][3] + 1 if r > 0 and c < cols - 1 else 1\n                max_length = max(max_length, max(dp[r][c]))\n\n    return max_length", "def findTilt(self, root):\n    def findTiltUtil(node):\n        if not node: return 0, 0\n        \n        leftSum, leftTilt = findTiltUtil(node.left)\n        rightSum, rightTilt = findTiltUtil(node.right)\n    \n        return (node.val + leftSum + rightSum, abs(leftSum - rightSum) + leftTilt + rightTilt)\n\n    return findTiltUtil(root)[1]", "def is_palindrome(s: str) -> bool:\n    return s == s[::-1]\n\ndef closest_palindrome(n: str) -> int:\n    num = int(n)\n    left = num - 1\n    right = num + 1\n\n    while True:\n        if is_palindrome(str(left)):\n            return left\n        if is_palindrome(str(right)):\n            return right\n        left -= 1\n        right += 1", "def arrayNesting(nums):\n    n = len(nums)\n    max_len = 0\n    for i in range(n):\n        if nums[i] != -1:\n            start = nums[i]\n            count = 0\n            while nums[start] != -1:\n                temp = start\n                start = nums[start]\n                count += 1\n                nums[temp] = -1\n            max_len = max(max_len, count)\n    return max_len", "def matrixReshape(mat, r, c):\n    m, n = len(mat), len(mat[0])\n    if m * n != r * c:\n        return mat\n\n    reshaped = [[0] * c for _ in range(r)]\n    for i in range(m * n):\n        reshaped[i // c][i % c] = mat[i // n][i % n]\n\n    return reshaped", "def checkInclusion(s1: str, s2: str) -> bool:\n    if len(s1) > len(s2): \n        return False\n    \n    s1_map = [0] * 26\n    s2_map = [0] * 26\n    \n    for i in range(len(s1)):\n        s1_map[ord(s1[i]) - ord('a')] += 1\n        s2_map[ord(s2[i]) - ord('a')] += 1\n    \n    for i in range(len(s2) - len(s1)):\n        if s1_map == s2_map: \n            return True\n        \n        s2_map[ord(s2[i]) - ord('a')] -= 1\n        s2_map[ord(s2[i + len(s1)]) - ord('a')] += 1\n\n    return s1_map == s2_map", "def maxVacationDays(flights, days):\n    n = len(flights)\n    k = len(days[0])\n    memo = [[-1] * k for _ in range(n)]\n\n    def dfs(currentWeek, currentCity):\n        if currentWeek == k:\n            return 0\n        if memo[currentCity][currentWeek] != -1:\n            return memo[currentCity][currentWeek]\n\n        maxVacation = days[currentCity][currentWeek] + dfs(currentWeek + 1, currentCity)\n\n        for i in range(n):\n            if flights[currentCity][i] == 1:\n                maxVacation = max(maxVacation, days[i][currentWeek] + dfs(currentWeek + 1, i))\n\n        memo[currentCity][currentWeek] = maxVacation\n        return maxVacation\n\n    return dfs(0, 0)", "def minDistance(height, width, tree, squirrel, nuts):\n    totalDist = 0\n    minDiff = float(\"inf\")\n    \n    for nut in nuts:\n        treeDist = abs(tree[0] - nut[0]) + abs(tree[1] - nut[1])\n        squirrelDist = abs(squirrel[0] - nut[0]) + abs(squirrel[1] - nut[1])\n        \n        totalDist += 2 * treeDist\n        minDiff = min(minDiff, squirrelDist - treeDist)\n    \n    return totalDist + minDiff", "def maxNumberOfCandies(candyType):\n    uniqueCandies = set(candyType)\n    return min(len(uniqueCandies), len(candyType) // 2)", "def findPaths(m, n, maxMove, startRow, startColumn):               \n    MOD = 10**9 + 7                     \n    dp = [[[0]* n for _ in range(m)] for _ in range(maxMove + 1)]\n    moves = ((-1, 0), (1, 0), (0, -1), (0, 1))\n\n    for k in range(1, maxMove + 1):                                \n        for i in range(m):                                         \n            for j in range(n):                                           \n                for move in moves:              \n                    ni, nj = i + move[0], j + move[1]\n                    if ni < 0 or ni >= m or nj < 0 or nj >= n:                                 \n                        dp[k][i][j] = (dp[k][i][j] + 1) % MOD          \n                    else:\n                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][ni][nj]) % MOD\n\n    return dp[maxMove][startRow][startColumn]", "def findUnsortedSubarray(nums):\n    sorted_nums = sorted(nums)\n    start, end = 0, len(nums) - 1\n    while start < len(nums) and nums[start] == sorted_nums[start]:\n        start += 1\n    while end > start and nums[end] == sorted_nums[end]:\n        end -= 1\n    return end - start + 1", "from collections import defaultdict\n\ndef killProcess(pid, ppid, kill):\n    children = defaultdict(list)\n    for i in range(len(pid)):\n        children[ppid[i]].append(pid[i])\n\n    def dfs(id, killed):\n        killed.append(id)\n        for child in children[id]:\n            dfs(child, killed)\n\n    killed = []\n    dfs(kill, killed)\n    return killed", "def minDistance(word1, word2):\n    m, n = len(word1), len(word2)\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(m+1):\n        for j in range(n+1):\n            if i == 0 or j == 0:\n                dp[i][j] = i + j\n            elif word1[i-1] == word2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])\n\n    return dp[m][n]", "def cross_product(p, q, r):\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n\ndef fence(trees):\n    trees.sort(key=lambda p: (p[0], p[1]))\n    hull = []\n    for p in trees:\n        while len(hull) >= 2 and cross_product(hull[-2], hull[-1], p) > 0:\n            hull.pop()\n        hull.append(p)\n\n    for p in reversed(trees):\n        while len(hull) >= 2 and cross_product(hull[-2], hull[-1], p) > 0:\n            hull.pop()\n        hull.append(p)\n    \n    return hull", "class FileSystem:\n    class Node:\n        def __init__(self):\n            self.is_file = False\n            self.content = \"\"\n            self.children = {}\n\n    def __init__(self):\n        self.root = self.Node()\n\n    def ls(self, path: str):\n        node = self.root\n        path_parts = self.split_path(path)\n\n        for part in path_parts:\n            node = node.children[part]\n\n        if node.is_file:\n            return path_parts[-1:]\n        else:\n            return sorted(node.children.keys())\n\n    def mkdir(self, path: str):\n        node = self.root\n        path_parts = self.split_path(path)\n\n        for part in path_parts:\n            if part not in node.children:\n                node.children[part] = self.Node()\n            node = node.children[part]\n\n    def addContentToFile(self, filePath: str, content: str):\n        node = self.root\n        path_parts = self.split_path(filePath)\n\n        for part in path_parts:\n            if part not in node.children:\n                node.children[part] = self.Node()\n            node = node.children[part]\n\n        node.is_file = True\n        node.content += content\n\n    def readContentFromFile(self, filePath: str) -> str:\n        node = self.root\n        path_parts = self.split_path(filePath)\n\n        for part in path_parts:\n            node = node.children[part]\n\n        return node.content\n\n    @staticmethod\n    def split_path(path: str):\n        return [part for part in path.split(\"/\") if part]", "class Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\ndef preorder(root):\n    result = []\n    if not root:\n        return result\n    nodes = [root]\n\n    while nodes:\n        current = nodes.pop()\n        result.append(current.val)\n        nodes.extend(reversed(current.children))\n    return result", "class Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children or []\n\ndef postorder(root):\n    result = []\n    if not root:\n        return result\n    \n    stk = [root]\n    \n    while stk:\n        current = stk.pop()\n        result.append(current.val)\n        \n        for child in current.children:\n            stk.append(child)\n    \n    return result[::-1]", "def is_valid(code, i):\n    if i >= len(code) or code[i] != '<':\n        return False, i\n    i += 1\n    name_start = i\n    while i < len(code) and code[i].isupper():\n        i += 1\n    name_len = i - name_start\n    if name_len < 1 or name_len > 9 or code[i] != '>':\n        return False, i\n    i += 1\n\n    while i < len(code) and code[i] != '<':\n        i += 1\n    if i + 2 + name_len >= len(code) or code[i:i + 2 + name_len] != '</' + code[name_start:i] + '>':\n        return False, i\n    return True, i + 2 + name_len\n\ndef validate_code_snippet(code):\n    is_valid_code, i = is_valid(code, 0)\n    return is_valid_code and i == len(code)", "from fractions import Fraction\n\ndef fractionAddition(expression: str) -> str:\n    fractions = expression.replace('+', ' +').replace('-', ' -').split()\n    result = sum(Fraction(fraction) for fraction in fractions)\n    return f\"{result.numerator}/{result.denominator}\"", "def validSquare(p1, p2, p3, p4):\n    def dist_sq(p, q):\n        return (p[0] - q[0])**2 + (p[1] - q[1])**2\n\n    points = [p1, p2, p3, p4]\n    dists = set()\n\n    for i in range(4):\n        for j in range(i + 1, 4):\n            dists.add(dist_sq(points[i], points[j]))\n\n    return len(dists) == 2 and 0 not in dists", "def findLHS(nums):\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n\n    longest_sequence = 0\n    for key in count:\n        if key + 1 in count:\n            longest_sequence = max(longest_sequence, count[key] + count[key + 1])\n\n    return longest_sequence", "def maxCount(m: int, n: int, ops: List[List[int]]) -> int:\n    for op in ops:\n        m = min(m, op[0])\n        n = min(n, op[1])\n    return m * n", "from typing import List\n\ndef findRestaurant(list1: List[str], list2: List[str]) -> List[str]:\n    restaurantMap = {restaurant: i for i, restaurant in enumerate(list1)}\n\n    minSum = float(\"inf\")\n    result = []\n    for j, restaurant in enumerate(list2):\n        if restaurant in restaurantMap:\n            totalSum = j + restaurantMap[restaurant]\n            if totalSum < minSum:\n                result = [restaurant]\n                minSum = totalSum\n            elif totalSum == minSum:\n                result.append(restaurant)\n\n    return result", "def findIntegers(n: int) -> int:\n    dp = [[0, 0] for _ in range(32)]\n    dp[0][0], dp[0][1] = 1, 1\n\n    for i in range(1, 32):\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1]\n        dp[i][1] = dp[i - 1][0]\n\n    ans = 0\n    prev_bit = 0\n    for i in range(30, -1, -1):\n        if n & (1 << i):\n            ans += dp[i][0]\n            if prev_bit:\n                break\n            prev_bit = 1\n        else:\n            prev_bit = 0\n\n    return ans + 1", "class StringIterator:\n    def __init__(self, compressedString: str):\n        self.s = compressedString\n        self.i = 0\n        self.count = 0\n        self.ch = \" \"\n    \n    def next(self) -> str:\n        if not self.hasNext():\n            return \" \"\n        if self.count == 0:\n            self.ch = self.s[self.i]\n            self.i += 1\n            while self.i < len(self.s) and self.s[self.i].isdigit():\n                self.count = self.count * 10 + int(self.s[self.i])\n                self.i += 1\n        self.count -= 1\n        return self.ch\n    \n    def hasNext(self) -> bool:\n        return self.i < len(self.s) or self.count != 0", "def canPlaceFlowers(flowerbed, n):\n    count = 0\n    for i in range(len(flowerbed)):\n        if flowerbed[i] == 0 and (i == 0 or flowerbed[i - 1] == 0) and (i == len(flowerbed) - 1 or flowerbed[i + 1] == 0):\n            flowerbed[i] = 1\n            count += 1\n        if count >= n:\n            return True\n    return count >= n", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef tree2str(t):\n    if not t:\n        return \"\"\n    if not t.left and not t.right:\n        return str(t.val)\n    if not t.right:\n        return \"{}({})\".format(t.val, tree2str(t.left))\n    return \"{}({})({})\".format(t.val, tree2str(t.left), tree2str(t.right))", "from collections import defaultdict\n\ndef find_duplicate(paths):\n    content_map = defaultdict(list)\n    for path in paths:\n        parts = path.split()\n        directory = parts[0]\n        for file in parts[1:]:\n            start = file.index('(')\n            end = file.index(')')\n            content = file[start + 1:end]\n            file_path = directory + '/' + file[:start]\n            content_map[content].append(file_path)\n\n    result = [file_paths for file_paths in content_map.values() if len(file_paths) > 1]\n    return result", "def triangleNumber(nums: list) -> int:\n    nums.sort()\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if nums[i] + nums[j] > nums[k]:\n                    count += 1\n                else:\n                    break\n    return count", "def addBoldTag(s: str, words: list) -> str:\n    n = len(s)\n    marked = [False] * n\n    for word in words:\n        pos = s.find(word)\n        while pos != -1:\n            for i in range(pos, pos + len(word)):\n                marked[i] = True\n            pos = s.find(word, pos + 1)\n    result = []\n    i = 0\n    while i < n:\n        if marked[i]:\n            result.append(\"<b>\")\n            while i < n and marked[i]:\n                result.append(s[i])\n                i += 1\n            result.append(\"</b>\")\n        else:\n            result.append(s[i])\n            i += 1\n    return \"\".join(result)", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef merge_trees(root1: TreeNode, root2: TreeNode) -> TreeNode:\n    if root1 is None: return root2\n    if root2 is None: return root1\n\n    root1.val += root2.val\n    root1.left = merge_trees(root1.left, root2.left)\n    root1.right = merge_trees(root1.right, root2.right)\n    return root1", "from collections import Counter\n\ndef least_interval(tasks, n):\n    task_freq = Counter(tasks)\n\n    max_f = max(task_freq.values())\n    max_count = sum(1 for count in task_freq.values() if count == max_f)\n\n    return max(len(tasks), (max_f - 1) * (n + 1) + max_count)", "class MyCircularQueue:\n\n    def __init__(self, k: int):\n        self.size = k\n        self.data = [0]*k\n        self.front = -1\n        self.rear = -1\n\n    def enQueue(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        if self.isEmpty():\n            self.front = 0\n        self.rear = (self.rear + 1) % self.size\n        self.data[self.rear] = value\n        return True\n\n    def deQueue(self) -> bool:\n        if self.isEmpty():\n            return False\n        if self.front == self.rear:\n            self.front = -1\n            self.rear = -1\n        else:\n            self.front = (self.front + 1) % self.size\n        return True\n\n    def Front(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.data[self.front]\n\n    def Rear(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.data[self.rear]\n\n    def isEmpty(self) -> bool:\n        return self.front == -1\n\n    def isFull(self) -> bool:\n        return (self.rear + 1) % self.size == self.front", "def add_one_row_helper(node, val, depth, current_depth):\n    if not node:\n        return\n    if current_depth == depth - 1:\n        left = node.left\n        right = node.right\n        node.left = TreeNode(val)\n        node.left.left = left\n        node.right = TreeNode(val)\n        node.right.right = right\n    else:\n        add_one_row_helper(node.left, val, depth, current_depth + 1)\n        add_one_row_helper(node.right, val, depth, current_depth + 1)\n        \ndef add_one_row(root, val, depth):\n    if depth == 1:\n        new_root = TreeNode(val)\n        new_root.left = root\n        return new_root\n    add_one_row_helper(root, val, depth, 1)\n    return root", "def maxDistance(arrays: List[List[int]]) -> int:\n    max_dist = 0\n    min_val = arrays[0][0]\n    max_val = arrays[0][-1]\n    \n    for arr in arrays[1:]:\n        max_dist = max(max_dist, max(abs(arr[-1] - min_val), abs(max_val - arr[0])))\n        min_val = min(min_val, arr[0])\n        max_val = max(max_val, arr[-1])\n        \n    return max_dist", "def smallestFactorization(num: int) -> int:\n    if num == 1:\n        return 1\n    result = 0\n    factor = 1\n    for i in range(9, 1, -1):\n        while num % i == 0:\n            num //= i\n            result += i * factor\n            factor *= 10\n            if result > 2**31 - 1:\n                return 0\n    return result if num == 1 else 0", "def maximumProduct(nums):\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])", "def kInversePairs(n: int, k: int) -> int:\n    mod = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][0] = 1\n        for j in range(1, k + 1):\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod\n            if j - i >= 0:\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod\n    return dp[n][k]", "import heapq\n\ndef scheduleCourse(courses):\n    courses.sort(key=lambda x: x[1])\n    curr_time, duration_sum = 0, []\n\n    for duration, deadline in courses:\n        curr_time += duration\n        heapq.heappush(duration_sum, -duration)\n\n        if curr_time > deadline:\n            curr_time += heapq.heappop(duration_sum)\n\n    return len(duration_sum)", "class Excel:\n\n    def __init__(self, height: int, width: str):\n        self.mat = [[0] * (ord(width) - ord('A') + 1) for _ in range(height)]\n        self.formulas = {}\n\n    def set(self, row: int, column: str, val: int) -> None:\n        pos = column + str(row)\n        if pos in self.formulas:\n            del self.formulas[pos]\n        self.mat[row - 1][ord(column) - ord('A')] = val\n\n    def get(self, row: int, column: str) -> int:\n        pos = column + str(row)\n        if pos in self.formulas:\n            return self.sum(row, column, self.formulas[pos])\n        return self.mat[row - 1][ord(column) - ord('A')]\n\n    def sum(self, row: int, column: str, numbers) -> int:\n        total = 0\n        for num in numbers:\n            if ':' in num:\n                start, end = num.split(':')\n                start_row, end_row = int(start[1:]), int(end[1:])\n                start_col, end_col = start[0], end[0]\n                for r in range(start_row, end_row + 1):\n                    for c in range(ord(start_col), ord(end_col) + 1):\n                        total += self.get(r, chr(c))\n            else:\n                total += self.get(int(num[1:]), num[0])\n        self.set(row, column, total)\n        self.formulas[column + str(row)] = numbers\n        return total", "import heapq\n\ndef smallestRange(nums):\n    minHeap = []\n    maxVal = -1e9\n    \n    for i, lst in enumerate(nums):\n        heapq.heappush(minHeap, (lst[0], i))\n        maxVal = max(maxVal, lst[0])\n        \n    listIndices = [0] * len(nums)\n    minRange = 1e9\n    start, end = -1, -1\n    \n    while len(minHeap) == len(nums):\n        val, listIdx = heapq.heappop(minHeap)\n        range_ = maxVal - val\n        \n        if range_ < minRange:\n            minRange = range_\n            start, end = val, maxVal\n            \n        listIndices[listIdx] += 1\n        if listIndices[listIdx] < len(nums[listIdx]):\n            newVal = nums[listIdx][listIndices[listIdx]]\n            heapq.heappush(minHeap, (newVal, listIdx))\n            maxVal = max(maxVal, newVal)\n            \n    return [start, end]", "def judge_square_sum(c):\n    for a in range(int(c ** 0.5) + 1):\n        b = int((c - a * a) ** 0.5)\n        if a * a + b * b == c:\n            return True\n    return False", "def findDerangement(n: int) -> int:\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[2] = 1\n    for i in range(3, n + 1):\n        dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]", "class LogSystem:\n\n    def __init__(self):\n        self.logs = {}\n        self.time_granularity = {\n            \"Year\": 0, \"Month\": 1, \"Day\": 2, \"Hour\": 3, \"Minute\": 4, \"Second\": 5\n        }\n        self.size_map = [4, 7, 10, 13, 16, 19]\n\n    def put(self, id: int, timestamp: str) -> None:\n        self.logs[timestamp] = id\n\n    def retrieve(self, start: str, end: str, granularity: str) -> list[int]:\n        size_substring = self.size_map[self.time_granularity[granularity]]\n        res = []\n\n        for k, v in self.logs.items():\n            if start[:size_substring] <= k[:size_substring] <= end[:size_substring]:\n                res.append(v)\n\n        return res", "def exclusiveTime(n, logs):\n    res = [0] * n\n    stack = []\n    prev_time = 0\n\n    for log in logs:\n        parts = log.split(':')\n        id = int(parts[0])\n        type = parts[1]\n        time = int(parts[2])\n\n        if type == \"start\":\n            if stack:\n                res[stack[-1]] += time - prev_time\n            stack.append(id)\n            prev_time = time\n        else:\n            res[stack.pop()] += time - prev_time + 1\n            prev_time = time + 1\n\n    return res", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef averageOfLevels(root: TreeNode):\n    result = []\n    queue = [root]\n\n    while queue:\n        sum_ = 0\n        count = 0\n        temp = []\n        while queue:\n            node = queue.pop(0)\n            sum_ += node.val\n            count += 1\n            if node.left: temp.append(node.left)\n            if node.right: temp.append(node.right)\n        queue = temp\n        result.append(sum_ / count)\n\n    return result", "from typing import List\n\ndef shoppingOffers(price: List[int], special: List[List[int]], needs: List[int]) -> int:\n    def helper(index):\n        if index == len(special):\n            return sum(needs[i] * price[i] for i in range(len(needs)))\n\n        no_offer = helper(index + 1)\n        can_apply_offer = True\n        for i in range(len(needs)):\n            needs[i] -= special[index][i]\n            if needs[i] < 0:\n                can_apply_offer = False\n\n        with_offer = float('inf')\n        if can_apply_offer:\n            offer_cost = special[index][-1] + helper(index)\n            with_offer = min(no_offer, offer_cost)\n\n        for i in range(len(needs)):\n            needs[i] += special[index][i]\n        \n        return with_offer if can_apply_offer else no_offer\n\n    return helper(0)", "def num_decodings(s: str) -> int:\n    MOD = 10**9 + 7\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 9 if s[0] == '*' else (0 if s[0] == '0' else 1)\n\n    for i in range(2, n + 1):\n        c, prev_c = s[i - 1], s[i - 2]\n        \n        if c == '*':\n            dp[i] = 9 * dp[i - 1]\n            if prev_c == '1': dp[i] += 9 * dp[i - 2]\n            elif prev_c == '2': dp[i] += 6 * dp[i - 2]\n            elif prev_c == '*': dp[i] += 15 * dp[i - 2]\n        else:\n            dp[i] = dp[i - 1] if c != '0' else 0\n            num = int(s[i - 2 : i])\n            if prev_c == '1' or (prev_c == '2' and num <= 26): dp[i] += dp[i - 2]\n            elif prev_c == '*': dp[i] += 2 * dp[i - 2] if 10 <= num <= 26 else dp[i - 2]\n\n        dp[i] %= MOD\n    return dp[n]", "def solve_equation(equation: str) -> str:\n    coef = val = left = operate = 0\n    equation += '+'\n    parts = [s.strip()+c for c in equation if c in '+-' for s in equation.split(c)]\n    for part in parts:\n        if part == '=':\n            left = -1\n            operate = 1\n        else:\n            n, x = part.split('x')\n            value_to_change = 1 if n else int(n)\n            if x:\n                coef += (1 if part[0] == '+' else -1) * left * operate * value_to_change\n            else:\n                val += (1 if part[0] == '+' else -1) * left * operate * value_to_change\n            operate = 1 - x.find('x')\n\n    if coef == 0:\n        return \"Infinite solutions\" if val == 0 else \"No solution\"\n    return \"x=\" + str(-val // coef)", "class MyCircularDeque:\n\n    def __init__(self, k: int):\n        self.buffer = [0] * k\n        self.front = -1\n        self.rear = 0\n        self.capacity = k\n\n    def insertFront(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        if self.front == -1:\n            self.front = 0\n        else:\n            self.front = (self.front - 1 + self.capacity) % self.capacity\n        self.buffer[self.front] = value\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        self.buffer[self.rear] = value\n        self.rear = (self.rear + 1) % self.capacity\n        if self.front == -1:\n            self.front = 0\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.isEmpty():\n            return False\n        if self.front == self.rear - 1:\n            self.front = -1\n        else:\n            self.front = (self.front + 1) % self.capacity\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.isEmpty():\n            return False\n        if self.front == self.rear - 1:\n            self.rear = 0\n            self.front = -1\n        else:\n            self.rear = (self.rear - 1 + self.capacity) % self.capacity\n        return True\n\n    def getFront(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.buffer[self.front]\n\n    def getRear(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.buffer[(self.rear - 1 + self.capacity) % self.capacity]\n\n    def isEmpty(self) -> bool:\n        return self.front == -1\n\n    def isFull(self) -> bool:\n        return self.front == self.rear", "from typing import List\nimport heapq\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.sentence = \"\"\n        self.times = 0\n\nclass AutocompleteSystem:\n\n    def __init__(self, sentences: List[str], times: List[int]):\n        self.root = TrieNode()\n        self.current = self.root\n        self.search = \"\"\n        \n        for i in range(len(sentences)):\n            self.insert(sentences[i], times[i])\n\n    def insert(self, sentence: str, times: int):\n        curr = self.root\n        for c in sentence:\n            if c not in curr.children:\n                curr.children[c] = TrieNode()\n            curr = curr.children[c]\n        curr.sentence = sentence\n        curr.times += times\n\n    def input(self, c: str) -> List[str]:\n        if c == '#':\n            self.insert(self.search, 1)\n            self.search = \"\"\n            self.current = self.root\n            return []\n        \n        self.search += c\n        if not self.current:\n            return []\n        \n        if c not in self.current.children:\n            self.current = None\n            return []\n        \n        self.current = self.current.children[c]\n        heap = []\n        for child in self.current.children.values():\n            if child.times:\n                heapq.heappush(heap, (-child.times, child.sentence))\n        \n        res = []\n        for _ in range(3):\n            if not heap:\n                break\n            res.append(heapq.heappop(heap)[1])\n        return res", "def findMaxAverage(nums, k):\n    n = len(nums)\n    sum_ = sum(nums[:k])\n    max_avg = sum_ / k\n    for i in range(k, n):\n        sum_ = sum_ - nums[i - k] + nums[i]\n        max_avg = max(max_avg, sum_ / k)\n    return max_avg", "def findMaxAverage(nums, k):\n    total = sum(nums[:k])\n    max_avg = total / k\n    for i in range(k, len(nums)):\n        total += nums[i] - nums[i - k]\n        max_avg = max(max_avg, total / k)\n    return max_avg", "def findErrorNums(nums):\n    result = []\n    for num in nums:\n        index = abs(num) - 1\n        if nums[index] > 0:\n            nums[index] = -nums[index]\n        else:\n            result.append(index + 1)\n    for i, num in enumerate(nums):\n        if num > 0:\n            result.append(i + 1)\n            break\n    return result", "def findLongestChain(pairs):\n    pairs.sort(key=lambda x: x[1])\n\n    max_chain_length = 0\n    last_right = float('-inf')\n    for pair in pairs:\n        if pair[0] > last_right:\n            last_right = pair[1]\n            max_chain_length += 1\n\n    return max_chain_length", "def countSubstrings(s: str) -> int:\n    n = len(s)\n    count = 0\n    for center in range(2 * n - 1):\n        left = center // 2\n        right = left + center % 2\n        while left >= 0 and right < n and s[left] == s[right]:\n            count += 1\n            left -= 1\n            right += 1\n    return count", "def replaceWords(dict, sentence):\n    roots = set(dict)\n    words = sentence.split()\n    result = []\n\n    for word in words:\n        prefix = ''\n        for i in range(1, len(word) + 1):\n            prefix = word[:i]\n            if prefix in roots:\n                break\n        result.append(prefix)\n\n    return ' '.join(result)", "from collections import deque\n\ndef predict_party_victory(senate: str) -> str:\n    radiant = deque()\n    dire = deque()\n    n = len(senate)\n    \n    for i, s in enumerate(senate):\n        if s == 'R':\n            radiant.append(i)\n        else:\n            dire.append(i)\n\n    while radiant and dire:\n        r = radiant.popleft()\n        d = dire.popleft()\n\n        if r < d:\n            radiant.append(r + n)\n        else:\n            dire.append(d + n)\n\n    return \"Dire\" if not radiant else \"Radiant\"", "def min_steps(n):\n    result = 0\n    i = 2\n    while i <= n:\n        while n % i == 0:\n            result += i\n            n //= i\n        i += 1\n    return result", "def maxA(n: int) -> int:\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = i\n        for j in range(1, i - 2):\n            dp[i] = max(dp[i], dp[j] * (i - j - 1))\n    return dp[n]", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef findDuplicateSubtrees(root):\n    tree_count = {}\n    result = []\n    findDuplicateSubtreesHelper(root, tree_count, result)\n    return result\n\ndef findDuplicateSubtreesHelper(root, tree_count, result):\n    if root is None:\n        return \"\"\n    subtree = \"{},{},{}\".format(root.val, findDuplicateSubtreesHelper(root.left, tree_count, result), findDuplicateSubtreesHelper(root.right, tree_count, result))\n    tree_count[subtree] = tree_count.get(subtree, 0) + 1\n    if tree_count[subtree] == 2:\n        result.append(root)\n    return subtree", "def findTarget(root, k):\n    nodes = set()\n    return findNode(root, k, nodes)\n\ndef findNode(root, k, nodes):\n    if not root:\n        return False\n    if k - root.val in nodes:\n        return True\n    nodes.add(root.val)\n    return findNode(root.left, k, nodes) or findNode(root.right, k, nodes)", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef constructMaximumBinaryTree(nums):\n    def helper(nums, left, right):\n        if left > right:\n            return None\n\n        maxIdx = left\n        for i in range(left + 1, right + 1):\n            if nums[i] > nums[maxIdx]:\n                maxIdx = i\n\n        root = TreeNode(nums[maxIdx])\n        root.left = helper(nums, left, maxIdx - 1)\n        root.right = helper(nums, maxIdx + 1, right)\n        return root\n\n    return helper(nums, 0, len(nums) - 1)", "from collections import deque\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n        \ndef printTree(root):\n    if not root:\n        return [[]]\n\n    # Calculate Depth\n    depth = 0\n    q = deque([root])\n    while q:\n        depth += 1\n        for _ in range(len(q)):\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    res = [[\"\" for _ in range((1 << depth) - 1)] for _ in range(depth)]\n\n    # Fill in matrix\n    q.append(root)\n    level = 0\n    step = (1 << (depth - 1))\n    while q:\n        cur_pos = step - 1\n        for _ in range(len(q)):\n            node = q.popleft()\n            res[level][cur_pos] = str(node.val)\n            cur_pos += (step << 1)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n        step >>= 1\n        level += 1\n\n    return res", "def cheapestJump(coins, maxJump):\n    n = len(coins)\n    dp = [float('inf')] * n\n    parent = [-1] * n\n    dp[0] = coins[0]\n    for i in range(n):\n        if coins[i] == -1:\n            continue\n        for j in range(1, maxJump + 1):\n            if i + j >= n:\n                break\n            next = i + j\n            cost = coins[next] + dp[i]\n            if cost < dp[next]:\n                dp[next] = cost\n                parent[next] = i\n    ans = []\n    if dp[n - 1] == float('inf'):\n        return ans\n    cur = n - 1\n    while cur != -1:\n        ans.append(cur + 1)\n        cur = parent[cur]\n    ans.reverse()\n    return ans", "def judgeCircle(moves: str) -> bool:\n    x, y = 0, 0\n    for move in moves:\n        if move == 'U': y += 1\n        elif move == 'D': y -= 1\n        elif move == 'R': x += 1\n        elif move == 'L': x -= 1\n    return x == 0 and y == 0", "from typing import List\n\ndef findClosestElements(arr: List[int], k: int, x: int) -> List[int]:\n    left = 0\n    right = len(arr) - k\n\n    while left < right:\n        mid = left + (right - left) // 2\n        if x - arr[mid] > arr[mid + k] - x:\n            left = mid + 1\n        else:\n            right = mid\n\n    return arr[left:left + k]", "def can_split(nums):\n    freq = [0] * 20001\n    needed = [0] * 20001\n    for n in nums:\n        freq[n] += 1\n    for n in nums:\n        if not freq[n]: continue\n        if not needed[n - 1]:\n            if freq[n + 1] and freq[n + 2]:\n                freq[n] -= 1; freq[n + 1] -= 1; freq[n + 2] -= 1;\n                needed[n + 2] += 1\n            else: return False\n        else:\n            freq[n] -= 1; needed[n - 1] -= 1;\n            needed[n] += 1\n    return True", "def newInteger(n):\n    result = 0\n    base = 1\n    while n:\n        result += n % 9 * base\n        n //= 9\n        base *= 10\n    return result", "def imageSmoother(img):\n    m, n = len(img), len(img[0])\n    result = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            count, total = 0, 0\n            for x in range(i - 1, i + 2):\n                for y in range(j - 1, j + 2):\n                    if 0 <= x < m and 0 <= y < n:\n                        total += img[x][y]\n                        count += 1\n            result[i][j] = total // count\n\n    return result", "from collections import deque\n\ndef widthOfBinaryTree(root):\n    if not root:\n        return 0\n\n    maxWidth = 0\n    q = deque([(root, 1)])\n\n    while q:\n        levelSize = len(q)\n        left, _ = q[0]\n        right = left\n        for _ in range(levelSize):\n            node, pos = q.popleft()\n            right = pos\n\n            if node.left:\n                q.append((node.left, 2 * pos))\n            if node.right:\n                q.append((node.right, 2 * pos + 1))\n        \n        maxWidth = max(maxWidth, right - left + 1)\n    \n    return maxWidth", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def checkEqualTree(self, root: TreeNode) -> bool:\n        def _sum(node, seen):\n            if not node:\n                return 0\n            s = node.val + _sum(node.left, seen) + _sum(node.right, seen)\n            seen.add(s)\n            return s\n\n        seen = set()\n        total = _sum(root, seen)\n        return total % 2 == 0 and (total // 2) in seen", "def strange_printer(s: str) -> int:\n    n = len(s)\n    if n == 0: return 0\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for len in range(1, n):\n        for i in range(n - len):\n            j = i + len\n            dp[i][j] = dp[i+1][j] + 1\n            for k in range(i + 1, j + 1):\n                if s[i] == s[k]:\n                    dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k][j])\n    return dp[0][n-1]", "def checkPossibility(nums):\n    cnt = 0\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i - 1]:\n            cnt += 1\n            if i == 1 or nums[i] >= nums[i - 2]:\n                nums[i-1] = nums[i]\n            else:\n                nums[i] = nums[i - 1]\n            if cnt > 1:\n                return False\n    return True", "def sumPaths(root, val):\n    if not root: return 0\n    val = val * 10 + root.val\n    if not root.left and not root.right: return val\n    return sumPaths(root.left, val) + sumPaths(root.right, val)\n\ndef pathSum(nums):\n    root = TreeNode(nums[0] % 10)\n    for num in nums:\n        depth, pos, val = num // 100, num % 100 // 10, num % 10\n        cur = root\n        for d in reversed(range(depth - 1)):\n            if (pos >> d) & 1:\n                if not cur.right: cur.right = TreeNode(val)\n                cur = cur.right\n            else:\n                if not cur.left: cur.left = TreeNode(val)\n                cur = cur.left\n    return sumPaths(root, 0)", "def constructArray(n: int, k: int) -> List[int]:\n    answer = [0] * n\n    for i in range(n):\n        if i % 2 == 0:\n            answer[i] = i // 2 + 1\n        else:\n            answer[i] = n - (i - 1) // 2\n            k -= 1\n    if k > 0:\n        for i in range(n - 2, -1, -1):\n            if k > 0:\n                answer[i] = answer[i + 1] - answer[i]\n                k -= 1\n    return answer", "def findKthNumber(m, n, k):\n    low, high = 1, m * n\n    while low < high:\n        mid = low + (high - low) // 2\n        count = 0\n        for i in range(1, m+1):\n            count += min(mid // i, n)\n        if count < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef trimBST(self, root: TreeNode, low: int, high: int) -> TreeNode:\n    if not root:\n        return None\n\n    if root.val < low:\n        return self.trimBST(root.right, low, high)\n    elif root.val > high:\n        return self.trimBST(root.left, low, high)\n    else:\n        root.left = self.trimBST(root.left, low, high)\n        root.right = self.trimBST(root.right, low, high)\n\n    return root", "def maximumSwap(num):\n    num_str = list(str(num))\n    last = {int(v): i for i, v in enumerate(num_str)}\n\n    for i, v in enumerate(num_str):\n        for d in range(9, int(v), -1):\n            if last.get(d, -1) > i:\n                num_str[i], num_str[last[d]] = num_str[last[d]], num_str[i]\n                return int(\"\".join(num_str))\n\n    return num", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef find_second_minimum_value(root, current=-1):\n    if root is None:\n        return current\n    if current == -1 or root.val < current:\n        current = root.val\n    if root.left is not None and root.right is not None:\n        if root.val == root.left.val:\n            current = find_second_minimum_value(root.left, current)\n            if root.val != root.right.val:\n                current = root.right.val if current == -1 else min(current, root.right.val)\n        else:\n            current = find_second_minimum_value(root.right, current)\n            if root.val != root.left.val:\n                current = root.left.val if current == -1 else min(current, root.left.val)\n    return current", "def num_light_configuration(n, presses):\n    dp = [[0] * (presses + 1) for _ in range(n+1)]\n    dp[0][0] = 1\n\n    for i in range(n + 1):\n        for j in range(1, presses + 1):\n            dp[i][j] = dp[i][j - 1] * (i + 1) + (dp[i - 1][j - 1] if i > 0 else 0)\n\n    return dp[n][presses]", "def findNumberOfLIS(nums):\n    n = len(nums)\n    maxLength = ans = 0\n    length = [1] * n\n    count = [1] * n\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                if length[i] == length[j] + 1:\n                    count[i] += count[j]\n                elif length[i] < length[j] + 1:\n                    length[i] = length[j] + 1\n                    count[i] = count[j]\n        if maxLength == length[i]:\n            ans += count[i]\n        elif maxLength < length[i]:\n            maxLength = length[i]\n            ans = count[i]\n\n    return ans", "def findLengthOfLCIS(nums):\n    if not nums:\n        return 0\n    result, current = 1, 1\n    for i in range(1, len(nums)):\n        current = current + 1 if nums[i] > nums[i - 1] else 1\n        result = max(result, current)\n    return result", "from heapq import heappush, heappop\nfrom collections import deque\n\ndef cutOffTree(forest: List[List[int]]) -> int:\n    if not forest or not forest[0]: return 0\n    m, n = len(forest), len(forest[0])\n    trees = []\n    \n    for i in range(m):\n        for j in range(n):\n            if forest[i][j] > 1:\n                heappush(trees, (forest[i][j], i, j))\n    \n    startX, startY = 0, 0\n    totalSteps = 0\n    while trees:\n        tree, endX, endY = heappop(trees)\n        steps = bfs(forest, startX, startY, endX, endY)\n        if steps == -1:\n            return -1\n        totalSteps += steps\n        startX, startY = endX, endY\n    \n    return totalSteps\n\ndef bfs(forest, startX, startY, endX, endY):\n    if startX == endX and startY == endY:\n        return 0\n        \n    m, n = len(forest), len(forest[0])\n    visited = [[False] * n for _ in range(m)]\n    q = deque([(startX, startY, 0)])\n    visited[startX][startY] = True\n    dirs = [-1, 0, 1, 0, -1]\n    \n    while q:\n        x, y, steps = q.popleft()\n        for k in range(4):\n            newX, newY = x + dirs[k], y + dirs[k+1]\n            if 0 <= newX < m and 0 <= newY < n and not visited[newX][newY] and forest[newX][newY] != 0:\n                if newX == endX and newY == endY:\n                    return steps + 1\n                q.append((newX, newY, steps + 1))\n                visited[newX][newY] = True\n    \n    return -1", "class MagicDictionary:\n\n    def __init__(self):\n        self.word_list = {}\n\n    def buildDict(self, dictionary: List[str]) -> None:\n        for word in dictionary:\n            if len(word) not in self.word_list:\n                self.word_list[len(word)] = []\n            self.word_list[len(word)].append(word)\n\n    def search(self, searchWord: str) -> bool:\n        if len(searchWord) in self.word_list:\n            for word in self.word_list[len(searchWord)]:\n                diff = sum(c1 != c2 for c1, c2 in zip(searchWord, word))\n                if diff == 1: return True\n        return False", "class MapSum:\n    def __init__(self):\n        self.map = {}\n\n    def insert(self, key: str, val: int) -> None:\n        self.map[key] = val\n\n    def sum(self, prefix: str) -> int:\n        total = 0\n        for key, value in self.map.items():\n            if key.startswith(prefix):\n                total += value\n        return total", "def checkValidString(s: str) -> bool:\n    left_balance, right_balance = 0, 0\n\n    for i in range(len(s)):\n        left_balance += 1 if s[i] == '(' or s[i] == '*' else -1\n        right_balance += 1 if s[len(s) - 1 - i] == ')' or s[len(s) - 1 - i] == '*' else -1\n\n        if left_balance < 0 or right_balance < 0:\n            return False\n\n    return True", "from itertools import permutations\n\ndef helper(cards, target=24):\n    if len(cards) == 1:\n        return abs(cards[0] - target) < 1e-6\n\n    for i in range(len(cards)):\n        for j in range(i + 1, len(cards)):\n            a, b = cards[i], cards[j]\n            rest = [cards[k] for k in range(len(cards)) if k != i and k != j]\n            for e in a + b, a - b, a * b, a / b:\n                if helper(rest + [e]):\n                    return True\n    return False\n\ndef canGet24(cards):\n    return helper(cards)", "def validPalindrome(s: str) -> bool:\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            temp1, temp2 = i + 1, j\n            while temp1 < temp2 and s[temp1] == s[temp2]:\n                temp1 += 1\n                temp2 -= 1\n            if temp1 >= temp2:\n                return True\n\n            temp1, temp2 = i, j - 1\n            while temp1 < temp2 and s[temp1] == s[temp2]:\n                temp1 += 1\n                temp2 -= 1\n            if temp1 >= temp2:\n                return True\n\n            return False\n        i += 1\n        j -= 1\n    return True", "def nextClosestTime(time: str) -> str:\n    digits = time[:2] + time[3:]\n    next_time = time\n    elapsed = float('inf')\n\n    for a in digits:\n        for b in digits:\n            for c in digits:\n                for d in digits:\n                    candidate_time = f\"{a}{b}:{c}{d}\"\n                    cand_elapsed = (int(candidate_time[:2]) * 60 + int(candidate_time[3:]) -\n                                    int(time[:2]) * 60 - int(time[3:]) + 1440) % 1440\n                    if 0 < cand_elapsed < elapsed:\n                        elapsed = cand_elapsed\n                        next_time = candidate_time\n\n    return next_time", "def calPoints(ops):\n    record = []\n    for op in ops:\n        if op == '+':\n            record.append(record[-1] + record[-2])\n        elif op == 'D':\n            record.append(record[-1] * 2)\n        elif op == 'C':\n            record.pop()\n        else:\n            record.append(int(op))\n    return sum(record)", "def kEmptySlots(bulbs, k):\n    days = [0] * len(bulbs)\n    for i, bulb in enumerate(bulbs):\n        days[bulb - 1] = i\n\n    ans = float('inf')\n    left = 0\n    right = k + 1\n    while right < len(days):\n        i = left + 1\n        for i in range(left + 1, right):\n            if days[i] < days[left] or days[i] < days[right]:\n                left = i\n                break\n        else:\n            ans = min(ans, max(days[left], days[right]))\n            left += 1\n            right += 1\n\n    return -1 if ans == float('inf') else ans + 1", "from typing import List\n\ndef findRedundantConnection(edges: List[List[int]]) -> List[int]:\n    def find(parent, x):\n        if parent[x] != x:\n            parent[x] = find(parent, parent[x])\n        return parent[x]\n\n    parent = list(range(len(edges) + 1))\n    for edge in edges:\n        root1 = find(parent, edge[0])\n        root2 = find(parent, edge[1])\n        if root1 == root2:\n            return edge\n        parent[root1] = root2\n    return []", "def findRedundantDirectedConnection(edges):\n    parent = [0] * (len(edges) + 1)\n    candidateA = candidateB = None\n\n    for u, v in edges:\n        if parent[v] > 0:\n            candidateA = [parent[v], v]\n            candidateB = [u, v]\n        else:\n            parent[v] = u\n\n    for i in range(1, len(edges) + 1):\n        cycle = i\n        steps = len(edges)\n        while parent[cycle] != 0 and steps > 0:\n            cycle = parent[cycle]\n            steps -= 1\n        if steps == 0:\n            if not candidateA:\n                return [parent[i], i]\n            else:\n                return candidateA\n\n    return candidateB", "def min_repeats_to_substring(a: str, b: str) -> int:\n    times = (len(b) + len(a) - 1) // len(a)\n\n    for i in range(2):\n        repeated_a = a * (times + i)\n        if b in repeated_a:\n            return times + i\n\n    return -1", "def longestUnivaluePath(root):\n    def findUnivaluePath(node):\n        if not node:\n            return 0\n        left = findUnivaluePath(node.left)\n        right = findUnivaluePath(node.right)\n        left = left + 1 if node.left and node.left.val == node.val else 0\n        right = right + 1 if node.right and node.right.val == node.val else 0\n        maxLen[0] = max(maxLen[0], left + right)\n        return max(left, right)\n\n    maxLen = [0]\n    findUnivaluePath(root)\n    return maxLen[0]", "def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n    memo = [[[-1.0 for _ in range(k + 1)] for _ in range(n)] for _ in range(n)]\n    return self.helper(n, k, row, column, memo)\n\ndef helper(self, n, k, row, column, memo):\n    if row < 0 or row >= n or column < 0 or column >= n:\n        return 0.0\n    if k == 0:\n        return 1.0\n    if memo[row][column][k] >= 0:\n        return memo[row][column][k]\n\n    result = 0.0\n    moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    for move in moves:\n        result += self.helper(n, k - 1, row + move[0], column + move[1], memo) / 8\n\n    memo[row][column][k] = result\n    return result", "def max_sum_of_three_subarrays(nums, k):\n    n = len(nums)\n    sums = [0] * (n - k + 1)\n    left, right = [0] * n, [0] * n\n\n    acc_sum = 0\n    for i in range(n):\n        acc_sum += nums[i]\n        if i >= k:\n            acc_sum -= nums[i - k]\n        if i >= k - 1:\n            sums[i - k + 1] = acc_sum\n\n    left[0] = 0\n    right[n - k] = n - k\n    for i in range(1, n - k + 1):\n        left[i] = i if sums[i] > sums[left[i - 1]] else left[i - 1]\n\n    for i in range(n - k - 1, -1, -1):\n        right[i] = i if sums[i] >= sums[right[i + 1]] else right[i + 1]\n\n    max_sum, ans = 0, [0] * 3\n    for i in range(k, n - 2 * k + 1):\n        left_idx, right_idx = left[i - k], right[i + k]\n        total_sum = sums[left_idx] + sums[i] + sums[right_idx]\n        if total_sum > max_sum:\n            max_sum = total_sum\n            ans = [left_idx, i, right_idx]\n\n    return ans", "class Employee:\n    def __init__(self, id: int, importance: int, subordinates: list):\n        self.id = id\n        self.importance = importance\n        self.subordinates = subordinates\n\ndef getTotalImportance(employees, id):\n    emap = {emp.id: emp for emp in employees}\n    return dfs(emap, id)\n\ndef dfs(emap, id):\n    emp = emap[id]\n    return emp.importance + sum(dfs(emap, sub_id) for sub_id in emp.subordinates)", "from collections import Counter\nfrom functools import lru_cache\n\ndef minStickers(stickers, target):\n    target_count = Counter(target)\n    memo = {}\n    \n    for s in stickers:\n        sticker_count = Counter(s)\n        state = ''.join(sticker_count & target_count)\n        memo[state] = 1\n    \n    @lru_cache(None)\n    def dp(state):\n        counts = Counter(state)\n        ans = float('inf')\n        for key, value in memo.items():\n            if any(counts[ch] < key.count(ch) for ch in state): continue\n            ans = min(ans, dp(state.translate(str.maketrans('', '', key))) + value)\n        return -1 if ans == float('inf') else ans\n    \n    return dp(target)", "import heapq\nfrom collections import Counter\n\ndef k_frequent_words(words, k):\n    word_count = Counter(words)\n    heap = [(-count, word) for word, count in word_count.items()]\n    heapq.heapify(heap)\n\n    result = []\n    for _ in range(k):\n        result.append(heapq.heappop(heap)[1])\n\n    return result", "def has_alternating_bits(n):\n    prev_bit = n % 2\n    n //= 2\n    while n > 0:\n        curr_bit = n % 2\n        if curr_bit == prev_bit:\n            return False\n        prev_bit = curr_bit\n        n //= 2\n    return True", "def numDistinctIslands(grid):\n    unique_islands = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                island_shape = []\n                dfs(grid, i, j, i, j, island_shape)\n                island_shape.sort()\n                unique_islands.add(tuple(island_shape))\n    return len(unique_islands)\n\ndef dfs(grid, i, j, i0, j0, shape):\n    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1:\n        grid[i][j] = 2\n        shape.append((i - i0, j - j0))\n        dfs(grid, i - 1, j, i0, j0, shape)\n        dfs(grid, i + 1, j, i0, j0, shape)\n        dfs(grid, i, j - 1, i0, j0, shape)\n        dfs(grid, i, j + 1, i0, j0, shape)", "def maxAreaOfIsland(grid):\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:\n            return 0\n        grid[i][j] = 0\n        return 1 + dfs(i-1, j) + dfs(i+1, j) + dfs(i, j-1) + dfs(i, j+1)\n\n    max_area = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j]:\n                max_area = max(max_area, dfs(i, j))\n    return max_area", "def count_binary_substrings(s: str) -> int:\n    prev, curr, result = 0, 1, 0\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            curr += 1\n        else:\n            result += min(prev, curr)\n            prev, curr = curr, 1\n    return result + min(prev, curr)", "def findShortestSubArray(nums):\n    freq_map, start_map = {}, {}\n    max_freq, min_length = 0, len(nums)\n\n    for i, num in enumerate(nums):\n        if num not in start_map:\n            start_map[num] = i\n        freq_map[num] = freq_map.get(num, 0) + 1\n\n        freq = freq_map[num]\n        if freq > max_freq:\n            max_freq = freq\n            min_length = i - start_map[num] + 1\n        elif freq == max_freq:\n            min_length = min(min_length, i - start_map[num] + 1)\n\n    return min_length", "def canPartitionKSubsets(nums, k):\n    total_sum = sum(nums)\n    if total_sum % k != 0:\n        return False\n    target = total_sum // k\n    visited = [False] * len(nums)\n    return dfs(nums, visited, 0, target, 0, k)\n\ndef dfs(nums, visited, start, target, curr_sum, k):\n    if k == 1:\n        return True\n    if curr_sum == target:\n        return dfs(nums, visited, 0, target, 0, k - 1)\n    for i in range(start, len(nums)):\n        if not visited[i] and curr_sum + nums[i] <= target:\n            visited[i] = True\n            if dfs(nums, visited, i + 1, target, curr_sum + nums[i], k):\n                return True\n            visited[i] = False\n    return False", "def fallingSquares(positions):\n    ans = []\n    intervals = []\n\n    for p in positions:\n        L, size = p\n        R = L + size\n        h = size\n        for h2, R2 in intervals:\n            if R2 > L and R > R2:\n                h = max(h, size + h2)\n\n        maxHeight = max((h2 for h2, R2 in intervals), default=0)\n        ans.append(max(maxHeight, h))\n        intervals.append((h, R))\n\n    return ans", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef searchBST(root: TreeNode, val: int) -> TreeNode:\n    if not root or root.val == val:\n        return root\n    return searchBST(root.right, val) if root.val < val else searchBST(root.left, val)", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef insertIntoBST(root, val):\n    if root is None:\n        return TreeNode(val)\n\n    if val < root.val:\n        root.left = insertIntoBST(root.left, val)\n    else:\n        root.right = insertIntoBST(root.right, val)\n\n    return root", "def search(reader, target):\n    left, right = 0, 1\n    while reader.get(right) < target:\n        left = right\n        right <<= 1\n\n    while left <= right:\n        mid = left + ((right - left) >> 1)\n        val = reader.get(mid)\n        if val == target:\n            return mid\n        if val > target:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return -1", "import heapq\n\nclass KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.min_heap = nums\n        heapq.heapify(self.min_heap)\n        \n        while len(self.min_heap) > k:\n            heapq.heappop(self.min_heap)\n\n    def add(self, val: int) -> int:\n        if len(self.min_heap) < self.k:\n            heapq.heappush(self.min_heap, val)\n        elif val > self.min_heap[0]:\n            heapq.heappushpop(self.min_heap, val)\n        return self.min_heap[0]", "def search(nums: List[int], target: int) -> int:\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1", "class MyHashSet:\n\n    def __init__(self):\n        self.storage = [False] * 1000001\n\n    def add(self, key: int):\n        self.storage[key] = True\n\n    def remove(self, key: int):\n        self.storage[key] = False\n\n    def contains(self, key: int) -> bool:\n        return self.storage[key]", "class MyHashMap:\n    def __init__(self):\n        self.size = 10007\n        self.data = [[] for _ in range(self.size)]\n\n    def put(self, key: int, value: int) -> None:\n        bucket = self.data[key % self.size]\n        for pair in bucket:\n            if pair[0] == key:\n                pair[1] = value\n                return\n        bucket.append([key, value])\n\n    def get(self, key: int) -> int:\n        bucket = self.data[key % self.size]\n        for pair in bucket:\n            if pair[0] == key:\n                return pair[1]\n        return -1\n\n    def remove(self, key: int) -> None:\n        bucket = self.data[key % self.size]\n        for i, pair in enumerate(bucket):\n            if pair[0] == key:\n                bucket.pop(i)\n                return", "class Node:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass MyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.size = 0\n\n    def get(self, index: int) -> int:\n        if index < 0 or index >= self.size:\n            return -1\n        cur = self.head\n        for _ in range(index):\n            cur = cur.next\n        return cur.val\n\n    def addAtHead(self, val: int) -> None:\n        self.head = Node(val, self.head)\n        self.size += 1\n\n    def addAtTail(self, val: int) -> None:\n        if self.size == 0:\n            self.addAtHead(val)\n        else:\n            cur = self.head\n            while cur.next:\n                cur = cur.next\n            cur.next = Node(val)\n            self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index < 0 or index > self.size:\n            return\n        if index == 0:\n            self.addAtHead(val)\n        else:\n            cur = self.head\n            for _ in range(index - 1):\n                cur = cur.next\n            cur.next = Node(val, cur.next)\n            self.size += 1\n\n    def deleteAtIndex(self, index: int) -> None:\n        if index < 0 or index >= self.size:\n            return\n        if index == 0:\n            self.head = self.head.next\n        else:\n            cur = self.head\n            for _ in range(index - 1):\n                cur = cur.next\n            cur.next = cur.next.next\n        self.size -= 1", "class Node:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef insert(head, insertVal):\n    if head is None:\n        newNode = Node(insertVal)\n        newNode.next = newNode\n        return newNode\n\n    prev, curr = head, head.next\n    inserted = False\n\n    while True:\n        if prev.val <= insertVal <= curr.val:\n            prev.next = Node(insertVal, curr)\n            inserted = True\n        elif prev.val > curr.val:\n            if insertVal >= prev.val or insertVal <= curr.val:\n                prev.next = Node(insertVal, curr)\n                inserted = True\n        prev, curr = curr, curr.next\n\n        if prev == head or inserted:\n            break\n\n    if not inserted:\n        prev.next = Node(insertVal, curr)\n\n    return head", "def toLowerCase(s: str) -> str:\n    return s.lower()", "import random\n\nclass Solution:\n    def __init__(self, n: int, blacklist: List[int]):\n        blacklist.sort()\n        self.mapping = dict()\n        idx = 0\n        for black in blacklist:\n            while idx < black:\n                self.mapping[idx] = n - 1\n                idx += 1\n                n -= 1\n            idx += 1\n            n -= 1\n        self.last = n\n\n    def pick(self) -> int:\n        num = random.randrange(self.last)\n        return self.mapping.get(num, num)", "class Solution:\n    def numDistinctIslands(self, grid: List[List[int]]) -> int:\n        def dfs(r, c, r0, c0):\n            if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c]:\n                grid[r][c] = 0\n                island.append((r - r0, c - c0))\n                dfs(r + 1, c, r0, c0)\n                dfs(r - 1, c, r0, c0)\n                dfs(r, c + 1, r0, c0)\n                dfs(r, c - 1, r0, c0)\n\n        def normalize(island):\n            ret = []\n            for p in island:\n                x, y = p\n                ret += [(x, y), (x, -y), (-x, y), (-x, -y), (y, x), (y, -x), (-y, x), (-y, -x)]\n            ret.sort()\n            return tuple(ret)\n\n        distinctIslands = set()\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c]:\n                    island = []\n                    dfs(r, c, r, c)\n                    distinctIslands.add(normalize(island))\n        return len(distinctIslands)", "def minimumDeleteSum(s1: str, s2: str) -> int:\n    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n    for i in range(1, len(s1) + 1):\n        dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])\n    for j in range(1, len(s2) + 1):\n        dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])\n    for i in range(1, len(s1) + 1):\n        for j in range(1, len(s2) + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j] + ord(s1[i - 1]), dp[i][j - 1] + ord(s2[j - 1]))\n    return dp[len(s1)][len(s2)]", "def numSubarrayProductLessThanK(nums, k):\n    if k <= 1:\n        return 0\n    prod = 1\n    count = 0\n    left = 0\n    for right in range(len(nums)):\n        prod *= nums[right]\n        while prod >= k:\n            prod /= nums[left]\n            left += 1\n        count += right - left + 1\n    return count", "def maxProfit(prices, fee):\n    cash, hold = 0, -prices[0]\n    for price in prices:\n        temp = cash\n        cash = max(cash, hold + price - fee)\n        hold = max(hold, temp - price)\n    return cash", "from sortedcontainers import SortedList\n\nclass MaxStack:\n    def __init__(self):\n        self.mainStack = []\n        self.maxSet = SortedList()\n\n    def push(self, x: int) -> None:\n        self.mainStack.append(x)\n        self.maxSet.add(x)\n\n    def pop(self) -> int:\n        top = self.mainStack.pop()\n        self.maxSet.remove(top)\n        return top\n\n    def top(self) -> int:\n        return self.mainStack[-1]\n\n    def peekMax(self) -> int:\n        return self.maxSet[-1]\n\n    def popMax(self) -> int:\n        max_val = self.maxSet.pop()\n        tempStack = []\n        while self.mainStack[-1] != max_val:\n            tempStack.append(self.mainStack.pop())\n        self.mainStack.pop()\n        while tempStack:\n            self.mainStack.append(tempStack.pop())\n        return max_val", "def is_one_bit_character(bits):\n    i = 0\n    while i < len(bits) - 1:\n        i += bits[i] + 1\n    return i == len(bits) - 1", "def findLength(nums1, nums2):\n    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    maxLength = 0\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if nums1[i] == nums2[j]:\n                dp[i][j] = dp[i + 1][j + 1] + 1\n                maxLength = max(maxLength, dp[i][j])\n\n    return maxLength", "def smallestDistancePair(nums, k):\n    nums.sort()\n    low, high = 0, nums[-1] - nums[0]\n    \n    while low < high:\n        mid = (low + high) // 2\n        count, left = 0, 0\n\n        for right in range(len(nums)):\n            while nums[right] - nums[left] > mid:\n                left += 1\n            count += (right - left)\n\n        if count < k:\n            low = mid + 1\n        else:\n            high = mid\n    \n    return low", "def longest_word(words):\n    built_words = set()\n    result = ''\n\n    for word in sorted(words):\n        if len(word) == 1 or word[:-1] in built_words:\n            if len(word) > len(result):\n                result = word\n            built_words.add(word)\n\n    return result", "from collections import defaultdict\n\ndef accountsMerge(accounts):\n    def dfs(id, visited, merged_emails):\n        if id in visited:\n            return\n        visited.add(id)\n        for email in accounts[id][1:]:\n            merged_emails.add(email)\n            dfs(email_to_id[email], visited, merged_emails)\n\n    email_to_id = {}\n    for i, account in enumerate(accounts):\n        for email in account[1:]:\n            email_to_id[email] = i\n\n    result = []\n    visited = set()\n    for i, account in enumerate(accounts):\n        if i not in visited:\n            merged_emails = set()\n            dfs(i, visited, merged_emails)\n            result.append([account[0]] + sorted(merged_emails))\n    return result", "def removeComments(self, source: List[str]) -> List[str]:\n    result = []\n    buffer = []\n    in_block_comment = False\n\n    for line in source:\n        i = 0\n        while i < len(line):\n            if in_block_comment:\n                if i < len(line) - 1 and line[i] == '*' and line[i + 1] == '/':\n                    in_block_comment = False\n                    i += 1\n            else:\n                if i < len(line) - 1 and line[i] == '/' and line[i + 1] == '*':\n                    in_block_comment = True\n                    i += 1\n                elif i < len(line) - 1 and line[i] == '/' and line[i + 1] == '/':\n                    break\n                else:\n                    buffer.append(line[i])\n            i += 1\n\n        if not in_block_comment and buffer:\n            result.append(''.join(buffer))\n            buffer.clear()\n\n    return result", "def candyCrush(board):\n    rows = len(board)\n    cols = len(board[0])\n    toDo = False\n    \n    for r in range(rows):\n        for c in range(cols - 2):\n            val = abs(board[r][c])\n            if val and val == abs(board[r][c + 1]) and val == abs(board[r][c + 2]):\n                board[r][c] = board[r][c + 1] = board[r][c + 2] = -val\n                toDo = True\n                \n    for r in range(rows - 2):\n        for c in range(cols):\n            val = abs(board[r][c])\n            if val and val == abs(board[r + 1][c]) and val == abs(board[r + 2][c]):\n                board[r][c] = board[r + 1][c] = board[r + 2][c] = -val\n                toDo = True\n                \n    for c in range(cols):\n        wr = rows - 1\n        for r in range(rows - 1, -1, -1):\n            if board[r][c] > 0:\n                board[wr][c] = board[r][c]\n                wr -= 1\n                \n        for r in range(wr, -1, -1):\n            board[r][c] = 0\n                \n    return candyCrush(board) if toDo else board", "def pivotIndex(nums):\n    total_sum = sum(nums)\n    left_sum = 0\n    for i, num in enumerate(nums):\n        if left_sum == total_sum - left_sum - num:\n            return i\n        left_sum += num\n    return -1", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef splitListToParts(root, k):\n    result = [None] * k\n    list_size = 0\n    current_node = root\n    while current_node:\n        list_size += 1\n        current_node = current_node.next\n\n    base_size = list_size // k\n    extra = list_size % k\n\n    current_node = root\n    for i in range(k):\n        if not current_node:\n            break\n        result[i] = current_node\n        current_part_size = base_size + (1 if i < extra else 0)\n        for _ in range(current_part_size - 1):\n            current_node = current_node.next\n        next_node = current_node.next\n        current_node.next = None\n        current_node = next_node\n\n    return result", "from collections import Counter\n\ndef parse(formula, i):\n    counts = Counter()\n    while i[0] < len(formula):\n        if formula[i[0]] == '(':\n            i[0] += 1\n            temp = parse(formula, i)\n            count = 0\n            while i[0] < len(formula) and formula[i[0]].isdigit():\n                count = count * 10 + int(formula[i[0]])\n                i[0] += 1\n            if count == 0: count = 1\n            for name, c in temp.items():\n                counts[name] += c * count\n        elif formula[i[0]] == ')':\n            i[0] += 1\n            return counts\n        else:\n            name = formula[i[0]]\n            i[0] += 1\n            while i[0] < len(formula) and formula[i[0]].islower():\n                name += formula[i[0]]\n                i[0] += 1\n            count = 0\n            while i[0] < len(formula) and formula[i[0]].isdigit():\n                count = count * 10 + int(formula[i[0]])\n                i[0] += 1\n            if count == 0: count = 1\n            counts[name] += count\n    return counts\n\ndef countOfAtoms(formula):\n    i = [0]\n    counts = parse(formula, i)\n    ans = []\n    for name, count in counts.items():\n        ans.append(name)\n        if count > 1: ans.append(str(count))\n    return ''.join(ans)", "def min_window_sub_sequence(s1: str, s2: str) -> str:\n    m, n = len(s1), len(s2)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for j in range(0, m + 1):\n        dp[0][j] = j\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if s1[j - 1] == s2[i - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = dp[i][j - 1]\n\n    start, length = 0, m + 1\n    for j in range(1, m + 1):\n        if dp[n][j] != 0 and j - dp[n][j] < length:\n            start = dp[n][j]\n            length = j - start\n\n    return \"\" if length == m + 1 else s1[start:start + length]", "def is_self_dividing(num):\n    n = num\n    while n:\n        digit = n % 10\n        if digit == 0 or num % digit != 0:\n            return False\n        n //= 10\n    return True\n\ndef self_dividing_numbers(left, right):\n    return [i for i in range(left, right+1) if is_self_dividing(i)]", "from bisect import bisect_left, insort\n\nclass MyCalendar:\n\n    def __init__(self):\n        self.calendar = []\n\n    def book(self, start, end):\n        i = bisect_left(self.calendar, [start, end])\n        if i % 2 == 1:\n            return False\n        if i > 0 and self.calendar[i-1] > start:\n            return False\n        if i < len(self.calendar) and end > self.calendar[i]:\n            return False\n        insort(self.calendar, start)\n        insort(self.calendar, end)\n        return True", "def countPalindromicSubsequences(s: str) -> int:\n    n = len(s)\n    MOD = 1000000007\n    dp = [[0] * (n + 1) for _ in range(4)]\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n + 1):\n            c = ord(s[i]) - ord('a')\n            dp[c][j] = sum(dp[k][j - 1] for k in range(4)) - dp[c][i] + 2\n            dp[c][j] = (dp[c][j] + MOD) % MOD\n\n    return sum(dp[c][n] for c in range(4)) % MOD", "class MyCalendarTwo:\n    def __init__(self):\n        self.singles = []\n        self.doubles = []\n\n    def book(self, start: int, end: int) -> bool:\n        for d_start, d_end in self.doubles:\n            if start < d_end and end > d_start:\n                return False\n        for s_start, s_end in self.singles:\n            if start < s_end and end > s_start:\n                self.doubles.append((max(start, s_start), min(end, s_end)))\n        self.singles.append((start, end))\n        return True", "from collections import defaultdict\nimport heapq\n\nclass MyCalendarThree:\n\n    def __init__(self):\n        self.timeline = defaultdict(int)\n\n    def book(self, start: int, end: int) -> int:\n        self.timeline[start] += 1\n        self.timeline[end] -= 1\n        ongoing, k = 0, 0\n        for value in self.timeline.values():\n            k = max(k, ongoing + value)\n            ongoing += value\n        return k", "def floodFill(image, sr, sc, newColor):\n    startColor = image[sr][sc]\n    def fill(sr, sc):\n        if not (0 <= sr < len(image)) or not (0 <= sc < len(image[0])) or image[sr][sc] != startColor or image[sr][sc] == newColor: \n            return\n        image[sr][sc] = newColor\n        fill(sr - 1, sc)\n        fill(sr + 1, sc)\n        fill(sr, sc - 1)\n        fill(sr, sc + 1)\n    \n    fill(sr, sc)\n    return image", "from collections import defaultdict\n\ndef areSentencesSimilar(sentence1, sentence2, similarPairs):\n    if len(sentence1) != len(sentence2): return False\n    similarityMap = defaultdict(set)\n    for pair in similarPairs:\n        similarityMap[pair[0]].add(pair[1])\n        similarityMap[pair[1]].add(pair[0])\n    for i in range(len(sentence1)):\n        if sentence1[i] != sentence2[i] and sentence2[i] not in similarityMap[sentence1[i]]:\n            return False\n    return True", "def asteroidCollision(asteroids):\n    s = []\n    for num in asteroids:\n        if num > 0 or not s or s[-1] < 0:\n            s.append(num)\n        elif s[-1] <= -num:\n            if s[-1] < -num:\n                s.pop()\n                s.append(num)\n            else:\n                s.pop()\n    return s", "def evaluate(expression: str) -> int:\n    def calculate(s, start, end, variables):\n        if s[start] == '(':\n            if s[start + 1:start + 4] == \"add\":\n                first = start + 5\n                second = first\n                value1 = calculate(s, first, end, variables)\n                second = s.index(' ', second) + 1\n                value2 = calculate(s, second, end, variables)\n                return value1 + value2\n            elif s[start + 1:start + 5] == \"mult\":\n                first = start + 6\n                second = first\n                value1 = calculate(s, first, end, variables)\n                second = s.index(' ', second) + 1\n                value2 = calculate(s, second, end, variables)\n                return value1 * value2\n            else:\n                inner = variables.copy()\n                idx = start + 5\n                while idx < end - 1 and s[idx] != '(':\n                    temp = idx\n                    idx = s.index(' ', idx + 1)\n                    var = s[temp:idx]\n                    temp = idx + 1\n                    if s[temp] == '(':\n                        idx += 1\n                    else:\n                        idx = s.index(' ', idx + 1)\n                    result = calculate(s, temp, idx, variables)\n                    inner[var] = result\n                    variables = inner\n                return calculate(s, end - 1, end, variables)\n        else:\n            if s[start].isdigit() or s[start] == '-':\n                end = s.find(' ', start) if ' ' in s[start:end] else end\n                return int(s[start:end])\n            else:\n                end = s.find(' ', start) if ' ' in s[start:end] else end\n                return variables[s[start:end]]\n\n    return calculate(expression, 0, len(expression), {})", "from collections import defaultdict\n\ndef areSentencesSimilar(sentence1, sentence2, pairs):\n    if len(sentence1) != len(sentence2):\n        return False\n    \n    graph = defaultdict(set)\n    for a, b in pairs:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    for a, b in zip(sentence1, sentence2):\n        if a == b:\n            continue\n        if b not in graph[a]:\n            return False\n\n    return True", "def monotoneIncreasingDigits(n: int) -> int:\n    n_str = [c for c in str(n)]\n\n    i = len(n_str) - 1\n    while i > 0:\n        if n_str[i] < n_str[i - 1]:\n            n_str[i - 1] = chr(ord(n_str[i - 1]) - 1)\n            for j in range(i, len(n_str)):\n                n_str[j] = '9'\n        i -= 1\n\n    return int(''.join(n_str))", "def daily_temperatures(temperatures):\n    result = [0] * len(temperatures)\n    stack = []\n\n    for i, temp in enumerate(temperatures):\n        while stack and temp > temperatures[stack[-1]]:\n            idx = stack.pop()\n            result[idx] = i - idx\n        stack.append(i)\n\n    return result", "def max_points(nums):\n    dp = [0] * 100001\n    max_points = 0\n    for num in nums:\n        dp[num] += 1\n    for i in range(2, len(dp)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + i * dp[i])\n        max_points = max(max_points, dp[i])\n    return max_points", "def cherryPickup(self, grid: List[List[int]]) -> int:\n    def dp(r1, c1, c2):\n        r2 = r1 + c1 - c2\n        if (r1 == len(grid) or r2 == len(grid) or c1 == len(grid) or c2 == len(grid) or\n            grid[r1][c1] == -1 or grid[r2][c2] == -1):\n            return float('-inf')\n        elif r1 == len(grid) - 1 and c1 == len(grid) - 1:\n            return grid[r1][c1]\n        elif memo[r1][c1][c2] != float('-inf'):\n            return memo[r1][c1][c2]\n        else:\n            memo[r1][c1][c2] = grid[r1][c1] + (r1 != r2) * grid[r2][c2]\n            max_cherries = max(dp(r1 + 1, c1, c2 + 1), dp(r1, c1 + 1, c2 + 1),\n                               dp(r1 + 1, c1, c2), dp(r1, c1 + 1, c2))\n            memo[r1][c1][c2] += max_cherries\n        \n        return memo[r1][c1][c2]\n    \n    N = len(grid)\n    memo = [[[float('-inf')] * N for _1 in range(N)] for _2 in range(N)]\n    return max(0, dp(0, 0, 0))", "def to_lower_case(s: str) -> str:\n    return s.lower()", "import heapq\n\ndef networkDelayTime(times, n, k):\n    graph = {i: [] for i in range(1, n+1)}\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    dist = {u: float('inf') for u in range(1, n+1)}\n    dist[k] = 0\n\n    pq = [(0, k)]\n\n    while pq:\n        curr_dist, u = heapq.heappop(pq)\n\n        for v, weight in graph[u]:\n            new_dist = curr_dist + weight\n            if new_dist < dist[v]:\n                dist[v] = new_dist\n                heapq.heappush(pq, (new_dist, v))\n\n    max_time = max(dist.values())\n    return max_time if max_time < float('inf') else -1", "import heapq\nfrom collections import defaultdict\n\ndef networkDelayTime(times, n, k):\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    dist = {i: float('inf') for i in range(1, n + 1)}\n    dist[k] = 0\n\n    pq = [(0, k)]\n\n    while pq:\n        time, node = heapq.heappop(pq)\n\n        if time > dist[node]:\n            continue\n\n        for neighbour, neighbourTime in graph[node]:\n            candidate_dist = time + neighbourTime\n            if candidate_dist < dist[neighbour]:\n                dist[neighbour] = candidate_dist\n                heapq.heappush(pq, (candidate_dist, neighbour))\n\n    maxTime = max(dist.values())\n    return maxTime if maxTime < float('inf') else -1", "def next_greatest_letter(letters, target):\n    for letter in letters:\n        if letter > target:\n            return letter\n    return letters[0]", "class WordFilter:\n\n    def __init__(self, words):\n        self.dict = {}\n        for i, word in enumerate(words):\n            for j in range(len(word) + 1):\n                self.dict[word[:j] + \"#\" + word[j:]] = i\n\n    def f(self, prefix, suffix):\n        return self.dict.get(prefix + \"#\" + suffix, -1)", "def minCostClimbingStairs(cost):\n    for i in range(2, len(cost)):\n        cost[i] += min(cost[i-1], cost[i-2])\n    return min(cost[-1], cost[-2])", "def shortestCompletingWord(licensePlate: str, words: list[str]) -> str:\n    from collections import Counter\n\n    lp_count = Counter(c.lower() for c in licensePlate if c.isalpha())\n\n    result = \"\"\n    for word in words:\n        word_count = Counter(word)\n\n        valid = all(word_count[ch] >= count for ch, count in lp_count.items())\n\n        if valid and (not result or len(word) < len(result)):\n            result = word\n\n    return result", "def shortest_completing_word(license_plate, words):\n    target = [0] * 26\n    for c in license_plate:\n        if c.isalpha():\n            target[ord(c.lower()) - ord('a')] += 1\n\n    result = \"\"\n    for word in words:\n        current = [0] * 26\n        for c in word:\n            if c.isalpha():\n                current[ord(c.lower()) - ord('a')] += 1\n\n        if all(a <= b for a, b in zip(target, current)) and (not result or len(word) < len(result)):\n            result = word\n\n    return result", "def countCornerRectangles(grid):\n    count = 0\n    m = len(grid)\n    n = len(grid[0])\n    \n    for i in range(m - 1):\n        for j in range(n - 1):\n            if grid[i][j] == 1:\n                for k in range(i + 1, m):\n                    for l in range(j + 1, n):\n                        if grid[k][l] == 1 and grid[i][l] == 1 and grid[k][j] == 1:\n                            count += 1\n    return count", "def ipToCIDR(ip: str, n: int) -> List[str]:\n    a, b, c, d = map(int, ip.split('.'))\n    start = (a << 24) + (b << 16) + (c << 8) + d\n    end = start + n - 1\n    \n    ans = []\n    while start <= end:\n        samePrefixBits = (~start & start).bit_length() - 1\n        while ((end - start) >> samePrefixBits) < 1:\n            samePrefixBits -= 1\n        range = 1 << samePrefixBits\n        ans.append(f\"{start >> 24}.{(start >> 16) & 255}.{(start >> 8) & 255}.{start & 255}/{32 - samePrefixBits}\")\n        start += range\n    \n    return ans", "from collections import deque\n\ndef openLock(deadends, target):\n    dead = set(deadends)\n    visited = set()\n    q = deque([\"0000\"])\n\n    if \"0000\" in dead:\n        return -1\n\n    visited.add(\"0000\")\n    moves = 0\n\n    while q:\n        level_size = len(q)\n        for i in range(level_size):\n            cur = q.popleft()\n\n            if cur == target:\n                return moves\n\n            for j in range(4):\n                for k in [-1, 1]:\n                    next_val = cur[:j] + str((int(cur[j]) + k + 10) % 10) + cur[j + 1:]\n\n                    if next_val not in visited and next_val not in dead:\n                        visited.add(next_val)\n                        q.append(next_val)\n\n        moves += 1\n\n    return -1", "from collections import deque\n\ndef openLock(deadends, target):\n    dead = set(deadends)\n    visited = set()\n    wheel_states = deque([(\"0000\", 0)])\n\n    if \"0000\" in dead:\n        return -1\n\n    while wheel_states:\n        current_state, turns = wheel_states.popleft()\n\n        if current_state == target:\n            return turns\n\n        for i in range(4):\n            up_state = current_state[:i] + str((int(current_state[i]) + 1) % 10) + current_state[i + 1:]\n            down_state = current_state[:i] + str((int(current_state[i]) - 1) % 10) + current_state[i + 1:]\n\n            if up_state not in visited and up_state not in dead:\n                wheel_states.append((up_state, turns + 1))\n                visited.add(up_state)\n\n            if down_state not in visited and down_state not in dead:\n                wheel_states.append((down_state, turns + 1))\n                visited.add(down_state)\n\n    return -1", "def reachNumber(target: int) -> int:\n    target = abs(target)\n    step = 0\n    sum = 0\n    while sum < target:\n        step += 1\n        sum += step\n    while (sum - target) % 2 != 0:\n        step += 1\n        sum += step\n    return step", "def min_moves(target: int) -> int:\n    target = abs(target)\n    step = 0\n    total = 0\n    while total < target or (total - target) % 2 != 0:\n        step += 1\n        total += step\n    return step", "def pyramid_transition(bottom, allowed):\n    mapping = {}\n    for s in allowed:\n        key = s[:2]\n        if key not in mapping:\n            mapping[key] = []\n        mapping[key].append(s[2])\n    return pyramid_transition_helper(bottom, \"\", 0, mapping)\n\ndef pyramid_transition_helper(bottom, top, idx, mapping):\n    if len(bottom) == 1:\n        return True\n    if idx == len(bottom) - 1:\n        return pyramid_transition_helper(top, \"\", 0, mapping)\n    key = bottom[idx:idx + 2]\n    if key not in mapping:\n        return False\n    for c in mapping[key]:\n        if pyramid_transition_helper(bottom, top + c, idx + 1, mapping):\n            return True\n    return False", "from collections import defaultdict\n\ndef pyramidTransition(bottom, allowed):\n    mapping = defaultdict(list)\n    for s in allowed:\n        mapping[s[:2]].append(s[2])\n    return dfs(\"\", bottom, mapping)\n\ndef dfs(curr, bottom, mapping):\n    if len(bottom) == 1:\n        return True\n    for i in range(len(bottom) - 1):\n        if bottom[i:i+2] not in mapping:\n            return False\n    curr = \"\".join(mapping[bottom[i:i + 2]][0] for i in range(len(bottom) - 1))\n    return dfs(curr, curr, mapping)", "def addBoldTag(words, s):\n    bold = [False] * len(s)\n    for word in words:\n        pos = s.find(word)\n        while pos != -1:\n            for i in range(pos, pos + len(word)):\n                bold[i] = True\n            pos = s.find(word, pos + 1)\n\n    result = []\n    for i in range(len(s)):\n        if bold[i] and (i == 0 or not bold[i - 1]):\n            result.append(\"<b>\")\n        result.append(s[i])\n        if bold[i] and (i == len(s) - 1 or not bold[i + 1]):\n            result.append(\"</b>\")\n\n    return \"\".join(result)", "def min_set_size(intervals):\n    intervals.sort()\n    n = len(intervals)\n    end = intervals[0][1]\n    count = 1\n\n    for i in range(1, n):\n        if end < intervals[i][0]:\n            end = intervals[i][1]\n            count += 1\n        else:\n            end = min(end, intervals[i][1])\n    return count * 2", "def anagramMappings(nums1, nums2):\n    num_map = {num: i for i, num in enumerate(nums2)}\n    mapping = [num_map[num] for num in nums1]\n    return mapping", "def makeLargestSpecial(s: str) -> str:\n    count, i = 0, 0\n    subs = []\n\n    for j in range(len(s)):\n        if s[j] == '1':\n            count += 1\n        else:\n            count -= 1\n\n        if count == 0:\n            subs.append(\"1\" + makeLargestSpecial(s[i+1:j]) + \"0\")\n            i = j + 1\n\n    subs.sort(reverse=True)\n    return \"\".join(subs)", "def is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef count_prime_set_bits(left: int, right: int) -> int:\n    return sum(is_prime(bin(i).count('1')) for i in range(left, right + 1))", "def partition_labels(s):\n    last = {c:i for i, c in enumerate(s)}\n    ans = []\n    j = anchor = 0\n    for i, c in enumerate(s):\n        j = max(j, last[c])\n        if i == j:\n            ans.append(i - anchor + 1)\n            anchor = i + 1\n    return ans", "from collections import deque\n\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\ndef levelOrder(root):\n    result = []\n\n    if not root:\n        return result\n\n    toVisit = deque([root])\n\n    while toVisit:\n        size = len(toVisit)\n        level = []\n\n        for _ in range(size):\n            currentNode = toVisit.popleft()\n            level.append(currentNode.val)\n\n            for child in currentNode.children:\n                toVisit.append(child)\n\n        result.append(level)\n\n    return result", "def minSwapsCouples(row):\n    n = len(row)\n    position = [0] * n\n    for i in range(n):\n        position[row[i]] = i\n\n    swaps = 0\n    for i in range(0, n, 2):\n        partner = row[i] + 1 if row[i] % 2 == 0 else row[i] - 1\n        if row[i + 1] != partner:\n            row[position[partner]], row[i + 1] = row[i + 1], row[position[partner]]\n            position[row[i + 1]], position[partner] = position[partner], position[row[i + 1]]\n            swaps += 1\n    return swaps", "class Node:\n    def __init__(self, val=0, prev=None, next=None, child=None):\n        self.val = val\n        self.prev = prev\n        self.next = next\n        self.child = child\n\ndef flatten(head: Node) -> Node:\n    if not head:\n        return None\n    \n    curr = head\n    while curr:\n        if curr.child:\n            insert = curr.child\n            next_node = curr.next\n            \n            insert.prev = curr\n            curr.next = insert\n            curr.child = None\n            \n            while insert.next:\n                insert = insert.next\n                \n            if next_node:\n                next_node.prev = insert\n                insert.next = next_node\n                \n        curr = curr.next\n        \n    return head", "def is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef count_prime_set_bits(left: int, right: int) -> int:\n    count = 0\n    for i in range(left, right + 1):\n        bits = bin(i).count('1')\n        if is_prime(bits):\n            count += 1\n    return count", "def partition_labels(s: str) -> list[int]:\n    last_pos = {}\n    for i, c in enumerate(s):\n        last_pos[c] = i\n\n    partitions = []\n    start, end = 0, 0\n    for i, c in enumerate(s):\n        end = max(end, last_pos[c])\n        if i == end:\n            partitions.append(end - start + 1)\n            start = i + 1\n    return partitions", "def orderOfLargestPlusSign(n, mines):\n    grid = [[1] * n for _ in range(n)]\n    for mine in mines:\n        grid[mine[0]][mine[1]] = 0\n        \n    left, right, up, down = [list(grid) for _ in range(4)]\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j]:\n                left[i][j] = 1 + (left[i][j - 1] if j > 0 else 0)\n                up[i][j] = 1 + (up[i - 1][j] if i > 0 else 0)\n\n    ans = 0\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if grid[i][j]:\n                right[i][j] = 1 + (right[i][j + 1] if j < n - 1 else 0)\n                down[i][j] = 1 + (down[i + 1][j] if i < n - 1 else 0)\n                ans = max(ans, min([left[i][j], right[i][j], up[i][j], down[i][j]]))\n\n    return ans", "def minSwapsCouples(row):\n    n = len(row) // 2\n    swaps = 0\n    position = {num: i for i, num in enumerate(row)}\n\n    for i in range(0, len(row), 2):\n        couple = row[i] - 1 if row[i] % 2 else row[i] + 1\n        if row[i + 1] != couple:\n            row[i + 1], row[position[couple]] = row[position[couple]], row[i + 1]\n            position[row[i + 1]], position[couple] = position[couple], i + 1\n            swaps += 1\n\n    return swaps", "def num_jewels_in_stones(jewels: str, stones: str) -> int:\n    count = 0\n    for stone in stones:\n        if stone in jewels:\n            count += 1\n    return count", "class Node:\n    def __init__(self, val: bool, isLeaf: bool, topLeft: 'Node', topRight: 'Node', bottomLeft: 'Node', bottomRight: 'Node'):\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n\ndef construct(grid):\n    def helper(x, y, length):\n        if length == 1:\n            return Node(grid[x][y] == 1, True, None, None, None, None)\n\n        tl = helper(x, y, length // 2)\n        tr = helper(x, y + length // 2, length // 2)\n        bl = helper(x + length // 2, y, length // 2)\n        br = helper(x + length // 2, y + length // 2, length // 2)\n\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val and tr.val == bl.val and bl.val == br.val:\n            return Node(tl.val, True, None, None, None, None)\n        else:\n            return Node(False, False, tl, tr, bl, br)\n\n    return helper(0, 0, len(grid))", "class TreeNode:\n    def __init__(self, isLeaf, val, topLeft=None, topRight=None, bottomLeft=None, bottomRight=None):\n        self.isLeaf = isLeaf\n        self.val = val\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n\ndef intersect(quadTree1, quadTree2):    \n    if quadTree1.isLeaf:\n        return quadTree1 if quadTree1.val else quadTree2\n    if quadTree2.isLeaf:\n        return quadTree2 if quadTree2.val else quadTree1\n\n    quadTree1.topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft)\n    quadTree1.topRight = intersect(quadTree1.topRight, quadTree2.topRight)\n    quadTree1.bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\n    quadTree1.bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight)\n\n    if quadTree1.topLeft.isLeaf and quadTree1.topRight.isLeaf and quadTree1.bottomLeft.isLeaf and quadTree1.bottomRight.isLeaf and quadTree1.topLeft.val == quadTree1.topRight.val == quadTree1.bottomLeft.val == quadTree1.bottomRight.val:\n        quadTree1.isLeaf = True\n        quadTree1.val = quadTree1.topLeft.val\n\n    return quadTree1", "class Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n \ndef max_depth(root):\n    if root is None:\n        return 0\n    depth = 0\n    for child in root.children:\n        depth = max(depth, max_depth(child))\n    return 1 + depth", "class Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\ndef helper(root, result):\n    if not root:\n        return\n    result.append(root.val)\n    for child in root.children:\n        helper(child, result)\n\ndef preorder(root):\n    result = []\n    helper(root, result)\n    return result", "class Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\ndef postorder(root: 'Node'):\n    if root is None:\n        return []\n    \n    result = []\n    stack = [root]\n\n    while stack:\n        curr = stack.pop()\n        result.append(curr.val)\n        stack.extend(curr.children)\n\n    return result[::-1]", "def isToeplitzMatrix(matrix):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    for i in range(rows - 1):\n        for j in range(cols - 1):\n            if matrix[i][j] != matrix[i+1][j+1]:\n                return False\n    return True", "import heapq\n\ndef rearrange_string(s):\n    counts = {}\n    for c in s:\n        counts[c] = counts.get(c, 0) + 1\n    \n    pq = [(-count, char) for char, count in counts.items()]\n    heapq.heapify(pq)\n    \n    result = []\n    previous = (0, '')\n    \n    while pq:\n        count, char = heapq.heappop(pq)\n        result.append(char)\n        \n        if previous[0] < 0:\n            heapq.heappush(pq, previous)\n        \n        count += 1\n        previous = (count, char)\n    \n    result_str = ''.join(result)\n    return result_str if len(result_str) == len(s) else \"\"", "def max_chunks_to_sorted(arr):\n    max_val, chunks = 0, 0\n    for i, value in enumerate(arr):\n        max_val = max(max_val, value)\n        if max_val == i:\n            chunks += 1\n    return chunks", "def max_chunks_to_sorted(arr):\n    max_so_far, count = 0, 0\n    for i, val in enumerate(arr):\n        max_so_far = max(max_so_far, val)\n        if max_so_far == i:\n            count += 1\n    return count", "from collections import Counter\n\ndef numRabbits(answers):\n    count = Counter(answers)\n    rabbits = 0\n    for ans, cnt in count.items():\n        rabbits += (ans + cnt)//(ans + 1) * (ans + 1)\n    return rabbits", "def numJewelsInStones(jewels, stones):\n    count = 0\n    for s in stones:\n        if s in jewels:\n            count += 1\n    return count", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef searchBST(root: TreeNode, val: int) -> TreeNode:\n    if not root or root.val == val:\n        return root\n    return searchBST(root.left, val) if root.val > val else searchBST(root.right, val)", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef insertIntoBST(root, val):\n    if root is None:\n        return TreeNode(val)\n\n    if val < root.val:\n        root.left = insertIntoBST(root.left, val)\n    else:\n        root.right = insertIntoBST(root.right, val)\n\n    return root", "def isBipartite(graph: List[List[int]]) -> bool:\n    def dfs(node: int, color: int) -> bool:\n        if colors[node]:\n            return colors[node] == color\n\n        colors[node] = color\n        for neighbor in graph[node]:\n            if not dfs(neighbor, 3 - color):\n                return False\n\n        return True\n\n    n = len(graph)\n    colors = [0] * n\n\n    for i in range(n):\n        if not colors[i] and not dfs(i, 1):\n            return False\n\n    return True", "import heapq\nfrom typing import List\n\ndef kthSmallestPrimeFraction(arr: List[int], k: int) -> List[int]:\n    pq = [(arr[i] / arr[j], i, j) for j in range(len(arr) - 1, 0, -1)]\n    heapq.heapify(pq)\n    for _ in range(k - 1):\n        _, i, j = heapq.heappop(pq)\n        if j != i + 1:\n            heapq.heappush(pq, (arr[i] / arr[j - 1], i, j - 1))\n    return [arr[pq[0][1]], arr[pq[0][2]]]", "from collections import deque\n\ndef slidingPuzzle(board):\n    m, n = 2, 3\n    target = \"123450\"\n    start = \"\".join(str(num) for row in board for num in row)\n    dirs = [[1, 3], [0, 2, 4], [1, 5], [0, 4], [1, 3, 5], [2, 4]]\n    q = deque([start])\n    res = 0\n    visited = {start}\n    while q:\n        for _ in range(len(q)):\n            cur = q.popleft()\n            if cur == target:\n                return res\n            zero_idx = cur.index(\"0\")\n            for dir in dirs[zero_idx]:\n                neighbor = list(cur)\n                neighbor[zero_idx], neighbor[dir] = neighbor[dir], neighbor[zero_idx]\n                neighbor = \"\".join(neighbor)\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    q.append(neighbor)\n        res += 1\n    return -1", "def rotatedDigits(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if isGood(i):\n            count += 1\n    return count\n\ndef isGood(num: int) -> bool:\n    changed = False\n    while num:\n        digit = num % 10\n        if digit in (3, 4, 7):\n            return False\n        if digit in (2, 5, 6, 9):\n            changed = True\n        num //= 10\n    return changed", "import heapq\n\nclass KthLargest:\n\n    def __init__(self, k, nums):\n        self.heap = []\n        self.k = k\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        heapq.heappush(self.heap, val)\n        if len(self.heap) > self.k:\n            heapq.heappop(self.heap)\n        return self.heap[0]", "def is_ideal_permutation(nums):\n    for i, num in enumerate(nums):\n        if abs(num - i) > 1:\n            return False\n    return True", "def customSortString(order, s):\n    priority = {char: idx for idx, char in enumerate(order)}\n    return \"\".join(sorted(s, key=lambda x: priority.get(x, 0)))", "def search(nums, target):\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "def canTransform(start: str, end: str) -> bool:\n    if len(start) != len(end): return False\n\n    i, j = 0, 0\n    n = len(start)\n    while i < n and j < n:\n        while i < n and start[i] == 'X': i += 1\n        while j < n and end[j] == 'X': j += 1\n\n        if start[i] != end[j]: return False\n\n        if (start[i] == 'R' and i > j) or (start[i] == 'L' and i < j): return False\n\n        i += 1; j += 1\n    return True", "import heapq\n\ndef swim(n, grid):\n    pq = [(grid[0][0], 0, 0)]\n    visited = [[False] * n for _ in range(n)]\n\n    dr = [-1, 0, 1, 0]\n    dc = [0, 1, 0, -1]\n\n    while pq:\n        curT, curR, curC = heapq.heappop(pq)\n\n        if curR == n - 1 and curC == n - 1:\n            return curT\n\n        for d in range(4):\n            newRow, newCol = curR + dr[d], curC + dc[d]\n            if 0 <= newRow < n and 0 <= newCol < n and not visited[newRow][newCol]:\n                visited[newRow][newCol] = True\n                heapq.heappush(pq, (max(curT, grid[newRow][newCol]), newRow, newCol))\n\n    return -1", "def kthSymbolInGrammar(n, k):\n    if n == 1:\n        return 0\n    if k % 2 == 0:\n        return 1 - kthSymbolInGrammar(n - 1, k // 2)\n    else:\n        return kthSymbolInGrammar(n - 1, (k + 1) // 2)", "def can_transform(sx, sy, tx, ty):\n    while sx != tx or sy != ty:\n        if sx > tx or sy > ty:\n            return False\n        if sx < tx:\n            tx -= ty\n        else:\n            ty -= sx\n    return True", "from collections import defaultdict\ndef numRabbits(answers):\n    count = defaultdict(int)\n    res = 0\n    for a in answers:\n        count[a] += 1\n        if count[a] == 1:\n            res += (a + 1)\n        elif count[a] > a + 1:\n            count[a] = 1\n            res += (a + 1)\n    return res", "def moves_to_chessboard(board):\n    N = len(board)\n    row, col = 0, 0\n    row_count, col_count = 0, 0\n\n    for i in range(N):\n        for j in range(N):\n            if (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]) != 0:\n                return -1\n\n    for i in range(N):\n        row ^= board[0][i]\n        col ^= board[i][0]\n        row_count += 1 if board[0][i] == 1 else 0\n        col_count += 1 if board[i][0] == 1 else 0\n\n    if row != 0 and row_count * 2 != N:\n        return -1\n    if col != 0 and col_count * 2 != N:\n        return -1\n\n    if N % 2 == 1:\n        if row_count % 2 == 1:\n            row_count = N - row_count\n        if col_count % 2 == 1:\n            col_count = N - col_count\n    else:\n        row_count = min(row_count, N - row_count)\n        col_count = min(col_count, N - col_count)\n\n    return (row_count + col_count) // 2", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def __init__(self):\n        self.min_diff = float(\"inf\")\n        self.prev = None\n\n    def minDiffInBST(self, root: TreeNode) -> int:\n        self.in_order_traversal(root)\n        return self.min_diff\n\n    def in_order_traversal(self, node: TreeNode) -> None:\n        if not node: return\n        self.in_order_traversal(node.left)\n        if self.prev:\n            self.min_diff = min(self.min_diff, node.val - self.prev.val)\n        self.prev = node\n        self.in_order_traversal(node.right)", "def letterCasePermutation(s):\n    def backtrack(index):\n        if index == len(s):\n            result.append(\"\".join(s))\n            return\n        backtrack(index + 1)\n        if s[index].isalpha():\n            s[index] = s[index].swapcase()\n            backtrack(index + 1)\n            s[index] = s[index].swapcase()\n\n    result = []\n    s = list(s)\n    backtrack(0)\n    return result", "from collections import deque\n\ndef isBipartite(graph):\n    colors = [0] * len(graph)\n    for i in range(len(graph)):\n        if colors[i] != 0:\n            continue\n        colors[i] = 1\n        queue = deque([i])\n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if colors[neighbor] == 0:\n                    colors[neighbor] = -colors[node]\n                    queue.append(neighbor)\n                elif colors[neighbor] == colors[node]:\n                    return False\n    return True", "import heapq\n\ndef kthSmallestPrimeFraction(arr, k):\n    pq = [(-arr[i] / arr[-1], i, len(arr) - 1) for i in range(len(arr) - 1)]\n\n    heapq.heapify(pq)\n\n    for _ in range(k - 1):\n        frac, i, j = heapq.heappop(pq)\n        j -= 1\n        if i < j:\n            heapq.heappush(pq, (-arr[i] / arr[j], i, j))\n\n    frac, i, j = heapq.heappop(pq)\n    return [arr[i], arr[j]]", "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k):\n    graph = [[] for _ in range(n)]\n    for flight in flights:\n        graph[flight[0]].append((flight[1], flight[2]))\n\n    pq = [(0, src, k + 1)]\n    while pq:\n        price, city, stops = heapq.heappop(pq)\n\n        if city == dst:\n            return price\n\n        if stops > 0:\n            for nei, prc in graph[city]:\n                heapq.heappush(pq, (price + prc, nei, stops - 1))\n\n    return -1", "def rotated_digits(n):\n    count = 0\n    for i in range(1, n + 1):\n        is_valid_after_rotation = True\n        is_different_after_rotation = False\n        num = i\n        while num:\n            digit = num % 10\n            if digit in {3, 4, 7}:\n                is_valid_after_rotation = False\n                break\n            if digit in {2, 5, 6, 9}:\n                is_different_after_rotation = True\n            num //= 10\n        if is_valid_after_rotation and is_different_after_rotation:\n            count += 1\n    return count", "from typing import List\n\ndef escape_ghosts(ghosts: List[List[int]], target: List[int]) -> bool:\n    max_dist = abs(target[0]) + abs(target[1])\n    for ghost in ghosts:\n        ghost_dist = abs(ghost[0] - target[0]) + abs(ghost[1] - target[1])\n        if ghost_dist <= max_dist:\n            return False\n    return True", "def numberOfWays(n):\n    MOD = 1000000007\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD\n\n    return dp[n]", "def custom_sort_string(order, s):\n    return ''.join(sorted(s, key=lambda x: order.index(x) if x in order else len(order)))", "from bisect import bisect_left\nfrom collections import defaultdict\n\ndef numMatchingSubseq(s, words):\n    positions = defaultdict(list)\n\n    for i, c in enumerate(s):\n        positions[c].append(i)\n\n    count = 0\n\n    for word in words:\n        index = -1\n        isSubsequence = True\n\n        for c in word:\n            position_list = positions.get(c, [])\n            i = bisect_left(position_list, index + 1)\n            if (i == len(position_list)):\n                isSubsequence = False\n                break\n            index = position_list[i]\n\n        if isSubsequence:\n            count += 1\n\n    return count", "def num_zeros(k):\n    x = 0\n    i = 5\n    while k // i >= 1:\n        x += k // i\n        i *= 5\n    return x", "def valid_tic_tac_toe(board: List[str]) -> bool:\n    x_count = sum(row.count('X') for row in board)\n    o_count = sum(row.count('O') for row in board)\n    if x_count != o_count and x_count != o_count + 1: return False\n\n    x_win, o_win = False, False\n    for i in range(3):\n        if board[i][0] == board[i][1] == board[i][2] != ' ':\n            x_win, o_win = (True, o_win) if board[i][0] == 'X' else (x_win, True)\n        if board[0][i] == board[1][i] == board[2][i] != ' ':\n            x_win, o_win = (True, o_win) if board[0][i] == 'X' else (x_win, True)\n    if board[0][0] == board[1][1] == board[2][2] != ' ':\n        x_win, o_win = (True, o_win) if board[0][0] == 'X' else (x_win, True)\n    if board[0][2] == board[1][1] == board[2][0] != ' ':\n        x_win, o_win = (True, o_win) if board[0][2] == 'X' else (x_win, True)\n\n    if x_win and o_win: return False\n    if x_win and x_count == o_count: return False\n    if o_win and x_count > o_count: return False\n\n    return True", "def numSubarrayBoundedMax(nums, left, right):\n    result, prev, start = 0, 0, -1\n    for i, num in enumerate(nums):\n        if left <= num <= right:\n            prev = i - start\n            result += prev\n        elif num < left:\n            result += prev\n        else:\n            start = i\n            prev = 0\n    return result", "def is_shifted(s, goal):\n    if len(s) != len(goal): return False\n\n    s = s + s\n    return goal in s", "from typing import List\n\ndef allPathsSourceTarget(graph: List[List[int]]) -> List[List[int]]:\n    def DFS(currentNode, path):\n        path.append(currentNode)\n        if currentNode == len(graph) - 1:\n            result.append(path[:])\n        else:\n            for neighbor in graph[currentNode]:\n                DFS(neighbor, path)\n        path.pop()\n\n    result = []\n    DFS(0, [])\n    return result", "def best_rotation(nums):\n    n = len(nums)\n    change = [0] * n\n\n    for i in range(n):\n        change[(i - nums[i] + 1 + n) % n] -= 1\n        change[(i + 1) % n] += 1\n\n    max_score = 0\n    cur_score = change[0]\n    for i in range(1, n):\n        cur_score += change[i]\n        if cur_score > max_score:\n            max_score = cur_score\n            \n    return max_score", "from collections import defaultdict, deque\n\ndef numBusesToDestination(routes, source, target):\n    if source == target:\n        return 0\n\n    stop_route_map = defaultdict(set)\n    for i, route in enumerate(routes):\n        for stop in route:\n            stop_route_map[stop].add(i)\n\n    queue = deque([source])\n    visited_sources = {source}\n\n    transfers = 0\n    while queue:\n        size = len(queue)\n        for _ in range(size):\n            curr = queue.popleft()\n            if curr == target:\n                return transfers\n\n            for route in stop_route_map[curr]:\n                for stop in routes[route]:\n                    if stop not in visited_sources:\n                        queue.append(stop)\n                        visited_sources.add(stop)\n                stop_route_map[curr].remove(route)\n        transfers += 1\n    return -1", "class MyHashSet:\n\n    def __init__(self):\n        self.storage = [False] * 1000001\n\n    def add(self, key: int):\n        self.storage[key] = True\n\n    def remove(self, key: int):\n        self.storage[key] = False\n\n    def contains(self, key: int) -> bool:\n        return self.storage[key]", "class MyHashMap:\n\n    def __init__(self):\n        self.data = [-1] * 1000001\n\n    def put(self, key: int, value: int) -> None:\n        self.data[key] = value\n\n    def get(self, key: int) -> int:\n        return self.data[key]\n\n    def remove(self, key: int) -> None:\n        self.data[key] = -1", "def racecar(target: int) -> int:\n    memo = {}\n    def dp(position, speed):\n        if abs(position) > 2 * target:\n            return target + 1\n        if position == target:\n            return 0 if speed == 1 else 1\n        if (position, speed) in memo:\n            return memo[(position, speed)]\n        \n        ans = dp(position + speed // 2, -speed // 2) + 1 if speed > 0 else dp(position - speed // 2, -speed // 2) + 1\n        ans = min(ans, dp(position + speed, speed * 2) + 1)\n        memo[(position, speed)] = ans\n        return ans\n    \n    return dp(0, 1)", "def minSwaps(nums1, nums2):\n    n = len(nums1)\n    noSwap = [float('inf')] * n\n    doSwap = [float('inf')] * n\n    noSwap[0] = 0\n    doSwap[0] = 1\n\n    for i in range(1, n):\n        if nums1[i] > nums1[i - 1] and nums2[i] > nums2[i - 1]:\n            noSwap[i] = noSwap[i - 1]\n            doSwap[i] = doSwap[i - 1] + 1\n        if nums1[i] > nums2[i - 1] and nums2[i] > nums1[i - 1]:\n            noSwap[i] = min(noSwap[i], doSwap[i - 1])\n            doSwap[i] = min(doSwap[i], noSwap[i - 1] + 1)\n\n    return min(noSwap[n - 1], doSwap[n - 1])", "from typing import List\n\ndef eventualSafeNodes(graph: List[List[int]]) -> List[int]:\n    n = len(graph)\n    color = [0] * n\n    ans = []\n\n    def hasCycle(node: int, color: List[int], graph: List[List[int]]) -> bool:\n        if color[node] > 0:\n            return color[node] == 1\n        color[node] = 1\n        for neighbor in graph[node]:\n            if hasCycle(neighbor, color, graph):\n                return True\n        color[node] = 2\n        return False\n\n    for i in range(n):\n        if not hasCycle(i, color, graph):\n            ans.append(i)\n    return ans", "from typing import List\n\ndef hitBricks(grid: List[List[int]], hits: List[List[int]]) -> List[int]:\n    def dfs(x, y):\n        if not (0 <= x < m) or not (0 <= y < n) or grid[x][y] <= 0:\n            return 0\n        grid[x][y] = -1\n        return 1 + sum(dfs(x + dx, y + dy) for dx, dy in directions)\n\n    m, n = len(grid), len(grid[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    for x, y in hits:\n        grid[x][y] -= 1\n\n    for j in range(n):\n        if grid[0][j] == 1:\n            dfs(0, j)\n\n    result = []\n    for x, y in hits:\n        grid[x][y] += 1\n        if grid[x][y] != 1:\n            result.append(0)\n            continue\n        for dx, dy in directions:\n            if dfs(x + dx, y + dy) != 0:\n                result.append(dfs(x, y) - 1)\n                break\n        else:\n            result.append(0)\n\n    return result", "def uniqueMorseRepresentations(words):\n    morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n    transformations = set()\n\n    for word in words:\n        morseCode = ''.join(morse[ord(c) - ord('a')] for c in word)\n        transformations.add(morseCode)\n\n    return len(transformations)", "def isPossibleToSplit(nums):\n    n = len(nums)\n    total_sum = sum(nums)\n\n    if total_sum % n != 0:\n        return False\n\n    target_sum = total_sum * (n // 2) // n\n    dp = [[False] * (target_sum + 1) for _ in range(n // 2 + 1)]\n    dp[0][0] = True\n\n    for num in nums:\n        for count in range(n // 2, 0, -1):\n            for sum_ in range(target_sum, num - 1, -1):\n                dp[count][sum_] = dp[count][sum_] or dp[count - 1][sum_ - num]\n\n        if dp[n // 2][target_sum]:\n            return True\n\n    return False", "def number_of_lines(widths, s):\n    lines = 1\n    current_pixel = 0\n    for c in s:\n        letter_pixels = widths[ord(c) - ord('a')]\n        if current_pixel + letter_pixels > 100:\n            lines += 1\n            current_pixel = 0\n        current_pixel += letter_pixels\n    return [lines, current_pixel]", "def max_increase_keeping_skyline(grid):\n    n = len(grid)\n    row_max = [0] * n\n    col_max = [0] * n\n    \n    for i in range(n):\n        for j in range(n):\n            row_max[i] = max(row_max[i], grid[i][j])\n            col_max[j] = max(col_max[j], grid[i][j])\n    \n    total_sum = 0\n    for i in range(n):\n        for j in range(n):\n            total_sum += min(row_max[i], col_max[j]) - grid[i][j]\n    \n    return total_sum", "def maxProfitAssignment(difficulty, profit, worker):\n    n = len(difficulty)\n    jobs = sorted(zip(difficulty, profit))\n    worker.sort()\n\n    max_profit = 0\n    total_profit = 0\n    job_idx = 0\n\n    for w in worker:\n        while job_idx < n and w >= jobs[job_idx][0]:\n            max_profit = max(max_profit, jobs[job_idx][1])\n            job_idx += 1\n        total_profit += max_profit\n\n    return total_profit", "def maxAreaOfIsland(grid):\n    def dfs(x, y):\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0:\n            return 0\n        grid[x][y] = 0\n        return dfs(x - 1, y) + dfs(x + 1, y) + dfs(x, y - 1) + dfs(x, y + 1) + 1\n\n    ans = 0\n    for i, row in enumerate(grid):\n        for j, cell in enumerate(row):\n            if cell == 0:\n                grid[i][j] = 1\n                ans = max(ans, dfs(i, j))\n                grid[i][j] = 0\n    return ans", "def xor_game(nums: List[int]) -> bool:\n    xor_sum = 0\n    for num in nums:\n        xor_sum ^= num\n    return xor_sum == 0 or len(nums) % 2 == 0", "from collections import defaultdict\n\ndef subdomainVisits(cpdomains):\n    counts = defaultdict(int)\n    result = []\n\n    for cpdomain in cpdomains:\n        count, domain = cpdomain.split()\n        count = int(count)\n\n        for i in range(len(domain)):\n            if domain[i] == '.':\n                counts[domain[i + 1:]] += count\n        counts[domain] += count\n\n    for sub, cnt in counts.items():\n        result.append(f\"{cnt} {sub}\")\n        \n    return result", "from itertools import combinations\n\ndef largestTriangleArea(points):\n    return max(0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) for (x1, y1), (x2, y2), (x3, y3) in combinations(points, 3))", "class Solution:\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\n        memo = {}\n        \n        def max_partition_sum(start: int, k: int) -> float:\n            if k == 1:\n                return sum(nums[start:]) / (len(nums) - start)\n            if (start, k) in memo:\n                return memo[start, k]\n            \n            ans, curr_sum = 0, 0\n            for i in range(start, len(nums) - k + 1):\n                curr_sum += nums[i]\n                ans = max(ans, curr_sum / (i - start + 1) + max_partition_sum(i + 1, k - 1))\n            \n            memo[start, k] = ans\n            return ans\n        \n        return max_partition_sum(0, k)", "def pruneTree(root: TreeNode) -> TreeNode:\n    if not root:\n        return None\n    root.left = pruneTree(root.left)\n    root.right = pruneTree(root.right)\n    if root.val == 0 and not root.left and not root.right:\n        return None\n    return root", "from collections import defaultdict\nfrom queue import Queue\n\ndef numBusesToDestination(routes, source, target):\n    if source == target:\n        return 0\n\n    stop_to_buses = defaultdict(set)\n    for i, route in enumerate(routes):\n        for stop in route:\n            stop_to_buses[stop].add(i)\n\n    q = Queue()\n    visited_buses = set()\n    num_buses = 0\n    q.put(source)\n\n    while not q.empty():\n        size = q.qsize()\n        for _ in range(size):\n            stop = q.get()\n            for bus in stop_to_buses[stop]:\n                if bus in visited_buses:\n                    continue\n                visited_buses.add(bus)\n                for next_stop in routes[bus]:\n                    if next_stop == target:\n                        return num_buses + 1\n                    q.put(next_stop)\n        num_buses += 1\n\n    return -1", "def ambiguousCoordinates(s):\n    def generateNumber(s):\n        if not s or (len(s) > 1 and s[0] == '0' and s[-1] == '0'):\n            return []\n        if len(s) > 1 and s[0] == '0':\n            return [\"0.\" + s[1:]]\n        res = [s]\n        if len(s) == 1 or s[-1] == '0':\n            return res\n        for i in range(1, len(s)):\n            res.append(s[:i] + \".\" + s[i:])\n        return res\n\n    n = len(s)\n    res = []\n    \n    for i in range(2, n - 1):\n        first = generateNumber(s[1:i])\n        second = generateNumber(s[i:n - 1])\n        \n        for f in first:\n            for sec in second:\n                res.append(\"(\" + f + \", \" + sec + \")\")\n    \n    return res", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef numComponents(head: ListNode, nums: List[int]) -> int:\n    num_set = set(nums)\n    result = 0\n    connected = False\n\n    while head:\n        if head.val in num_set:\n            if not connected:\n                connected = True\n                result += 1\n        else:\n            connected = False\n        head = head.next\n\n    return result", "def racecar(target: int) -> int:\n    memo = {}\n\n    def dp(pos: int, speed: int) -> int:\n        if pos == target:\n            return 0\n        if abs(pos) > 2 * target:\n            return float('inf')\n\n        key = (pos, speed)\n        if key in memo:\n            return memo[key]\n\n        op1 = dp(pos + speed, speed * 2) + 1\n        op2 = dp(pos, -speed) + 2\n\n        ans = min(op1, op2)\n        memo[key] = ans\n        return ans\n\n    return dp(0, 1)", "def mostCommonWord(paragraph: str, banned: List[str]):\n    word_count = {}\n    banned_set = {ban.lower() for ban in banned}\n\n    for word in paragraph.lower().split():\n        cleaned_word = ''.join(c for c in word if c.isalpha())\n        if cleaned_word not in banned_set:\n            word_count[cleaned_word] = word_count.get(cleaned_word, 0) + 1\n\n    return max(word_count, key=word_count.get)", "def pushDominoes(dominoes: str) -> str:\n    n = len(dominoes)\n    forces = [0] * n\n    \n    force = 0\n    for i in range(n):\n        if dominoes[i] == 'R':\n            force = n\n        elif dominoes[i] == 'L':\n            force = 0\n        else:\n            force = max(force - 1, 0)\n        forces[i] += force\n    \n    force = 0\n    for i in range(n - 1, -1, -1):\n        if dominoes[i] == 'L':\n            force = n\n        elif dominoes[i] == 'R':\n            force = 0\n        else:\n            force = max(force - 1, 0)\n        forces[i] -= force\n    \n    return \"\".join(['R' if f > 0 else 'L' if f < 0 else '.' for f in forces])", "def minimal_length_encoding(words):\n    word_set = set(words)\n\n    for word in words:\n        for i in range(1, len(word)):\n            word_set.discard(word[i:])\n\n    return sum(len(word) + 1 for word in word_set)", "def numMagicSquaresInside(grid):\n    count = 0\n    for i in range(len(grid) - 2):\n        for j in range(len(grid[0]) - 2):\n            if grid[i][j] <= 9 and grid[i + 1][j + 1] == 5 and isMagic(grid, i, j):\n                count += 1\n    return count\n\n\ndef isMagic(grid, x, y):\n    temp = [0] * 16\n    for i in range(3):\n        for j in range(3):\n            num = grid[x + i][y + j]\n            temp[num] += 1\n            if num > 9 or temp[num] > 1:\n                return False\n\n    _sum = grid[x][y] + grid[x][y+1] + grid[x][y+2]\n    for i in range(3):\n        row_sum, col_sum = 0, 0\n        for j in range(3):\n            row_sum += grid[x + i][y + j]\n            col_sum += grid[x + j][y + i]\n        if row_sum != _sum or col_sum != _sum:\n            return False\n\n    if grid[x][y] + grid[x + 1][y + 1] + grid[x + 2][y + 2] != _sum:\n        return False\n    if grid[x][y + 2] + grid[x + 1][y + 1] + grid[x + 2][y] != _sum:\n        return False\n\n    return True", "def shortestToChar(s, c):\n    n = len(s)\n    result = [n for _ in range(n)]\n    pos = -n\n\n    for i in range(n):\n        if s[i] == c:\n            pos = i\n        result[i] = i - pos\n\n    for i in range(pos - 1, -1, -1):\n        if s[i] == c:\n            pos = i\n        result[i] = min(result[i], pos - i)\n\n    return result", "def smallest_good_integer(fronts, backs):\n    not_good = {fronts[i] for i in range(len(fronts)) if fronts[i] == backs[i]}\n\n    result = float('inf')\n    for i in range(len(fronts)):\n        if fronts[i] not in not_good:\n            result = min(result, fronts[i])\n        if backs[i] not in not_good:\n            result = min(result, backs[i])\n\n    return 0 if result == float('inf') else result", "def numFactoredBinaryTrees(arr):\n    MOD = 10**9 + 7\n    n = len(arr)\n    arr.sort()\n    dp = {}\n    for i, x in enumerate(arr):\n        dp[x] = 1\n        for y in arr[:i]:\n            if x % y == 0 and x // y in dp:\n                dp[x] = (dp[x] + dp[y] * dp[x // y]) % MOD\n    return sum(dp.values()) % MOD", "def backspaceCompare(s: str, t: str) -> bool:\n    i, j = len(s) - 1, len(t) - 1\n    while True:\n        back = 0\n        while i >= 0 and (back > 0 or s[i] == '#'):\n            back = back + 1 if s[i] == '#' else back - 1\n            i -= 1\n        back = 0\n        while j >= 0 and (back > 0 or t[j] == '#'):\n            back = back + 1 if t[j] == '#' else back - 1\n            j -= 1\n        if i >= 0 and j >= 0 and s[i] == t[j]:\n            i, j = i -1, j - 1\n        else:\n            return i == -1 and j == -1", "def longestMountain(arr):\n    n = len(arr)\n    res = up = down = 0\n\n    for i in range(1, n):\n        if (down and arr[i - 1] < arr[i]) or arr[i - 1] == arr[i]:\n            up = down = 0\n\n        up += arr[i - 1] < arr[i]\n        down += arr[i - 1] > arr[i]\n\n        if up and down:\n            res = max(res, up + down + 1)\n\n    return res", "from collections import Counter\n\ndef is_possible_divide(hand, group_size):\n    card_count = Counter(hand)\n\n    for card in sorted(card_count):\n        if card_count[card] > 0:\n            count = card_count[card]\n            for i in range(1, group_size):\n                if card_count[card + i] < count:\n                    return False\n                card_count[card + i] -= count\n\n    return True", "from collections import deque\n\ndef shortestPathLength(graph):\n    n = len(graph)\n    queue = deque([(i, 1 << i, 0) for i in range(n)])\n    visited = [[False] * (1 << n) for _ in range(n)]\n\n    for i in range(n):\n        visited[i][1 << i] = True\n\n    while queue:\n        node, bitmask, length = queue.popleft()\n\n        if bitmask == (1 << n) - 1:\n            return length\n\n        for nei in graph[node]:\n            next_bitmask = bitmask | (1 << nei)\n            if not visited[nei][next_bitmask]:\n                visited[nei][next_bitmask] = True\n                queue.append((nei, next_bitmask, length + 1))\n\n    return 0", "def shiftingLetters(s: str, shifts) -> str:\n    for i in range(len(shifts) - 2, -1, -1):\n        shifts[i] += shifts[i + 1] % 26\n\n    result = list(s)\n    for i in range(len(s)):\n        result[i] = chr((ord(result[i]) - ord('a') + shifts[i] % 26) % 26 + ord('a'))\n        \n    return \"\".join(result)", "def maxDistToClosest(seats):\n    n = len(seats)\n    maxDist = 0\n    lastPerson = -1\n\n    for i in range(n):\n        if seats[i] == 1:\n            if lastPerson == -1:\n                maxDist = i\n            else:\n                maxDist = max(maxDist, (i - lastPerson) // 2)\n            lastPerson = i\n\n    maxDist = max(maxDist, n - 1 - lastPerson)\n    return maxDist", "def rectangleArea(rectangles):\n    mod = 10**9 + 7\n    n = len(rectangles)\n    X, Y = set(), set()\n    for rect in rectangles:\n        X.add(rect[0])\n        X.add(rect[2])\n        Y.add(rect[1])\n        Y.add(rect[3])\n    sorted_x = sorted(X)\n    sorted_y = sorted(Y)\n    cnt = [[0 for _ in range(len(Y) - 1)] for _ in range(len(X) - 1)]\n\n    for rect in rectangles:\n        x1_idx = sorted_x.index(rect[0])\n        x2_idx = sorted_x.index(rect[2]) - 1\n        y1_idx = sorted_y.index(rect[1])\n        y2_idx = sorted_y.index(rect[3]) - 1\n        for i in range(x1_idx, x2_idx + 1):\n            for j in range(y1_idx, y2_idx + 1):\n                cnt[i][j] = 1\n\n    total_area = 0\n    for i in range(len(X) - 1):\n        for j in range(len(Y) - 1):\n            if cnt[i][j]:\n                total_area += (sorted_x[i + 1] - sorted_x[i]) * (sorted_y[j + 1] - sorted_y[j])\n                total_area %= mod\n\n    return total_area", "def to_goat_latin(sentence: str) -> str:\n    words = sentence.split()\n    vowels = set(\"AEIOUaeiou\")\n    result = []\n\n    for i, word in enumerate(words):\n        if word[0] not in vowels:\n            word = word[1:] + word[0]\n        result.append(word + \"ma\" + \"a\" * (i + 1))\n\n    return ' '.join(result)", "def numFriendRequests(ages):\n    count = [0] * 121\n    total_requests = 0\n\n    for age in ages:\n        count[age] += 1\n\n    for a in range(1, 121):\n        for b in range(1, 121):\n            if a * 0.5 + 7 >= b:\n                continue\n            if a < b:\n                continue\n            if a < b * 2:\n                total_requests += count[a] * count[b]\n                if a == b:\n                    total_requests -= count[a]\n\n    return total_requests", "def max_profit_assignment(difficulty, profit, worker):\n    jobs = sorted(zip(difficulty, profit))\n    worker.sort()\n\n    i, max_profit, total_profit = 0, 0, 0\n    for ability in worker:\n        while i < len(difficulty) and ability >= jobs[i][0]:\n            max_profit = max(max_profit, jobs[i][1])\n            i += 1\n        total_profit += max_profit\n    return total_profit", "def kSimilarity(s1: str, s2: str) -> int:\n    k = 0\n    temp = list(s1)\n\n    for i in range(len(temp)):\n        if temp[i] != s2[i]:\n            j = i + 1\n            while temp[j] != s2[i] or s2[j] == temp[j]:\n                j += 1\n            temp[i], temp[j] = temp[j], temp[i]\n            k += 1\n\n    return k", "def count_unique_chars(s):\n    return len(set(s))\n\ndef sum_count_unique_chars(s):\n    sum = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            sum += count_unique_chars(s[i:j])\n    return sum", "def consecutive_numbers_sum(n: int) -> int:\n    count = 0\n    i = 1\n    while i * (i - 1) // 2 < n:\n        if (n - i * (i - 1) // 2) % i == 0:\n            count += 1\n        i += 1\n    return count", "def largeGroupPositions(s: str):\n    result = []\n    start = 0\n    for i in range(1, len(s)):\n        if s[i] != s[start]:\n            if i - start >= 3:\n                result.append([start, i - 1])\n            start = i\n    if len(s) - start >= 3:\n        result.append([start, len(s) - 1])\n    return result", "def mask_information(s: str) -> str:\n    if '@' in s:\n        s = s.lower()\n        return s[0] + \"*****\" + s[s.index('@') - 1:]\n    else:\n        digits = \"\".join(filter(str.isdigit, s))\n        if len(digits) == 10:\n            return \"***-***-\" + digits[-4:]\n        prefix = \"*\"* (len(digits) - 10) + \"-\"\n        return \"+\" + prefix + \"***-***-\" + digits[-4:]", "class MyCircularQueue:\n\n    def __init__(self, k: int):\n        self.data = [0] * k\n        self.head = 0\n        self.tail = -1\n        self.size = 0\n        self.capacity = k\n\n    def enQueue(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        self.tail = (self.tail + 1) % self.capacity\n        self.data[self.tail] = value\n        self.size += 1\n        return True\n\n    def deQueue(self) -> bool:\n        if self.isEmpty():\n            return False\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return True\n\n    def Front(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.data[self.head]\n\n    def Rear(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.data[self.tail]\n\n    def isEmpty(self) -> bool:\n        return self.size == 0\n\n    def isFull(self) -> bool:\n        return self.size == self.capacity", "def flipAndInvertImage(image):\n    for row in image:\n        row.reverse()\n        for j in range(len(row)):\n            row[j] = 1 - row[j]\n    return image", "def findReplaceString(s, indices, sources, targets):\n    index_mapping = sorted(\n        [(indices[i], i) for i in range(len(indices)) if s.startswith(sources[i], indices[i])]\n    )\n    result = []\n    last_idx = 0\n\n    for idx, i in index_mapping:\n        result.append(s[last_idx:idx])\n        result.append(targets[i])\n        last_idx = idx + len(sources[i])\n\n    result.append(s[last_idx:])\n    return \"\".join(result)", "from collections import defaultdict\n\ndef sumOfDistancesInTree(n, edges):\n    tree = defaultdict(set)\n    for u, v in edges:\n        tree[u].add(v)\n        tree[v].add(u)\n\n    count = [1] * n\n    res = [0] * n\n\n    def dfs(node, parent):\n        for child in tree[node]:\n            if child != parent:\n                dfs(child, node)\n                count[node] += count[child]\n                res[node] += res[child] + count[child]\n\n    def dfs2(node, parent):\n        for child in tree[node]:\n            if child != parent:\n                res[child] = res[node] - count[child] + n - count[child]\n                dfs2(child, node)\n\n    dfs(0, -1)\n    dfs2(0, -1)\n\n    return res", "def largestOverlap(img1, img2):\n    n = len(img1)\n    onesImg1 = [(i, j) for i in range(n) for j in range(n) if img1[i][j]]\n    onesImg2 = [(i, j) for i in range(n) for j in range(n) if img2[i][j]]\n\n    overlaps = {}\n    for pt1 in onesImg1:\n        for pt2 in onesImg2:\n            dx, dy = pt2[0] - pt1[0], pt2[1] - pt1[1]\n            key = (dx, dy)\n            if key not in overlaps:\n                overlaps[key] = 0\n            overlaps[key] += 1\n\n    return max(overlaps.values() or [0])", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:\n        def find_deepest(node):\n            if not node:\n                return None, 0\n            left, left_height = find_deepest(node.left)\n            right, right_height = find_deepest(node.right)\n            if left_height == right_height:\n                return node, left_height + 1\n            return (left, left_height + 1) if left_height > right_height else (right, right_height + 1)\n\n        return find_deepest(root)[0]", "def isRectangleOverlap(rec1, rec2):\n    return rec1[2] > rec2[0] and rec1[3] > rec2[1] and rec1[0] < rec2[2] and rec1[1] < rec2[3]", "def new21Game(n: int, k: int, maxPts: int) -> float:\n    if k == 0 or n >= k + maxPts:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    s, ans = 1, 0\n\n    for i in range(1, n + 1):\n        dp[i] = s / maxPts\n        if i < k:\n            s += dp[i]\n        else:\n            ans += dp[i]\n        if i >= maxPts:\n            s -= dp[i - maxPts]\n\n    return ans", "def push_dominoes(dominoes: str) -> str:\n    prev, cur = None, dominoes\n    while prev != cur:\n        prev = cur\n        cur_lst = list(prev)\n        for i in range(len(cur)):\n            if prev[i] == 'L' and i > 0 and prev[i - 1] == '.':\n                cur_lst[i - 1] = 'L'\n            elif prev[i] == 'R' and i < len(cur) - 1 and prev[i + 1] == '.':\n                cur_lst[i + 1] = 'R'\n        cur = ''.join(cur_lst)\n    return cur", "def is_similar(a: str, b: str) -> bool:\n    diff_count = 0\n    for char_a, char_b in zip(a, b):\n        if char_a != char_b:\n            diff_count += 1\n            if diff_count > 2:\n                return False\n    return True\n\ndef count_groups(strs: list[str]) -> int:\n    count = 0\n    visited = [False] * len(strs)\n    for i in range(len(strs)):\n        if not visited[i]:\n            count += 1\n            visited[i] = True\n            for j in range(i + 1, len(strs)):\n                if is_similar(strs[i], strs[j]):\n                    visited[j] = True\n    return count", "from sortedcontainers import SortedList\n\ndef advantage_count(nums1, nums2):\n    nums1_sorted = SortedList(nums1)\n    result = []\n    for num in nums2:\n        index = nums1_sorted.bisect_right(num)\n        if index == len(nums1_sorted):\n            val = nums1_sorted.pop(0)\n        else:\n            val = nums1_sorted.pop(index)\n        result.append(val)\n    return result", "def can_visit_all_rooms(rooms):\n    visited = set()\n    stack = [0]\n\n    while stack:\n        current_room = stack.pop()\n\n        visited.add(current_room)\n\n        for key in rooms[current_room]:\n            if key not in visited:\n                stack.append(key)\n\n    return len(visited) == len(rooms)", "def splitIntoFibonacci(num):\n    ans = []\n    def backtrack(index, prev1, prev2):\n        if index == len(num):\n            return len(ans) >= 3\n        curr = 0\n        for i in range(index, len(num)):\n            if i > index and num[index] == '0':\n                break\n            curr = curr * 10 + ord(num[i]) - ord('0')\n            if curr > 2**31 - 1:\n                break\n            if len(ans) >= 2:\n                if curr < prev1 + prev2:\n                    continue\n                elif curr > prev1 + prev2:\n                    break\n            ans.append(curr)\n            if backtrack(i + 1, prev2, curr):\n                return True\n            ans.pop()\n        return False\n            \n    backtrack(0, 0, 0)\n    return ans", "import random\n\ndef match(a, b):\n    return sum(a[i] == b[i] for i in range(6))\n\ndef find_secret_word(wordlist, master):\n    for _ in range(10):\n        guess = random.choice(wordlist)\n        match_cnt = master.guess(guess)\n        if match_cnt == 6:\n            return\n        wordlist = [word for word in wordlist if match(word, guess) == match_cnt]", "def backspace_compare(s, t):\n    def process_backspaces(string):\n        stack = []\n        for c in string:\n            if c != '#':\n                stack.append(c)\n            elif stack:\n                stack.pop()\n        return stack\n\n    return process_backspaces(s) == process_backspaces(t)", "def longest_mountain(arr):\n    n = len(arr)\n    max_length = 0\n    i = 1\n    while i < n - 1:\n        if arr[i - 1] < arr[i] and arr[i] > arr[i + 1]:\n            left = i - 1\n            right = i + 1\n            while left > 0 and arr[left - 1] < arr[left]:\n                left -= 1\n            while right < n - 1 and arr[right] > arr[right + 1]:\n                right += 1\n            max_length = max(max_length, right - left + 1)\n            i = right\n        else:\n            i += 1\n    return max_length", "from collections import Counter\n\ndef is_n_straight_hand(hand, group_size):\n    counts = Counter(hand)\n\n    for card in sorted(counts):\n        if counts[card] > 0:\n            for i in range(group_size - 1, -1, -1):\n                if counts[card + i] < counts[card]:\n                    return False\n                counts[card + i] -= counts[card]\n\n    return True", "from collections import deque, defaultdict\n\ndef shortestPathLength(graph):\n    n = len(graph)\n    q = deque()\n    \n    for i in range(n):\n        q.append((i, 1 << i))\n    steps = -1\n    visited = {i: set() for i in range(n)}\n    \n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            currNode, currVisits = q.popleft()\n            \n            if bin(currVisits).count('1') == n:\n                return steps\n\n            for nextNode in graph[currNode]:\n                nextVisits = currVisits | (1 << nextNode)\n\n                if nextVisits not in visited[nextNode]:\n                    visited[nextNode].add(nextVisits)\n                    q.append((nextNode, nextVisits))\n\n    return -1", "def shiftingLetters(s: str, shifts: list[int]) -> str:\n    n = len(s)\n    for i in range(n - 2, -1, -1):\n        shifts[i] = (shifts[i] + shifts[i + 1]) % 26\n    \n    result = []\n    for i in range(n):\n        result.append(chr(((ord(s[i]) - ord('a')) + shifts[i]) % 26 + ord('a')))\n    \n    return \"\".join(result)", "def max_dist_to_closest(seats):\n    max_dist = 0\n    last_person = -1\n    for i, seat in enumerate(seats):\n        if seat == 1:\n            max_dist = i if last_person < 0 else max(max_dist, (i - last_person) // 2)\n            last_person = i\n    return max(max_dist, len(seats) - 1 - last_person)", "def rectangleArea(rectangles):\n    mod = 10**9 + 7\n    X = sorted(set(x for rect in rectangles for x in rect[::2]))\n    Xdict = {x:i for i,x in enumerate(X)}\n\n    events = []\n    for x1,y1,x2,y2 in rectangles:\n        events.append((Xdict[x1], 1, y1, y2))\n        events.append((Xdict[x2], -1, y1, y2))\n    events.sort()\n\n    area = 0\n    cnt = [0] * len(X)\n    active = 0\n    for idx, type, y1, y2 in events:\n        area = (area + (X[idx+1] - X[idx]) * active % mod) % mod\n        cnt[y1] += type\n        cnt[y2] -= type\n        active = sum(p for j,p in zip(X, cnt) if p)\n\n    return area", "from collections import defaultdict\n\ndef loudAndRich(richer, quiet):\n    n = len(quiet)\n    graph = defaultdict(list)\n    for r in richer:\n        graph[r[1]].append(r[0])\n\n    answer = [-1] * n\n\n    def dfs(x):\n        if answer[x] != -1:\n            return answer[x]\n        answer[x] = x\n        for y in graph[x]:\n            cand = dfs(y)\n            if quiet[cand] < quiet[answer[x]]:\n                answer[x] = cand\n        return answer[x]\n\n    for i in range(n):\n        dfs(i)\n\n    return answer", "def peakIndexInMountainArray(arr):\n    low, high = 0, len(arr) - 1\n    while low < high:\n        mid = low + (high - low) // 2\n        if arr[mid] < arr[mid + 1]:\n            low = mid + 1\n        else:\n            high = mid\n    return low", "def carFleet(target: int, position: List[int], speed: List[int]) -> int:\n    cars = sorted(zip(position, speed), reverse=True)\n    fleets = 0\n    last_arrival = -1\n\n    for pos, sp in cars:\n        arrival = (target - pos) / sp\n        if arrival > last_arrival:\n            fleets += 1\n            last_arrival = arrival\n\n    return fleets", "def k_similarity(s1, s2):\n    k = 0\n    a, b = list(s1), list(s2)\n    for i in range(len(a)):\n        if a[i] != b[i]:\n            for j in range(i + 1, len(b)):\n                if a[i] == b[j] and a[j] != b[j]:\n                    a[i], a[j] = a[j], a[i]\n                    k += 1\n                    break\n    return k", "from bisect import bisect_left, insort_left\n\nclass ExamRoom:\n\n    def __init__(self, n: int):\n        self.students = []\n        self.n = n\n\n    def seat(self) -> int:\n        if not self.students:\n            seat_index = 0\n        else:\n            distance, seat_index = self.students[0], 0\n            \n            for i in range(1, len(self.students)):\n                d = (self.students[i] - self.students[i - 1]) // 2\n                if d > distance:\n                    distance = d\n                    seat_index = self.students[i - 1] + d\n                    \n            if self.n - 1 - self.students[-1] > distance:\n                seat_index = self.n - 1\n                \n        insort_left(self.students, seat_index)\n        return seat_index\n\n    def leave(self, p: int) -> None:\n        index = bisect_left(self.students, p)\n        self.students.pop(index)", "def scoreOfParentheses(s):\n    score, depth = 0, 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            depth += 1\n        else:\n            depth -= 1\n            if s[i - 1] == '(':\n                score += 1 << depth\n    return score", "import heapq\n\ndef mincost_to_hire_workers(quality, wage, k):\n    workers = sorted((w / q, q) for w, q in zip(wage, quality))\n    total_quality = 0\n    max_heap = []\n    result = float(\"inf\")\n\n    for ratio, q in workers:\n        heapq.heappush(max_heap, -q)\n        total_quality += q\n\n        if len(max_heap) > k:\n            total_quality += heapq.heappop(max_heap)\n\n        if len(max_heap) == k:\n            result = min(result, total_quality * ratio)\n\n    return result", "def mirrorReflection(p, q):\n    from math import gcd\n    m = p // gcd(p, q)\n\n    if m % 2 == 0:\n        return 2\n    if (q // gcd(p, q)) % 2 == 0:\n        return 0\n    return 1", "def are_almost_equal(s, goal):\n    if s == goal:\n        return True\n    count = 0\n    index1, index2 = -1, -1\n    for i in range(len(s)):\n        if s[i] != goal[i]:\n            count += 1\n            if index1 == -1:\n                index1 = i\n            else:\n                index2 = i\n            if count > 2:\n                return False\n    return count == 2 and s[index1] == goal[index2] and s[index2] == goal[index1]", "def lemonadeChange(bills):\n    five, ten = 0, 0\n    for bill in bills:\n        if bill == 5:\n            five += 1\n        elif bill == 10:\n            if not five:\n                return False\n            five -= 1\n            ten += 1\n        else:\n            if ten and five:\n                ten -= 1\n                five -= 1\n            elif five >= 3:\n                five -= 3\n            else:\n                return False\n    return True", "def matrixScore(grid):\n    m, n = len(grid), len(grid[0])\n    for i in range(m):\n        if grid[i][0] == 0:\n            for j in range(n):\n                grid[i][j] = 1 - grid[i][j]\n    for j in range(1, n):\n        count = sum(grid[i][j] for i in range(m))\n        if count <= m // 2:\n            for i in range(m):\n                grid[i][j] = 1 - grid[i][j]\n    return sum(sum(grid[i][j]*(1 << (n - 1 - j)) for j in range(n)) for i in range(m))", "from collections import deque\n\ndef shortest_subarray(nums, k):\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n\n    res = n + 1\n    dq = deque()\n    for i in range(n + 1):\n        while dq and prefix_sum[i] - prefix_sum[dq[0]] >= k:\n            res = min(res, i - dq.popleft())\n        while dq and prefix_sum[i] <= prefix_sum[dq[-1]]:\n            dq.pop()\n        dq.append(i)\n\n    return res if res <= n else -1", "from collections import defaultdict\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef find_nodes_at_distance_k(root, target_val, k):\n    if k < 0:\n        return []\n\n    parent_map = defaultdict(lambda: None)\n    visited = set()\n    target_node = initialize_parent_map(root, None, target_val, parent_map)\n\n    result = []\n    find_nodes_at_distance_k_helper(target_node, k, visited, parent_map, result)\n    return result\n\ndef initialize_parent_map(node, parent, target_val, parent_map):\n    if not node:\n        return None\n    if node.val == target_val:\n        return node\n\n    parent_map[node] = parent\n    left = initialize_parent_map(node.left, node, target_val, parent_map)\n    right = initialize_parent_map(node.right, node, target_val, parent_map)\n    return left if left else right\n\ndef find_nodes_at_distance_k_helper(node, k, visited, parent_map, result):\n    if not node or node in visited:\n        return\n\n    visited.add(node)\n    if k == 0:\n        result.append(node.val)\n        return\n\n    find_nodes_at_distance_k_helper(node.left, k-1, visited, parent_map, result)\n    find_nodes_at_distance_k_helper(node.right, k-1, visited, parent_map, result)\n    find_nodes_at_distance_k_helper(parent_map[node], k-1, visited, parent_map, result)", "import random\n\nclass Solution:\n\n    def __init__(self, n: int, blacklist: List[int]):\n        self.blacklist_map = {}\n        self.reduced_n = n - len(blacklist)\n\n        for b in blacklist:\n            if b < n:\n                self.blacklist_map[b] = -1\n\n        for b in blacklist:\n            if b >= self.reduced_n:\n                continue\n            while n - 1 in self.blacklist_map:\n                n -= 1\n            self.blacklist_map[b] = n - 1\n            n -= 1\n\n    def pick(self) -> int:\n        random_int = random.randint(0, self.reduced_n - 1)\n        return self.blacklist_map.get(random_int, random_int)", "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    m, n, steps, k, x, y, mask = len(grid), len(grid[0]), 0, 0, -1, -1, 0\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                x, y = i, j\n            elif 'a' <= grid[i][j] <= 'f':\n                k = max(k, ord(grid[i][j]) - ord('a') + 1)\n\n    q = deque([(x, y, 0)])\n    visited = {(x, y, mask)}\n\n    dirs = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n\n    while q:\n        qs = len(q)\n        for sz in range(qs):\n            x, y, mask = q.popleft()\n\n            if mask == (1 << k) - 1:\n                return steps\n\n            for dx, dy in dirs:\n                nx, ny, nmask = x + dx, y + dy, mask\n\n                if 0 <= nx < m and 0 <= ny < n:\n                    c = grid[nx][ny]\n                    if 'A' <= c <= 'F' and not nmask & (1 << (ord(c) - ord('A'))):\n                        continue\n                    if 'a' <= c <= 'f':\n                        nmask |= (1 << (ord(c) - ord('a')))\n\n                    if (nx, ny, nmask) in visited:\n                        continue\n\n                    visited.add((nx, ny, nmask))\n                    q.append((nx, ny, nmask))\n\n        steps += 1\n\n    return -1", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxDepth(node):\n    if node is None:\n        return 0\n    else:\n        return max(maxDepth(node.left), maxDepth(node.right)) + 1\n\ndef subtreeWithAllDeepest(root):\n    if root is None:\n        return None\n\n    leftDepth = maxDepth(root.left)\n    rightDepth = maxDepth(root.right)\n\n    if leftDepth == rightDepth:\n        return root\n\n    if leftDepth > rightDepth:\n        return subtreeWithAllDeepest(root.left)\n    else:\n        return subtreeWithAllDeepest(root.right)", "def is_prime(n):\n    if n <= 1:\n        return False\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 1\n    return True\n\ndef is_palindrome(n):\n    return str(n) == str(n)[::-1]\n\ndef prime_palindrome(n):\n    while True:\n        if is_prime(n) and is_palindrome(n):\n            return n\n        n += 1", "def transpose(matrix):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    result = [[0] * rows for _ in range(cols)]\n    for i in range(rows):\n        for j in range(cols):\n            result[j][i] = matrix[i][j]\n    return result", "def longest_distance(n):\n    last = -1\n    longest = 0\n    i = 0\n    while n:\n        if n & 1:\n            if last >= 0:\n                longest = max(longest, i - last)\n            last = i\n        n >>= 1\n        i += 1\n    return longest", "from itertools import permutations as perm\n\ndef reorderedPowerOf2(n):\n    for p in set(perm(str(n))):\n        if p[0] != '0' and (bin(int(''.join(p))).count('1') == 1):\n            return True\n    return False", "from collections import defaultdict\nfrom sortedcontainers import SortedList\n\ndef advantageCount(nums1, nums2):\n    d = defaultdict(int)\n    sorted_nums1 = SortedList(nums1)\n    res = []\n    \n    for num in nums2:\n        i = sorted_nums1.bisect_right(num)\n        if i == len(sorted_nums1):\n            i = 0\n        res.append(sorted_nums1.pop(i))\n    return res", "import heapq\n\ndef minRefuelStops(target: int, startFuel: int, stations: List[List[int]]) -> int:\n    i, stops, curFuel = 0, 0, startFuel\n    pq = []\n    while curFuel < target:\n        while i < len(stations) and stations[i][0] <= curFuel:\n            heapq.heappush(pq, -stations[i][1])\n            i += 1\n        if not pq: return -1\n        curFuel += -heapq.heappop(pq)\n        stops += 1\n    return stops", "def rand7(): # Given API\n    pass\n\ndef rand10():\n    result = 41\n    while result > 40:\n        result = (rand7() - 1) * 7 + rand7()\n    return result % 10 + 1", "def leafSimilar(root1, root2):\n    def getLeaves(node):\n        if not node:\n            return []\n        if not node.left and not node.right:\n            return [node.val]\n        return getLeaves(node.left) + getLeaves(node.right)\n\n    return getLeaves(root1) == getLeaves(root2)", "def lenLongestFibSubseq(arr):\n    index = {x: i for i, x in enumerate(arr)}\n\n    longest = dict()\n    ans = 0\n\n    for k, z in enumerate(arr):\n        for j, y in enumerate(arr[:k]):\n            i = index.get(z - y, None)\n            if i is not None and i < j:\n                longest[j, k] = longest.get((i, j), 1) + 1\n                ans = max(ans, longest[j, k] + 1)\n\n    return ans if ans >= 3 else 0", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        x = y = di = 0\n        obstacleSet = set(map(tuple, obstacles))\n\n        ans = 0\n        for cmd in commands:\n            if cmd == -2:\n                di = (di - 1) % 4\n            elif cmd == -1:\n                di = (di + 1) % 4\n            else:\n                for k in range(cmd):\n                    nx = x + dx[di]\n                    ny = y + dy[di]\n                    if (nx, ny) not in obstacleSet:\n                        x = nx\n                        y = ny\n                        ans = max(ans, x * x + y * y)\n\n        return ans", "def minEatingSpeed(piles, h):\n    left, right = 1, max(piles)\n    while left < right:\n        mid = left + (right - left) // 2\n        totalHours = sum((pile + mid - 1) // mid for pile in piles)\n        if totalHours > h:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef middleNode(head):\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    return slow", "def aliceWins(piles):\n    n = len(piles)\n    dp = [[0] * n for _ in range(n)]\n    for gap in range(n):\n        for i in range(n - gap):\n            j = i + gap\n            x = dp[i + 2][j] if i + 2 <= j else 0\n            y = dp[i + 1][j - 1] if i + 1 <= j - 1 else 0\n            z = dp[i][j - 2] if i <= j - 2 else 0\n            dp[i][j] = max(piles[i] + min(x, y), piles[j] + min(y, z))\n    sum_of_piles = sum(piles)\n    return dp[0][n - 1] > (sum_of_piles - dp[0][n - 1])", "def nthMagicalNumber(n, a, b):\n    mod = 1000000007\n    lcm = a * b // gcd(a, b)\n    left, right = 1, 10**14\n    while left < right:\n        mid = left + (right - left) // 2\n        if (mid // a + mid // b - mid // lcm) < n:\n            left = mid + 1\n        else:\n            right = mid\n    return left % mod\n\ndef gcd(a, b):\n    return a if b == 0 else gcd(b, a % b)", "def profitableSchemes(n, minProfit, group, profit):\n    dp = [[0] * (minProfit + 1) for _ in range(n + 1)]\n    mod = 10**9 + 7\n    dp[0][0] = 1\n    for i in range(len(group)):\n        for j in range(n, group[i] - 1, -1):\n            for k in range(minProfit, -1, -1):\n                dp[j][k] = (dp[j][k] + dp[j - group[i]][max(0, k - profit[i])]) % mod\n    return sum(dp[i][minProfit] for i in range(1, n + 1)) % mod", "import random\nfrom bisect import bisect_left\n\nclass Solution:\n\n    def __init__(self, w: List[int]):\n        self.prefix_sum = []\n        for weight in w:\n            previous = self.prefix_sum[-1] if self.prefix_sum else 0\n            self.prefix_sum.append(previous + weight)\n\n    def pickIndex(self) -> int:\n        num = random.random() * self.prefix_sum[-1]\n        return bisect_left(self.prefix_sum, num)", "import random\n\nclass Solution:\n    def __init__(self, m, n):\n        self.grid = [[0] * n for _ in range(m)]\n        self.zero_count = m * n\n\n    def pick(self):\n        index = random.randrange(self.zero_count)\n\n        for i, row in enumerate(self.grid):\n            for j, cell in enumerate(row):\n                if cell == 0:\n                    if index == 0:\n                        self.grid[i][j] = 1\n                        self.zero_count -= 1\n                        return (i, j)\n                    index -= 1\n        return (-1, -1)  # Should not happen", "import random\nfrom bisect import bisect_left\n\nclass Solution:\n    def __init__(self, rects):\n        self.rects = rects\n        self.areas = []\n        self.total_area = 0\n        for rect in rects:\n            area = (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1)\n            self.total_area += area\n            self.areas.append(self.total_area)\n\n    def pick(self):\n        random_area = random.randint(0, self.total_area - 1)\n        rect_index = bisect_left(self.areas, random_area + 1)\n\n        x = random.randint(self.rects[rect_index][0], self.rects[rect_index][2])\n        y = random.randint(self.rects[rect_index][1], self.rects[rect_index][3])\n\n        return [x, y]", "import random\nimport math\n\nclass Solution:\n\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        angle = random.random() * 2 * math.pi\n        r = math.sqrt(random.random()) * self.radius\n        return [self.x_center + r * math.cos(angle), self.y_center + r * math.sin(angle)]", "def find_kth_character(s: str, k: int) -> str:\n    n = len(s)\n    size = 0\n\n    for c in s:\n        if c.isdigit():\n            size = size * int(c)\n        else:\n            size += 1\n\n    for i in range(n - 1, -1, -1):\n        c = s[i]\n        k %= size\n        if k == 0 and not c.isdigit():\n            return c\n\n        if c.isdigit():\n            size //= int(c)\n        else:\n            size -= 1\n\n    return '-'", "def num_rescue_boats(people, limit):\n    people.sort()\n    left, right = 0, len(people) - 1\n    boats = 0\n    while left <= right:\n        if people[left] + people[right] <= limit:\n            left += 1\n        right -= 1\n        boats += 1\n    return boats", "from heapq import heappush, heappop\n\ndef reachableNodes(edges, maxMoves, n):\n    graph = [[] for _ in range(n)]\n    for u, v, cnt in edges:\n        graph[u].append((v, cnt + 1))\n        graph[v].append((u, cnt + 1))\n\n    visited = set()\n    pq = [(-maxMoves, 0)]\n\n    while pq:\n        moves_left, node = heappop(pq)\n\n        if node in visited:\n            continue\n        visited.add(node)\n\n        for next_node, moves_needed in graph[node]:\n            moves_left_after = moves_left - moves_needed\n            if next_node not in visited and moves_left_after > 0:\n                heappush(pq, (moves_left_after, next_node))\n\n    return len(visited)", "def projectionArea(grid):\n    n = len(grid)\n    top, front, side = 0, 0, 0\n    for i in range(n):\n        max_front, max_side = 0, 0\n        for j in range(n):\n            if grid[i][j] > 0:\n                top += 1\n            max_front = max(max_front, grid[i][j])\n            max_side = max(max_side, grid[j][i])\n        front += max_front\n        side += max_side\n    return top + front + side", "def uncommon_from_sentences(s1, s2):\n    word_count = {}\n    for word in (s1 + \" \" + s2).split():\n        word_count[word] = word_count.get(word, 0) + 1\n\n    return [key for key, val in word_count.items() if val == 1]", "def spiral_walk(rows, cols, rStart, cStart):\n    result = []\n    dr = [0, 1, 0, -1]\n    dc = [1, 0, -1, 0]\n    moves = rows * cols\n    r, c, dir = rStart, cStart, 0\n    \n    while len(result) < moves:\n        result.append([r, c])\n        r += dr[dir]\n        c += dc[dir]\n        \n        if r < 0 or r >= rows or c < 0 or c >= cols:\n            r -= dr[dir]\n            c -= dc[dir]\n            dir = (dir + 1) % 4\n            r += dr[dir]\n            c += dc[dir]\n\n    return result", "from collections import defaultdict\n\n\ndef possible_bipartition(n, dislikes):\n    def dfs(person, group):\n        if person in groups:\n            return groups[person] == group\n        groups[person] = group\n        for other in dislike_list[person]:\n            if not dfs(other, -group):\n                return False\n        return True\n\n    groups = {}\n    dislike_list = defaultdict(list)\n    for p1, p2 in dislikes:\n        dislike_list[p1].append(p2)\n        dislike_list[p2].append(p1)\n\n    for person in range(1, n + 1):\n        if person not in groups and not dfs(person, 1):\n            return False\n\n    return True", "def min_moves(k, n):\n    if k == 1 or n == 0 or n == 1:\n        return n\n    \n    res = float('inf')\n    for i in range(1, n + 1):\n        temp = max(min_moves(k - 1, i - 1), min_moves(k, n - i))\n        res = min(res, temp)\n    \n    return res + 1", "def fair_candy_swap(aliceSizes, bobSizes):\n    aliceTotal, bobTotal = sum(aliceSizes), sum(bobSizes)\n    delta = (bobTotal - aliceTotal) // 2\n    for a in aliceSizes:\n        for b in bobSizes:\n            if a + delta == b:\n                return [a, b]\n    return []", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def constructFromPrePost(self, pre, post):\n        def buildTree(preStart, preEnd, postStart, postEnd):\n            if preStart == preEnd:\n                return None\n\n            root = TreeNode(pre[preStart])\n\n            if preStart + 1 == preEnd:\n                return root\n\n            leftRoot = pre[preStart + 1]\n\n            leftSize = 0\n            for i in range(postStart, postEnd):\n                if post[i] == leftRoot:\n                    leftSize = i - postStart + 1\n                    break\n\n            root.left = buildTree(preStart + 1, preStart + 1 + leftSize, postStart, postStart + leftSize)\n            root.right = buildTree(preStart + 1 + leftSize, preEnd, postStart + leftSize, postEnd - 1)\n\n            return root\n\n        return buildTree(0, len(pre), 0, len(post))", "def find_and_replace_patterns(words, pattern):\n    result = []\n    for word in words:\n        if len(word) != len(pattern): continue\n\n        w2p = {}\n        p2w = {}\n        matches = True\n        for cWord, cPattern in zip(word, pattern):\n            if cWord not in w2p: w2p[cWord] = cPattern\n            if cPattern not in p2w: p2w[cPattern] = cWord\n\n            if w2p[cWord] != cPattern or p2w[cPattern] != cWord:\n                matches = False\n                break\n\n        if matches: result.append(word)\n    return result", "def sum_of_widths(nums):\n    MOD = 10**9 + 7\n    nums.sort()\n    c, res = 1, 0\n    n = len(nums)\n\n    for i in range(n):\n        res = (res + (nums[i] - nums[n - i - 1]) * c) % MOD\n        c = c * 2 % MOD\n\n    return res", "def surfaceArea(grid):\n    n = len(grid)\n    area = 0\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j]:\n                area += 4 * grid[i][j] + 2\n                if i > 0:\n                    area -= 2 * min(grid[i][j], grid[i - 1][j])\n                if j > 0:\n                    area -= 2 * min(grid[i][j], grid[i][j - 1])\n\n    return area", "def num_special_equivalent_groups(words):\n    groups = set()\n\n    for word in words:\n        evens = \"\".join(sorted(word[0::2]))\n        odds = \"\".join(sorted(word[1::2]))\n\n        groups.add(evens + odds)\n\n    return len(groups)", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef all_possible_FBT(n):\n    if n % 2 == 0:\n        return []\n    if n == 1:\n        return [TreeNode(0)]\n\n    result = []\n    for i in range(1, n, 2):\n        left = all_possible_FBT(i)\n        right = all_possible_FBT(n - i - 1)\n        for l in left:\n            for r in right:\n                root = TreeNode(0)\n                root.left = l\n                root.right = r\n                result.append(root)\n    return result", "from collections import defaultdict, deque\n\nclass FreqStack:\n    def __init__(self):\n        self.freq = defaultdict(int)\n        self.group = defaultdict(list)\n\n    def push(self, x: int):\n        freq = self.freq[x] = self.freq[x] + 1\n        self.group[freq].append(x)\n\n    def pop(self) -> int:\n        max_freq = max(self.group)\n        x = self.group[max_freq].pop()\n        self.freq[x] -= 1\n        if not self.group[max_freq]:\n            del self.group[max_freq]\n        return x", "def isMonotonic(nums):\n    increasing = decreasing = True\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]: decreasing = False\n        if nums[i] < nums[i - 1]: increasing = False\n    return increasing or decreasing", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef increasingBST(root):\n    def inorder(node):\n        nonlocal prev\n        if not node: return\n\n        inorder(node.left)\n        prev.right = node\n        prev = node\n        node.left = None\n        inorder(node.right)\n\n    dummy = TreeNode(0)\n    prev = dummy\n    inorder(root)\n    return dummy.right", "def subarrayBitwiseORs(arr: List[int]) -> int:\n    result, current, temp = set(), set(), set()\n    for num in arr:\n        temp = {num}\n        for c in current:\n            temp.add(num | c)\n        current = temp\n        result |= current\n    return len(result)", "def lex_smallest_string(s, k):\n    res = s\n    for i in range(k):\n        tmp = s[i:] + s[:i]\n        if tmp < res:\n            res = tmp\n    return res", "class RLEIterator:\n    def __init__(self, encoding):\n        self.encoding = encoding\n        self.index = 0\n\n    def next(self, n):\n        while self.index < len(self.encoding):\n            if n <= self.encoding[self.index]:\n                self.encoding[self.index] -= n\n                return self.encoding[self.index + 1]\n            n -= self.encoding[self.index]\n            self.index += 2\n        return -1", "class StockSpanner:\n\n    def __init__(self):\n        self.prices = []\n        self.index_stack = []\n\n    def next(self, price: int) -> int:\n        while self.index_stack and self.prices[self.index_stack[-1]] <= price:\n            self.index_stack.pop()\n        span = len(self.prices) + 1 if not self.index_stack else len(self.prices) - self.index_stack[-1]\n        self.index_stack.append(len(self.prices))\n        self.prices.append(price)\n        return span", "from bisect import bisect_right\n\ndef num_digits_less_than_n(digits: List[int], n: int) -> int:\n    ans = 0\n    factor = 1\n    n_str = str(n)\n    for i in range(len(n_str) - 1, -1, -1):\n        ans += bisect_right(digits, int(n_str[i])) * factor\n        factor *= len(digits)\n    return ans", "def find_valid_permutations(s: str) -> int:\n    n = len(s)\n    MOD = 1000000007\n    dp = [0] * (n + 2)\n    dp[0] = 1\n\n    for c in s:\n        new_dp = [0] * (n + 2)\n        if c == 'I':\n            for i in range(n):\n                new_dp[i + 1] = (new_dp[i + 1] + dp[i]) % MOD\n        else:\n            for i in range(n - 1, -1, -1):\n                new_dp[i] = (new_dp[i + 1] + dp[i + 1]) % MOD\n        dp = new_dp\n\n    return dp[0]", "def totalFruit(fruits):\n    left, right, max_count = 0, 0, 0\n    count = {}\n\n    while right < len(fruits):\n        count[fruits[right]] = count.get(fruits[right], 0) + 1\n        while len(count) > 2:\n            count[fruits[left]] -= 1\n            if count[fruits[left]] == 0:\n                del count[fruits[left]]\n            left += 1\n        max_count = max(max_count, right - left + 1)\n        right += 1\n\n    return max_count", "def move_even_odd(nums):\n    even_index = 0\n    odd_index = len(nums) - 1\n\n    while even_index < odd_index:\n        if nums[even_index] % 2 == 0:\n            even_index += 1\n        else:\n            nums[even_index], nums[odd_index] = nums[odd_index], nums[even_index]\n            odd_index -= 1\n\n    return nums", "def isPalindrome(num):\n    return str(num) == str(num)[::-1]\n\ndef superpalindromesInRange(left: str, right: str) -> int:\n    l = int(left)\n    r = int(right)\n    cnt = 0\n    base = 1\n    while base * base <= r:\n        if isPalindrome(base) and isPalindrome(base * base):\n            if base * base >= l:\n                cnt += 1\n        base += 1\n    return cnt", "def sum_of_mins(arr):\n    mod = 10**9 + 7\n    n = len(arr)\n    left, right = [0] * n, [0] * n\n    st = []\n\n    for i in range(n):\n        while st and arr[st[-1]] > arr[i]:\n            st.pop()\n        left[i] = st[-1] if st else -1\n        st.append(i)\n\n    st.clear()\n    for i in range(n - 1, -1, -1):\n        while st and arr[st[-1]] > arr[i]:\n            st.pop()\n        right[i] = st[-1] if st else n\n        st.append(i)\n\n    ans = 0\n    for i in range(n):\n        ans = (ans + arr[i] * (i - left[i]) * (right[i] - i)) % mod\n    return ans", "def minDifference(nums, k):\n    if len(nums) <= 1: return 0\n    nums.sort()\n    min_diff = nums[-1] - nums[0]\n    for i in range(1, len(nums)):\n        high = max(nums[i-1] + k, nums[-1] - k)\n        low = min(nums[i] - k, nums[0] + k)\n        min_diff = min(min_diff, high - low)\n    return min_diff", "def snakesAndLadders(board):\n    n = len(board)\n    visited = [False] * (n*n + 1)\n    queue = [(1, 0)]  # starting at position 1\n    visited[1] = True\n\n    def get_position(pos):\n        r = (pos - 1) // n\n        c = (pos - 1) % n\n        if r % 2 == 1:\n            c = n - 1 - c\n        r = n - r - 1\n        return r, c\n\n    while queue:\n        pos, steps = queue.pop(0)\n        for jump in range(1, 7):\n            next_pos = pos + jump\n            if next_pos > n*n:\n                break\n            r, c = get_position(next_pos)\n            if board[r][c] != -1:\n                next_pos = board[r][c]\n            if next_pos == n*n:\n                return steps + 1\n            if not visited[next_pos]:\n                visited[next_pos] = True\n                queue.append((next_pos, steps + 1))\n\n    return -1", "def minimum_score(nums, k):\n    nums.sort()\n    n = len(nums)\n    res = nums[n - 1] - nums[0]\n\n    for i in range(n - 1):\n        high = max(nums[i] + k, nums[n - 1] - k)\n        low = min(nums[i + 1] - k, nums[0] + k)\n        res = min(res, high - low)\n\n    return res", "from collections import defaultdict\nfrom bisect import bisect\n\nclass TopVotedCandidate:\n\n    def __init__(self, persons, times):\n        self.leader_map = {}\n        self.times = times\n        votes = defaultdict(int)\n        leader = -1\n        for i, t in enumerate(times):\n            votes[persons[i]] += 1\n            if votes[persons[i]] >= votes[leader]:\n                leader = persons[i]\n            self.leader_map[t] = leader\n\n    def q(self, t):\n        idx = bisect.bisect(self.times, t)\n        return self.times[idx - 1]", "def sortArray(nums):\n    nums.sort()", "from collections import deque\n\ndef catMouseGame(graph):\n    n = len(graph)\n    status = [[[0]*3 for _ in range(n)] for _ in range(n)]\n\n    for i in range(1, n):\n        status[i][i][1] = 2\n        status[i][i][2] = 2\n    queue = deque([(i, i, t, 2) for i in range(1, n) for t in (1, 2)])\n\n    while queue:\n        pos_m, pos_c, t_type, t_result = queue.popleft()\n\n        for prev in graph[pos_m if t_type == 1 else pos_c]:\n            if (t_type == 2 and prev == 0) or (t_result == 2 and status[prev][pos_c][3 - t_type]):\n                continue\n            if status[prev][pos_c][3 - t_type]:\n                continue\n            queue.append((pos_c, prev, 3 - t_type, 3 - t_result))\n            status[prev][pos_c][3 - t_type] = 3 - t_result\n\n    return status[1][2][1]", "from collections import Counter\nfrom math import gcd\nfrom functools import reduce\n\ndef hasGroupsSizeX(deck):\n    counts = Counter(deck)\n    gcd_result = reduce(gcd, counts.values())\n    return gcd_result > 1", "def partitionDisjoint(nums):\n    left_max, global_max, left_length = nums[0], nums[0], 1\n    for i in range(1, len(nums)):\n        if nums[i] < left_max:\n            left_max = global_max\n            left_length = i + 1\n        else:\n            global_max = max(global_max, nums[i])\n    return left_length", "from collections import Counter\n\ndef word_subsets(words1, words2):\n    max_chars = Counter()\n    for word in words2:\n        chars = Counter(word)\n        for c, count in chars.items():\n            max_chars[c] = max(max_chars[c], count)\n    \n    result = []\n    for word in words1:\n        word_chars = Counter(word)\n        universal = all(word_chars[c] >= max_chars[c] for c in max_chars)\n        if universal:\n            result.append(word)\n    \n    return result", "def reverse_string(s):\n    return s[::-1]", "def canReorderDoubled(arr):\n    count = collections.Counter(arr)\n    \n    for a in sorted(count, key=abs):\n        if count[a] > 0:\n            target = a * 2\n            if count[target] < count[a]:\n                return False\n            count[target] -= count[a]\n\n    return True", "from collections import deque\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass CBTInserter:\n    def __init__(self, root: TreeNode):\n        self.root = root\n        self.q = deque([root])\n        while True:\n            node = self.q[0]\n            if not node.left or not node.right:\n                break\n            self.q.append(node.left)\n            self.q.append(node.right)\n            self.q.popleft()\n\n    def insert(self, v: int) -> int:\n        newNode = TreeNode(v)\n        parentNode = self.q[0]\n        if not parentNode.left:\n            parentNode.left = newNode\n        else:\n            parentNode.right = newNode\n            self.q.append(parentNode.left)\n            self.q.append(parentNode.right)\n            self.q.popleft()\n        return parentNode.val\n\n    def get_root(self) -> TreeNode:\n        return self.root", "def numMusicPlaylists(n, goal, k):\n    MOD = 1000000007\n    dp = [[0] * (n + 1) for _ in range(goal + 1)]\n    dp[0][0] = 1\n    for i in range(1, goal + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j - 1] * (n - (j - 1)) % MOD + dp[i - 1][j] * max(0, j - k) % MOD) % MOD\n    return dp[goal][n]", "def minAddToMakeValid(s: str) -> int:\n    result = balance = 0\n    for c in s:\n        balance += 1 if c == '(' else -1\n        if balance == -1:\n            result += 1\n            balance += 1\n    return result + balance", "def sortArrayByParityII(nums):\n    j = 1\n    for i in range(0, len(nums), 2):\n        if nums[i] % 2:\n            while nums[j] % 2:\n                j += 2\n            nums[i], nums[j] = nums[j], nums[i]\n    return nums", "def threeSumMulti(arr, target):\n    MOD = 1000000007\n    ans = 0\n\n    arr.sort()\n    n = len(arr)\n\n    for i in range(n - 2):\n        j, k = i + 1, n - 1\n        while j < k:\n            s = arr[i] + arr[j] + arr[k]\n            if s > target:\n                k -= 1\n            elif s < target:\n                j += 1\n            else:\n                if arr[j] != arr[k]:\n                    left_count = right_count = 1\n\n                    while j < n - 1 and arr[j] == arr[j + 1]:\n                        left_count += 1\n                        j += 1\n\n                    while k > 0 and arr[k] == arr[k - 1]:\n                        right_count += 1\n                        k -= 1\n\n                    ans += left_count * right_count\n                    ans %= MOD\n                    j += 1\n                    k -= 1\n                else:\n                    ans += (k - j + 1) * (k - j) // 2\n                    ans %= MOD\n                    break\n\n    return ans", "from collections import deque\n\ndef minMalwareSpread(graph, initial):\n    n = len(graph)\n    initial.sort()\n    \n    malware = set(initial)\n    \n    minNode = initial[0]\n    minSpread = n + 1\n\n    for node in initial:\n        q = deque(otherNode for otherNode in initial if node != otherNode)\n        visited = [node != otherNode and otherNode in malware for otherNode in range(n)]\n        \n        while q:\n            cur = q.popleft()\n            for next, isConnected in enumerate(graph[cur]):\n                if isConnected and not visited[next] and next not in malware:\n                    visited[next] = True\n                    q.append(next)\n        \n        spread = sum(visited)\n        \n        if spread < minSpread:\n            minNode = node\n            minSpread = spread\n    \n    return minNode", "def isLongPressedName(name: str, typed: str) -> bool:\n    i, j = 0, 0\n    while j < len(typed):\n        if i < len(name) and name[i] == typed[j]:\n            i += 1\n        elif j == 0 or typed[j] != typed[j - 1]:\n            return False\n        j += 1\n    return i == len(name)", "def minFlipsMonoIncr(s: str) -> int:\n    flipCount, oneCount = 0, 0\n    for c in s:\n        if c == '1':\n            oneCount += 1\n        else:\n            flipCount = min(flipCount + 1, oneCount)\n    return flipCount", "def find_same_binary_value_parts(arr):\n    ones = sum(arr)\n\n    if ones % 3 != 0:\n        return [-1, -1]\n\n    target = ones // 3\n    if target == 0:\n        return [0, len(arr) - 2]\n\n    count = 0\n    i = j = -1\n    ones = 0\n    for idx, n in enumerate(arr):\n        if n == 1:\n            ones += 1\n            if ones == target + 1:\n                count += 1\n            if count == 1 and i == -1:\n                i = idx\n            if count == 2 and j == -1:\n                j = idx\n            if count == 3:\n                break\n\n    return [i, j]", "from collections import deque\nfrom typing import List\n\ndef minMalwareSpread(graph: List[List[int]], initial: List[int]) -> int:\n    n = len(graph)\n    color = [-1] * n\n    colors = 0\n\n    for i in range(n):\n        if color[i] == -1:\n            q = deque([i])\n            color[i] = colors\n\n            while q:\n                t = q.popleft()\n                for j in range(n):\n                    if graph[t][j] == 1 and color[j] == -1:\n                        q.append(j)\n                        color[j] = colors\n\n            colors += 1\n\n    area = [0] * colors\n    count = [0] * colors\n    initially_infected = set(initial)\n    for i in range(n):\n        area[color[i]] += 1\n        if i in initially_infected:\n            count[color[i]] += 1\n\n    res = min(initial)\n    min_size = n + 1\n    for i in initial:\n        if count[color[i]] == 1:\n            if area[color[i]] < min_size:\n                min_size = area[color[i]]\n                res = i\n            elif area[color[i]] == min_size and i < res:\n                res = i\n\n    return res", "def num_unique_emails(emails):\n    unique_emails = set()\n\n    for email in emails:\n        local_name, domain_name = email.split(\"@\")\n        local_name = local_name.split(\"+\")[0]\n        local_name = local_name.replace(\".\", \"\")\n\n        unique_emails.add(local_name + \"@\" + domain_name)\n\n    return len(unique_emails)", "def num_subarrays_with_sum(nums, goal):\n    from collections import defaultdict\n    prefix_sum_count = defaultdict(int)\n    prefix_sum_count[0] = 1\n    cumulative_sum, result = 0, 0\n    \n    for num in nums:\n        cumulative_sum += num\n        result += prefix_sum_count[cumulative_sum - goal]\n        prefix_sum_count[cumulative_sum] += 1\n    \n    return result", "def minFallingPathSum(matrix):\n    n = len(matrix)\n    for i in range(1, n):\n        for j in range(n):\n            min_val = matrix[i - 1][j]\n            if j > 0: min_val = min(min_val, matrix[i - 1][j - 1])\n            if j < n - 1: min_val = min(min_val, matrix[i - 1][j + 1])\n            matrix[i][j] += min_val\n    return min(matrix[-1])", "def beautifulArray(n: int) -> List[int]:\n    result = [1]\n    while len(result) < n:\n        temp = []\n        for i in result:\n            if i * 2 - 1 <= n:\n                temp.append(i * 2 - 1)\n        for i in result:\n            if i * 2 <= n:\n                temp.append(i * 2)\n        result = temp\n    return result", "from collections import deque\n\nclass RecentCounter:\n    def __init__(self):\n        self.requests = deque()\n\n    def ping(self, t: int) -> int:\n        self.requests.append(t)\n        while self.requests[0] < t - 3000:\n            self.requests.popleft()\n        return len(self.requests)", "def powerfulIntegers(x, y, bound):\n    max_i = 0 if x == 1 else int(math.log(bound, x))\n    max_j = 0 if y == 1 else int(math.log(bound, y))\n    result_set = set()\n    \n    for i in range(max_i + 1):\n        for j in range(max_j + 1):\n            powerful_num = x ** i + y ** j\n            if powerful_num <= bound:\n                result_set.add(powerful_num)\n                \n    return list(result_set)", "from collections import deque\n\ndef shortestBridge(grid):\n    n = len(grid)\n    q = deque()\n\n    # Find the first island and mark it\n    for i in range(n):\n        if any(grid[i]):\n            first_row = i\n            first_col = grid[first_row].index(1)\n            break\n\n    dfs(grid, q, first_row, first_col)\n\n    steps = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    \n    while q:\n        for _ in range(len(q)):\n            x, y = q.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < n:\n                    if grid[nx][ny] == 1:\n                        return steps\n                    elif grid[nx][ny] == 0:\n                        grid[nx][ny] = -1\n                        q.append((nx, ny))\n        steps += 1\n    return -1\n\ndef dfs(grid, q, i, j):\n    n = len(grid)\n    if not (0 <= i < n and 0 <= j < n and grid[i][j] == 1):\n        return\n    grid[i][j] = -1\n    q.append((i, j))\n    \n    dfs(grid, q, i - 1, j)\n    dfs(grid, q, i + 1, j)\n    dfs(grid, q, i, j - 1)\n    dfs(grid, q, i, j + 1)", "def knightDialer(n: int) -> int:\n    if n == 1:\n        return 10\n    MOD = 10**9 + 7\n    moves = [\n        [4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9],\n        [], [1, 7, 0], [2, 6], [1, 3], [2, 4]\n    ]\n    dp = [1] * 10\n    for _ in range(2, n + 1):\n        new_dp = [0] * 10\n        for j in range(10):\n            for move in moves[j]:\n                new_dp[j] = (new_dp[j] + dp[move]) % MOD\n        dp = new_dp\n    return sum(dp) % MOD", "def moves_to_stamp(stamp: str, target: str) -> list:\n    result = []\n    is_stamped = [False] * len(target)\n    stamp_count = 0\n    target = list(target)\n\n    while stamp_count < 10 * len(target):\n        found_stamp = False\n        for i in range(len(target) - len(stamp) + 1):\n            if is_stamped[i]:\n                continue\n            j = 0\n            overlap = 0\n            while j < len(stamp) and (target[i + j] == '?' or target[i + j] == stamp[j]):\n                if target[i + j] == stamp[j]:\n                    overlap += 1\n                j += 1\n            if j == len(stamp) and overlap > 0:\n                for j in range(len(stamp)):\n                    target[i + j] = '?'\n                result.append(i)\n                is_stamped[i] = True\n                found_stamp = True\n        if not found_stamp:\n            break\n        \n        stamp_count += 1\n\n    for c in target:\n        if c != '?':\n            return []\n\n    return result[::-1]", "def subarraysDivByK(nums, k):\n    prefix_sums_mod_k = [0] * k\n    prefix_sums_mod_k[0] = 1\n    running_sum = 0\n    count = 0\n    \n    for num in nums:\n        running_sum += num\n        mod = (running_sum % k + k) % k\n        count += prefix_sums_mod_k[mod]\n        prefix_sums_mod_k[mod] += 1\n    \n    return count", "def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\n    if not root:\n        return 0\n    if root.val < low:\n        return self.rangeSumBST(root.right, low, high)\n    if root.val > high:\n        return self.rangeSumBST(root.left, low, high)\n    return root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)", "def min_area_rect(points):\n    point_set = {(x, y) for x, y in points}\n    min_area = float('inf')\n\n    for p1 in point_set:\n        for p2 in point_set:\n            if p1[0] != p2[0] and p1[1] != p2[1]:\n                if (p1[0], p2[1]) in point_set and (p2[0], p1[1]) in point_set:\n                    min_area = min(min_area, abs((p1[0] - p2[0]) * (p1[1] - p2[1])))\n\n    return min_area if min_area != float('inf') else 0", "def distinctSubseqII(s):\n    mod = 10**9 + 7\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    last = [-1] * 26\n\n    for i in range(1, n + 1):\n        dp[i] = (dp[i - 1] * 2) % mod\n        if last[ord(s[i - 1]) - ord('a')] != -1:\n            dp[i] = (dp[i] - dp[last[ord(s[i - 1]) - ord('a')]] + mod) % mod\n        last[ord(s[i - 1]) - ord('a')] = i - 1\n\n    dp[n] = (dp[n] - 1 + mod) % mod\n    return dp[n]", "def valid_mountain_array(arr):\n    n, i, j = len(arr), 0, len(arr) - 1\n    while i + 1 < n and arr[i] < arr[i + 1]:\n        i += 1\n    while j > 0 and arr[j - 1] > arr[j]:\n        j -= 1\n    return i > 0 and i == j and j < n - 1", "def decode_permutation(s: str):\n    n = len(s)\n    perm = [0] * (n + 1)\n    next_zero, next_one = 0, n\n\n    for c in s:\n        if c == '0':\n            perm[next_zero] = next_one\n            next_zero += 1\n            next_one -= 1\n        else:\n            perm[next_one] = next_zero\n            next_one -= 1\n            next_zero += 1\n\n    perm[next_zero] = next_one\n    return perm", "from itertools import permutations\n\ndef smallestSuperstring(words):\n    def get_shared_length(a, b):\n        for shared_length in range(min(len(a), len(b)), 0, -1):\n            if a[-shared_length:] == b[:shared_length]:\n                return shared_length\n        return 0\n\n    def merge(a, b, shared_length):\n        return a + b[shared_length:]\n\n    def get_total_length(merged_words):\n        return sum(len(word) for word in merged_words)\n\n    best = None\n    for perm in permutations(words):\n        merged_words = list(perm)\n        for i in range(len(words) - 1):\n            shared_length = get_shared_length(merged_words[i], merged_words[i + 1])\n            merged_words[i + 1] = merge(merged_words[i], merged_words[i + 1], shared_length)\n        if best is None or get_total_length(merged_words) < len(best):\n            best = \"\".join(merged_words)\n\n    return best", "def min_deletion_size(strs):\n    num_deleted = 0\n    for col in range(len(strs[0])):\n        for row in range(1, len(strs)):\n            if strs[row][col] < strs[row - 1][col]:\n                num_deleted += 1\n                break\n    return num_deleted", "def min_moves_unique(nums):\n    nums.sort()\n    moves = 0\n    for i in range(1, len(nums)):\n        if nums[i] <= nums[i - 1]:\n            diff = nums[i - 1] - nums[i] + 1\n            moves += diff\n            nums[i] += diff\n    return moves", "def validateStackSequences(pushed, popped):\n    stack = []\n    popIndex = 0\n    \n    for pushValue in pushed:\n        stack.append(pushValue)\n        while stack and stack[-1] == popped[popIndex]:\n            stack.pop()\n            popIndex += 1\n    \n    return not stack", "from collections import defaultdict\n\ndef removeStones(stones):\n    row_groups = defaultdict(int)\n    col_groups = defaultdict(int)\n    group_count = 0\n    \n    groups = defaultdict(list)\n    \n    for x, y in stones:\n        if x not in row_groups:\n            row_groups[x] = group_count\n            group_count += 1\n        if y + 10001 not in col_groups: # Offset by max row index\n            col_groups[y + 10001] = group_count\n            group_count += 1\n            \n        group_x, group_y = row_groups[x], col_groups[y + 10001]\n        groups[group_x].append(group_y)\n        groups[group_y].append(group_x)\n    \n    visited = [False] * group_count\n    \n    def dfs(groupId):\n        if visited[groupId]:\n            return 0\n        visited[groupId] = True\n        size = 1\n        for neighbor in groups[groupId]:\n            size += dfs(neighbor)\n        return size\n    \n    max_stones = 0\n    for groupId in range(group_count):\n        max_stones += dfs(groupId) - 1\n    \n    return max_stones", "def bag_of_tokens_score(tokens, power):\n    tokens.sort()\n    max_score = score = 0\n    left, right = 0, len(tokens) - 1\n\n    while left <= right:\n        if power >= tokens[left]:\n            power -= tokens[left]\n            left += 1\n            score += 1\n            max_score = max(max_score, score)\n        elif score > 0:\n            power += tokens[right]\n            right -= 1\n            score -= 1\n        else:\n            break\n\n    return max_score", "from itertools import permutations\n\ndef largestTimeFromDigits(arr):\n    max_time = -1\n    for h, i, j, k in permutations(arr):\n        hour = h * 10 + i\n        minute = j * 10 + k\n        time = hour * 60 + minute\n        if hour < 24 and minute < 60 and time > max_time:\n            max_time = time\n\n    if max_time == -1:\n        return \"\"\n    else:\n        return \"{:02d}:{:02d}\".format(max_time // 60, max_time % 60)", "from collections import deque\n\ndef deckRevealedIncreasing(deck):\n    n = len(deck)\n    index = deque(range(n))\n    ans = [0] * n\n\n    deck.sort()\n    for card in deck:\n        ans[index.popleft()] = card\n        if index:\n            index.append(index.popleft())\n\n    return ans", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef flipEquiv(root1, root2):\n    if not root1 and not root2: return True\n    if not root1 or not root2: return False\n    if root1.val != root2.val: return False\n    return (flipEquiv(root1.left, root2.left) and flipEquiv(root1.right, root2.right)) or \\\n           (flipEquiv(root1.left, root2.right) and flipEquiv(root1.right, root2.left))", "from collections import defaultdict\n\ndef largestComponentSize(nums):\n    def primes(n):\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return i\n        return n\n\n    def dfs(node, visited, graph):\n        if node in visited:\n            return 0\n        visited.add(node)\n        size = 1\n        for neighbor in graph[node]:\n            size += dfs(neighbor, visited, graph)\n        return size\n\n    graph = defaultdict(set)\n    visited = set()\n\n    for num in nums:\n        prime = primes(num)\n        graph[prime].add(num)\n        if num != prime:\n            graph[num].add(prime)\n\n    count = 0\n    for num in nums:\n        count = max(count, dfs(num, visited, graph))\n\n    return count", "def is_alien_sorted(words, order):\n    alien_order = {char: i for i, char in enumerate(order)}\n\n    for i in range(1, len(words)):\n        for j in range(len(words[i - 1])):\n            if j == len(words[i]):\n                return False\n\n            if words[i - 1][j] != words[i][j]:\n                if alien_order[words[i - 1][j]] > alien_order[words[i][j]]:\n                    return False\n                break\n\n    return True", "def can_reorder_array(arr):\n    from collections import Counter\n    \n    count = Counter(arr)\n    arr = sorted(arr)\n    for x in arr:\n        if count[x] == 0:\n            continue\n        if count[2 * x] > 0:\n            count[x] -= 1\n            count[2 * x] -= 1\n        else:\n            return False\n    return True", "class Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        n = len(strs)\n        m = len(strs[0])\n        dp = [1] * m\n\n        for j in range(m):\n            for i in range(j):\n                flag = all(strs[k][i] <= strs[k][j] for k in range(n - 1))\n                dp[j] = max(dp[j], dp[i] + 1) if flag else dp[j]\n\n        return m - max(dp)", "def tallestBillboard(rods):\n    n = len(rods)\n    totalLength = sum(rods)\n    dp = [[-1] * (totalLength + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    \n    for i in range(1, n + 1):\n        for j in range(totalLength + 1):\n            dp[i][j] = dp[i - 1][j]\n            if rods[i - 1] <= j:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - rods[i - 1]] + rods[i - 1])\n            if rods[i - 1] <= totalLength - j:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j + rods[i - 1]])\n                \n    return dp[n][0] // 2", "def prisonAfterNDays(cells, n):\n    n = n % 14 if n % 14 != 0 else 14 # Pattern repeats every 14 days\n\n    for _ in range(n):\n        temp = [0] * 8\n        for i in range(1, 7):\n            temp[i] = int(cells[i - 1] == cells[i + 1])\n        cells = temp\n\n    return cells", "def min_k_bit_flips(nums, k):\n    n = len(nums)\n    flipped = [0] * n\n    flips = ans = 0\n    for i in range(n):\n        if i >= k:\n            flips -= flipped[i - k]\n        if (flips + nums[i]) % 2 == 0:\n            if i + k > n:\n                return -1\n            flipped[i] = 1\n            flips += 1\n            ans += 1\n    return ans", "from collections import Counter\n\ndef numSquarefulPerms(nums):\n    def is_square(n):\n        return int(n ** 0.5) ** 2 == n\n\n    def dfs(idx):\n        if idx == len(nums):\n            return 1\n\n        count = 0\n        for key in counter.keys():\n            if counter[key] and (idx == 0 or is_square(nums[idx - 1] + key)):\n                counter[key] -= 1\n                nums[idx] = key\n                count += dfs(idx + 1)\n                counter[key] += 1\n\n        return count\n\n    key_set, counter = set(nums), Counter(nums)\n    return dfs(0)", "def findJudge(n, trust):\n    trust_counts = [0] * (n + 1)\n    for a, b in trust:\n        trust_counts[a] -= 1\n        trust_counts[b] += 1\n    for i in range(1, n + 1):\n        if trust_counts[i] == n - 1:\n            return i\n    return -1", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef is_complete_tree(root: TreeNode) -> bool:\n    if not root:\n        return True\n    \n    queue = [root]\n    while queue[0]:\n        node = queue.pop(0)\n        queue.append(node.left)\n        queue.append(node.right)\n    while queue and not queue[0]:\n        queue.pop(0)\n    return not queue", "def regionsBySlashes(grid):\n    n = len(grid)\n    graph = [[0] * (n * 3) for _ in range(n * 3)]\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == '/':\n                graph[i * 3][j * 3 + 2] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3] = 1\n            if grid[i][j] == '\\\\':\n                graph[i * 3][j * 3] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3 + 2] = 1\n\n    regions = 0\n    for i in range(n * 3):\n        for j in range(n * 3):\n            if not graph[i][j]:\n                regions += 1\n                dfs(graph, i, j)\n\n    return regions\n\ndef dfs(graph, i, j):\n    n = len(graph)\n    if i < 0 or j < 0 or i >= n or j >= n or graph[i][j]:\n        return\n\n    graph[i][j] = 1\n    dfs(graph, i - 1, j)\n    dfs(graph, i + 1, j)\n    dfs(graph, i, j - 1)\n    dfs(graph, i, j + 1)", "def min_deletion_size(strs):\n    rows, cols = len(strs), len(strs[0])\n    count = 0\n    for c in range(cols):\n        for r in range(1, rows):\n            if strs[r - 1][c] > strs[r][c]:\n                count += 1\n                break\n    return count", "def repeatedNTimes(nums):\n    hash_map = {}\n    for num in nums:\n        if num in hash_map:\n            return num\n        else:\n            hash_map[num] = 1", "from collections import defaultdict\nfrom math import sqrt, inf\n\ndef minAreaFreeRect(points):\n    minArea = inf\n    xGroups = defaultdict(set)\n\n    for x, y in points:\n        xGroups[x].add(y)\n\n    for x1, ys1 in xGroups.items():\n        for x2, ys2 in xGroups.items():\n            if x1 == x2:\n                continue\n\n            for y1 in ys1:\n                for y2 in ys2:\n                    if y2 in ys1 and y1 in ys2:\n                        area = sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) * sqrt((x1 - x2) ** 2 + (y1 - y1) ** 2)\n                        minArea = min(minArea, area)\n\n    return minArea if minArea != inf else 0", "def least_ops_express_target(x, target):\n    if x == target:\n        return 0\n    if target == 1:\n        return 1\n    if x > target:\n        return min(2 * target - 1, 2 * (x - target))\n\n    k = 0\n    p = x\n    while p < target:\n        k += 1\n        p *= x\n\n    ans = float('inf')\n    d = 1\n\n    for i in range(k - 1, -1, -1):\n        while p >= target + d * (1 - x):\n            p -= d\n            ans = min(ans, i + int(math.log2(target // d) + 1) + int(d == 1 and -1 or 0))\n        d = d * x + 1\n\n    return ans", "def is_univalued(root, val=None):\n    if not root:\n        return True\n    if val is None:\n        val = root.val\n    return root.val == val and is_univalued(root.left, val) and is_univalued(root.right, val)", "def spellchecker(wordlist, queries):\n    word_map = {word: word for word in wordlist}\n    word_map_lower_case = {word.lower(): word for word in wordlist if word.lower() not in word_map_lower_case}\n    word_map_vowel_replaced = {replace_vowels(word.lower()): word for word in wordlist if replace_vowels(word.lower()) not in word_map_vowel_replaced}\n\n    result = []\n    for query in queries:\n        lower_query = query.lower()\n        vowel_replaced_query = replace_vowels(lower_query)\n\n        if query in word_map:\n            result.append(word_map[query])\n        elif lower_query in word_map_lower_case:\n            result.append(word_map_lower_case[lower_query])\n        elif vowel_replaced_query in word_map_vowel_replaced:\n            result.append(word_map_vowel_replaced[vowel_replaced_query])\n        else:\n            result.append(\"\")\n\n    return result\n\n\ndef replace_vowels(word):\n    return ''.join(['#' if ch in 'aeiou' else ch for ch in word])", "def numsSameConsecDiff(n, k):\n    result = []\n    if n == 1: result.append(0)\n\n    def dfs(current):\n        if len(current) == n:\n            result.append(int(current))\n            return\n\n        last_digit = current[-1]\n        if last_digit - k >= 0: dfs(current + str(last_digit - k))\n        if k != 0 and last_digit + k <= 9: dfs(current + str(last_digit + k))\n\n    for i in range(1, 10):\n        dfs(str(i))\n\n    return result", "def min_camera_cover(root):\n    ans = [0]\n    return (dfs(root, ans) < 1) + ans[0]\n\ndef dfs(node, ans):\n    if not node:\n        return 2\n    left = dfs(node.left, ans)\n    right = dfs(node.right, ans)\n    if left == 0 or right == 0:\n        ans[0] += 1\n        return 1\n    return 2 if left == 1 or right == 1 else 0", "def pancakeSort(arr):\n    flips = []\n    for size in range(len(arr), 1, -1):\n        maxIdx = arr.index(max(arr[:size]))\n        flips.extend([maxIdx + 1, size])\n        arr[:maxIdx + 1] = reversed(arr[:maxIdx + 1])\n        arr[:size] = reversed(arr[:size])\n    return flips", "def powerful_integers(x, y, bound):\n    result = set()\n    for i in range(20):\n        for j in range(20):\n            val = x**i + y**j\n            if val <= bound:\n                result.add(val)\n    return list(result)", "def flipRecur(node, voyage, flipped, idx):\n    if not node:\n        return idx\n    if node.val != voyage[idx]:\n        flipped[0] = -1\n        return idx\n    idx += 1\n    if (idx < len(voyage) and node.left and\n            node.left.val != voyage[idx]):\n        flipped.append(node.val)\n        idx = flipRecur(node.right, voyage, flipped, idx)\n        idx = flipRecur(node.left, voyage, flipped, idx)\n    else:\n        idx = flipRecur(node.left, voyage, flipped, idx)\n        idx = flipRecur(node.right, voyage, flipped, idx)\n    return idx\n\n\ndef flipMatchVoyage(root, voyage):\n    flipped = []\n    flipRecur(root, voyage, flipped, 0)\n    if flipped and flipped[0] == -1:\n        return [-1]\n    return flipped", "def isRationalEqual(s: str, t: str) -> bool:\n    def evaluate(s: str) -> float:\n        i = s.find('(')\n        if i != -1:\n            base = s[:i]\n            rep = s[i + 1:-1]\n            return float(base + rep * 20)\n        return float(s)\n\n    return abs(evaluate(s) - evaluate(t)) < 1e-12", "def fib(n):\n    if n <= 1:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b", "def kClosest(points, k):\n    points.sort(key=lambda x: x[0] ** 2 + x[1] ** 2)\n    return points[:k]", "def smallestRepunitDivByK(k: int) -> int:\n    if k % 2 == 0 or k % 5 == 0:\n        return -1\n    n = 0\n    for i in range(1, k + 1):\n        n = (n * 10 + 1) % k\n        if n == 0:\n            return i\n    return -1", "def subarraysDivByK(nums, k):\n    counts = {0: 1}\n    sum_, result = 0, 0\n    \n    for num in nums:\n        sum_ += num\n        mod = (sum_ % k + k) % k\n        result += counts.get(mod, 0)\n        counts[mod] = counts.get(mod, 0) + 1\n    \n    return result", "def odd_even_jumps(arr):\n    n = len(arr)\n    can_reach_odd = [False] * n\n    can_reach_even = [False] * n\n    can_reach_odd[-1] = can_reach_even[-1] = True\n\n    index_map = {}\n    index_map[arr[-1]] = n - 1\n\n    good_indices = 1\n    for i in range(n - 2, -1, -1):\n        odd_jump = next(iter([value for value in index_map if value >= arr[i]]), None)\n        even_jump = next(iter([value for value in index_map if value <= arr[i]]), None)\n\n        if odd_jump is not None:\n            can_reach_odd[i] = can_reach_even[index_map[odd_jump]]\n        if even_jump is not None:\n            can_reach_even[i] = can_reach_odd[index_map[even_jump]]\n\n        if can_reach_odd[i]:\n            good_indices += 1\n\n        index_map[arr[i]] = i\n\n    return good_indices", "def largestPerimeter(nums):\n    nums.sort(reverse=True)\n\n    for i in range(len(nums) - 2):\n        if nums[i] < nums[i + 1] + nums[i + 2]:\n            return nums[i] + nums[i + 1] + nums[i + 2]\n\n    return 0", "def sortedSquares(nums):\n    return sorted([x ** 2 for x in nums])", "def maxTurbulenceSize(arr):\n    n = len(arr)\n    result = 1\n    i = 0\n\n    while i < n - 1:\n        if arr[i] == arr[i + 1]:\n            i += 1\n            continue\n\n        j = i + 1\n        while j < n - 1 and ((arr[j] > arr[j + 1]) != (arr[j - 1] > arr[j])):\n            j += 1\n        \n        result = max(result, j - i + 1)\n        i = j\n\n    return result", "def distributeCoins(root):\n    def dfs(node):\n        if not node:\n            return 0\n        left, right = dfs(node.left), dfs(node.right)\n        moves[0] += abs(left) + abs(right)\n        return node.val + left + right - 1\n\n    moves = [0]\n    dfs(root)\n    return moves[0]", "def uniquePathsIII(grid):\n    x, y, empty = 0, 0, 1\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                x, y = i, j\n            elif grid[i][j] == 0:\n                empty += 1\n    return dfs(grid, x, y, empty)\n\ndef dfs(grid, x, y, empty):\n    if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == -1:\n        return 0\n    if grid[x][y] == 2:\n        return 1 if empty == -1 else 0\n    grid[x][y] = -1\n    paths = dfs(grid, x + 1, y, empty - 1) + dfs(grid, x - 1, y, empty - 1) + dfs(grid, x, y + 1, empty - 1) + dfs(grid, x, y - 1, empty - 1)\n    grid[x][y] = 0\n    return paths", "from collections import defaultdict\nimport bisect\n\nclass TimeMap:\n\n    def __init__(self):\n        self.data = defaultdict(list)\n\n    def set(self, key, value, timestamp):\n        self.data[key].append((timestamp, value))\n\n    def get(self, key, timestamp):\n        if key not in self.data: return \"\"\n        index = bisect.bisect(self.data[key], (timestamp + 1,))\n        return self.data[key][index-1][1] if index else \"\"", "def count_and_triples(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if nums[i] & nums[j] & nums[k] != 0:\n                    count += 1\n    return count", "def mincostTickets(days, costs):\n  travel_days = set(days)\n  dp = [0] * 366\n\n  for i in range(1, 366):\n    if i not in travel_days:\n      dp[i] = dp[i - 1]\n    else:\n      dp[i] = min(dp[i - 1] + costs[0],\n                  dp[max(0, i - 7)] + costs[1],\n                  dp[max(0, i - 30)] + costs[2])\n\n  return dp[365]", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxAncestorDiff(root: TreeNode) -> int:\n    def helper(node, mn, mx):\n        if node is None:\n            return mx - mn\n\n        mx = max(mx, node.val)\n        mn = min(mn, node.val)\n\n        left_diff = helper(node.left, mn, mx)\n        right_diff = helper(node.right, mn, mx)\n\n        return max(left_diff, right_diff)\n\n    return helper(root, root.val, root.val)", "def sumEvenAfterQueries(nums, queries):\n    answer = []\n    even_sum = sum(num for num in nums if num % 2 == 0)\n\n    for value, index in queries:\n        if nums[index] % 2 == 0:\n            even_sum -= nums[index]\n        nums[index] += value\n        if nums[index] % 2 == 0:\n            even_sum += nums[index]\n        answer.append(even_sum)\n\n    return answer", "def interval_intersection(firstList, secondList):\n    result = []\n    i, j = 0, 0\n\n    while i < len(firstList) and j < len(secondList):\n        start = max(firstList[i][0], secondList[j][0])\n        end = min(firstList[i][1], secondList[j][1])\n\n        if start <= end:\n            result.append([start, end])\n\n        if firstList[i][1] < secondList[j][1]:\n            i += 1\n        else:\n            j += 1\n\n    return result", "from collections import defaultdict, deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef verticalTraversal(root):\n    if not root:\n        return []\n\n    columns = defaultdict(lambda: defaultdict(list))\n    q = deque([(root, 0, 0)])\n\n    while q:\n        node, row, col = q.popleft()\n        columns[col][row].append(node.val)\n        columns[col][row].sort()\n\n        if node.left:\n            q.append((node.left, row + 1, col - 1))\n        if node.right:\n            q.append((node.right, row + 1, col + 1))\n\n    return [[val for row in column_data.values() for val in row] for column_data in sorted(columns.values())]", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def smallestFromLeaf(self, root: TreeNode) -> str:\n        if not root:\n            return \"|\"\n        s = chr(root.val + 97)\n        if not root.left and not root.right:\n            return s\n        left = self.smallestFromLeaf(root.left)\n        right = self.smallestFromLeaf(root.right)\n        return min(left, right) + s", "def add_to_array_form(num, k):\n    for i in range(len(num) - 1, -1, -1):\n        k, num[i] = divmod(num[i] + k, 10)\n        if k == 0:\n            break\n    while k:\n        k, digit = divmod(k, 10)\n        num.insert(0, digit)\n    return num", "def equationsPossible(equations):\n    parent = [i for i in range(26)]\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    for e in equations:\n        if e[1] == '=':\n            x = ord(e[0]) - ord('a')\n            y = ord(e[3]) - ord('a')\n            parent[find(x)] = find(y)\n\n    for e in equations:\n        if e[1] == '!' and find(ord(e[0]) - ord('a')) == find(ord(e[3]) - ord('a')):\n            return False\n\n    return True", "def broken_calc(startValue: int, target: int) -> int:\n    operations = 0\n    while target > startValue:\n        target = target // 2 if target % 2 == 0 else target + 1\n        operations += 1\n    return operations + startValue - target", "def good_subarrays(nums, k):\n    count = 0\n    for i in range(len(nums)):\n        frequency = {}\n        for j in range(i, len(nums)):\n            frequency[nums[j]] = frequency.get(nums[j], 0) + 1\n            if len(frequency) > k:\n                break\n            if len(frequency) == k:\n                count += 1\n    return count", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isCousins(self, root, x, y):\n        def findDepth(node, search_val, depth):\n            if not node:\n                return -1\n            if node.val == search_val:\n                return depth\n            left_depth = findDepth(node.left, search_val, depth + 1)\n            if left_depth != -1:\n                return left_depth\n            return findDepth(node.right, search_val, depth + 1)\n\n        def findParent(node, search_val):\n            if not node or not (node.left or node.right):\n                return None\n            if (node.left and node.left.val == search_val) or (node.right and node.right.val == search_val):\n                return node\n            left_parent = findParent(node.left, search_val)\n            if left_parent:\n                return left_parent\n            return findParent(node.right, search_val)\n\n        x_depth = findDepth(root, x, 0)\n        y_depth = findDepth(root, y, 0)\n        x_parent = findParent(root, x)\n        y_parent = findParent(root, y)\n        return (x_depth == y_depth) and (x_parent != y_parent)", "from collections import deque\n\ndef orangesRotting(grid):\n    m, n = len(grid), len(grid[0])\n    fresh_oranges = sum(row.count(1) for row in grid)\n    rotten = deque([(i, j) for i, row in enumerate(grid) for j, value in enumerate(row) if value == 2])\n    \n    minutes = 0\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    while rotten and fresh_oranges:\n        for _ in range(len(rotten)):\n            x, y = rotten.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:\n                    grid[nx][ny] = 2\n                    fresh_oranges -= 1\n                    rotten.append((nx, ny))\n        minutes += 1\n\n    return minutes if fresh_oranges == 0 else -1", "def min_k_bit_flips(nums, k):\n    n, res, flipped = len(nums), 0, 0\n    change = [0] * n\n    for i in range(n - k + 1):\n        flipped ^= change[i]\n        if nums[i] == flipped:\n            res += 1\n            flipped ^= 1\n            if i + k < n:\n                change[i + k] ^= 1\n    for i in range(n - k + 1, n):\n        flipped ^= change[i]\n        if nums[i] == flipped:\n            return -1\n    return res", "from math import sqrt\nfrom itertools import permutations\n\ndef is_squareful(x, int_y):\n    s = int(sqrt(x + y))\n    return s * s == x + y\n\ndef squareful_perms(nums):\n    count = 0\n    for p in permutations(nums):\n        if all(is_squareful(p[i], p[i + 1]) for i in range(len(p) - 1)):\n            count += 1\n    return count", "def find_judge(n, trust):\n    trustCounts = [0] * (n + 1)\n    for a, b in trust:\n        trustCounts[a] -= 1\n        trustCounts[b] += 1\n\n    for i in range(1, n + 1):\n        if trustCounts[i] == n - 1:\n            return i\n    return -1", "def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:\n    if root is None or val > root.val:\n        newNode = TreeNode(val)\n        newNode.left = root\n        return newNode\n    root.right = self.insertIntoMaxTree(root.right, val)\n    return root", "def numRookCaptures(board):\n    x, y, captures = 0, 0, 0\n\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'R':\n                x, y = i, j\n                break\n        if board[x][y] == 'R':\n            break\n\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    for dx, dy in dirs:\n        nx, ny = x + dx, y + dy\n        while 0 <= nx < 8 and 0 <= ny < 8:\n            if board[nx][ny] == 'p':\n                captures += 1\n                break\n            elif board[nx][ny] == 'B':\n                break\n            nx += dx\n            ny += dy\n\n    return captures", "def mergeStones(stones, k):\n    n = len(stones)\n    if (n - 1) % (k - 1) != 0:\n        return -1\n    prefixSum = [0] * (n + 1)\n    dp = [[[-1] * (k + 1) for _ in range(n)] for _ in range(n)]\n\n    for i in range(n):\n        prefixSum[i + 1] = prefixSum[i] + stones[i]\n\n    for l in range(2, n + 1):\n        for i in range(n - l + 1):\n            j = i + l - 1\n            for m in range(2, k + 1):\n                for p in range(i, j + 1 - m + 1, k - 1):\n                    dp[i][j][m] = (dp[i][p][1] + dp[p + 1][j][m - 1]) % (1e9 + 7)\n            if (j - i) % (k - 1) == 0:\n                dp[i][j][1] = (dp[i][j][k] + prefixSum[j + 1] - prefixSum[i]) % (1e9 + 7)\n\n    return dp[0][n - 1][1]", "def grid_illumination(n, lamps, queries):\n    lamp_rows = set()\n    lamp_cols = set()\n    lamp_left_diag = set()\n    lamp_right_diag = set()\n\n    for lamp in lamps:\n        row, col = lamp\n        lamp_rows.add(row)\n        lamp_cols.add(col)\n        lamp_left_diag.add(row - col)\n        lamp_right_diag.add(row + col)\n\n    ans = []\n\n    for query in queries:\n        row, col = query\n        if row in lamp_rows or col in lamp_cols or (row - col) in lamp_left_diag or (row + col) in lamp_right_diag:\n            ans.append(1)\n        else:\n            ans.append(0)\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                newRow, newCol = row + i, col + j\n                lamp_rows.discard(newRow)\n                lamp_cols.discard(newCol)\n                lamp_left_diag.discard(newRow - newCol)\n                lamp_right_diag.discard(newRow + newCol)\n\n    return ans", "from collections import Counter\n\ndef commonChars(words):\n    merged = Counter()\n    for word in words:\n        word_count = Counter(word)\n        if not merged:\n            merged = word_count\n        else:\n            for char in merged:\n                merged[char] = min(merged[char], word_count[char])\n\n    result = []\n    for char, count in merged.items():\n        result.extend([char] * count)\n    return result", "def longestOnes(nums, k):\n    left, right, max_ones, zero_count = 0, 0, 0, 0\n    while right < len(nums):\n        if nums[right] == 0:\n            zero_count += 1\n        while zero_count > k:\n            if nums[left] == 0:\n                zero_count -= 1\n            left += 1\n        max_ones = max(max_ones, right - left + 1)\n        right += 1\n    return max_ones", "import heapq\n\ndef maxSumAfterKOperations(nums, k):\n    heapq.heapify(nums)\n    for _ in range(k):\n        current = heapq.heappop(nums)\n        heapq.heappush(nums, -current)\n    return sum(nums)", "def clumsy(n: int) -> int:\n    if n <= 2:\n        return n\n    if n == 3:\n        return 6\n    result = n * (n - 1) // (n - 2) + (n - 3)\n    n -= 4\n    while n >= 4:\n        result = result - (n * (n - 1) // (n - 2)) + (n - 3)\n        n -= 4\n    return result - clumsy(n)", "def min_rotations(tops, bottoms):\n    res = float('inf')\n\n    for target in (tops[0], bottoms[0]):\n        top_rot, bot_rot = 0, 0\n        for ti, bi in zip(tops, bottoms):\n            if ti != target and bi != target:\n                top_rot = bot_rot = float('inf')\n                break\n            top_rot += ti != target\n            bot_rot += bi != target\n\n        res = min(res, top_rot, bot_rot)\n\n    return -1 if res == float('inf') else res", "def height_checker(heights):\n    expected = sorted(heights)\n    \n    count = 0\n    for i in range(len(heights)):\n        if heights[i] != expected[i]:\n            count += 1\n            \n    return count", "def maxSatisfied(customers, grumpy, minutes):\n    total_customers = 0\n    max_extra_customers = 0\n    extra_customers = 0\n    for i in range(len(customers)):\n        if grumpy[i] == 0:\n            total_customers += customers[i]\n        if i < minutes:\n            extra_customers += customers[i] * grumpy[i]\n        else:\n            extra_customers += (customers[i] * grumpy[i]) - (customers[i - minutes] * grumpy[i - minutes])\n        max_extra_customers = max(max_extra_customers, extra_customers)\n    return total_customers + max_extra_customers", "def prevPermOpt1(arr):\n    n = len(arr)\n    for i in range(n - 2, -1, -1):\n        if arr[i] > arr[i + 1]:\n            j = i + 1\n            while j < n and arr[j] < arr[i]:\n                j += 1\n            arr[i], arr[j - 1] = arr[j - 1], arr[i]\n            break\n    return arr", "def bitwise_complement(n):\n    x = 1\n    while n > x:\n        x = x * 2 + 1\n    return x - n", "def num_pairs_divisible_by60(time):\n    count = [0] * 60\n    pairs = 0\n\n    for t in time:\n        mod = t % 60\n        pairs += count[(60 - mod) % 60]\n        count[mod] += 1\n\n    return pairs", "def num_dup_digits_at_most_n(n):\n    count = 0\n    for i in range(1, n + 1):\n        digits = set()\n        num = i\n        while num != 0:\n            digit = num % 10\n            if digit in digits:\n                count += 1\n                break\n            else:\n                digits.add(digit)\n            num //= 10\n    return count", "from math import floor, ceil\n\ndef find_rounding_error(prices, target):\n    n = len(prices)\n    decimals = [float(price) - floor(float(price)) for price in prices]\n    rounded_sum = sum(floor(float(price)) for price in prices)\n\n    if target < rounded_sum or target > rounded_sum + n:\n        return \"-1 \"\n\n    ceil_count = target - rounded_sum\n    rounding_error = 0.0\n\n    for d in decimals:\n        if ceil_count > 0:\n            rounding_error += 1 - d\n            ceil_count -= 1\n        else:\n            rounding_error += d\n\n    return f\"{rounding_error:.3f} \"", "from collections import defaultdict\n\ndef leadsToDestination(n, edges, source, destination):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n\n    visited = [0] * n\n    return dfs(source, graph, visited, destination)\n\ndef dfs(node, graph, visited, destination):\n    if node not in graph:\n        return node == destination\n    if visited[node] != 0:\n        return visited[node] == 2\n\n    visited[node] = 1\n    for neighbor in graph[node]:\n        if not dfs(neighbor, graph, visited, destination):\n            return False\n\n    visited[node] = 2\n    return True", "def findKthPositive(nums, k):\n    left, right = 0, len(nums)\n    while left < right:\n        mid = left + (right - left) // 2\n        if nums[mid] - mid - 1 < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left + k", "def lex_smallest_equivalent(s1, s2, base_str):\n    parent = {chr(ch): chr(ch) for ch in range(ord('a'), ord('z') + 1)}\n\n    for c1, c2 in zip(s1, s2):\n        root1, root2 = c1, c2\n        while parent[root1] != root1:\n            root1 = parent[root1]\n        while parent[root2] != root2:\n            root2 = parent[root2]\n        if root1 != root2:\n            min_root = min(root1, root2)\n            parent[root1] = min_root\n            parent[root2] = min_root\n\n    return ''.join(parent[ch] for ch in base_str)", "def find_longest_repeating_substring(s: str) -> int:\n    n = len(s)\n    max_substr_length = 0\n    for length in range(1, n // 2 + 1):\n        max_repeat_count = repeat_count = 0\n        for i in range(n - length):\n            if s[i:i + length] == s[i + length:i + 2 * length]:\n                repeat_count += 1\n            else:\n                max_repeat_count = max(max_repeat_count, repeat_count)\n                repeat_count = 0\n        max_substr_length = max(max_substr_length, max_repeat_count * length)\n    return max_substr_length", "def maxScoreSightseeingPair(values):\n    max_score = 0\n    max_score_left = values[0] + 0\n    for j in range(1, len(values)):\n        max_score = max(max_score, max_score_left + values[j] - j)\n        max_score_left = max(max_score_left, values[j] + j)\n    return max_score", "def fixedPoint(arr: List[int]) -> int:\n    left, right = 0, len(arr) - 1\n    while left < right:\n        middle = left + (right - left) // 2\n        if arr[middle] < middle:\n            left = middle + 1\n        else:\n            right = middle\n    return left if arr[left] == left else -1", "def has_all_codes_in_range(s: str, n: int) -> bool:\n    substrings = set()\n    length = len(bin(n)) - 2\n    for i in range(len(s) - length + 1):\n        substrings.add(s[i:i + length])\n    return len(substrings) == n", "from typing import List\n\ndef manhattan_distance(worker: List[int], bike: List[int]) -> int:\n    return abs(worker[0] - bike[0]) + abs(worker[1] - bike[1])\n\ndef dfs(workers: List[List[int]], bikes: List[List[int]], used: List[bool], index: int, dist: int, min_dist: List[int]) -> None:\n    if index == len(workers):\n        min_dist[0] = min(min_dist[0], dist)\n        return\n\n    if dist >= min_dist[0]:\n        return\n\n    for i in range(len(bikes)):\n        if used[i]:\n            continue\n        used[i] = True\n        cur_dist = manhattan_distance(workers[index], bikes[i])\n        dfs(workers, bikes, used, index + 1, dist + cur_dist, min_dist)\n        used[i] = False\n\ndef assign_bikes(workers: List[List[int]], bikes: List[List[int]]) -> int:\n    min_dist = [float('inf')]\n    used = [False] * len(bikes)\n    dfs(workers, bikes, used, 0, 0, min_dist)\n    return min_dist[0]", "def count_digit(d, low, high):\n    count = 0\n    for i in range(low, high + 1):\n        num = i\n        while num > 0:\n            if num % 10 == d:\n                count += 1\n            num //= 10\n    return count", "def prefixesDivBy5(nums):\n    result = []\n    current = 0\n    for num in nums:\n        current = ((current << 1) | num) % 5\n        result.append(current == 0)\n    return result", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef nextGreaterNodes(head):\n    result = []\n    stack = []\n    while head:\n        while stack and stack[-1] < head.val:\n            stack[-1] = head.val\n            stack.pop()\n        result.append(head.val)\n        stack.append(len(result) - 1)\n        head = head.next\n\n    while stack:\n        result[stack.pop()] = 0\n\n    return result", "from collections import deque\n\ndef addNegabinary(arr1, arr2):\n    res = deque()\n    carry, i, j = 0, len(arr1) - 1, len(arr2) - 1\n    while i >= 0 or j >= 0 or carry:\n        if i >= 0: carry += arr1[i]; i -= 1\n        if j >= 0: carry += arr2[j]; j -= 1\n        res.appendleft(carry & 1)\n        carry = -(carry >> 1)\n    while len(res) > 1 and res[0] == 0: res.popleft()\n    return list(res)", "def numSubmatrixSumTarget(matrix: List[List[int]], target: int) -> int:\n    rows, cols = len(matrix), len(matrix[0])\n    for row in range(rows):\n        for col in range(1, cols):\n            matrix[row][col] += matrix[row][col-1]\n    \n    count = 0\n    for col1 in range(cols):\n        for col2 in range(col1, cols):\n            counter = collections.defaultdict(int)\n            counter[0] = 1\n            cur_sum = 0\n            for row in range(rows):\n                cur_sum += matrix[row][col2] - (matrix[row][col1-1] if col1 > 0 else 0)\n                count += counter[cur_sum - target]\n                counter[cur_sum] += 1\n\n    return count", "def remove_outer_parentheses(s: str) -> str:\n    result = []\n    opened = 0\n\n    for c in s:\n        if c == '(':\n            if opened > 0:\n                result.append(c)\n            opened += 1\n        elif c == ')':\n            if opened > 1:\n                result.append(c)\n            opened -= 1\n\n    return ''.join(result)", "def sumRootToLeaf(root, path_value=0):\n    if not root:\n        return 0\n    path_value = path_value * 2 + root.val\n    if not root.left and not root.right:\n        return path_value\n    return sumRootToLeaf(root.left, path_value) + sumRootToLeaf(root.right, path_value)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        if not root:\n            return None\n        if not root.left and not root.right:\n            if root.val < limit:\n                return None\n            return root\n        root.left = self.sufficientSubset(root.left, limit - root.val)\n        root.right = self.sufficientSubset(root.right, limit - root.val)\n        if not root.left and not root.right:\n            return None\n\n        return root", "def videoStitching(clips, time):\n    dp = [float('inf')] * (time + 1)\n    dp[0] = 0\n    for i in range(1, time + 1):\n        for clip in clips:\n            if clip[0] < i and i <= clip[1]:\n                dp[i] = min(dp[i], dp[clip[0]] + 1)\n    return -1 if dp[time] == float('inf') else dp[time]", "def sum_of_digits(nums):\n    min_val = min(nums)\n    digit_sum = sum(int(digit) for digit in str(min_val))\n    return 1 if digit_sum % 2 == 0 else 0", "def alice_win(n):\n    return n % 2 == 0", "def longestArithSeqLength(nums):\n    n = len(nums)\n    longest = 0\n    dp = [{} for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            dp[i][diff] = dp[j].get(diff, 1) + 1\n            longest = max(longest, dp[i][diff])\n    \n    return longest", "def confusingNumberII(n):\n    def helper(current):\n        nonlocal count, validNums\n        for num in validNums:\n            next_num = current * 10 + num\n            if next_num > n:\n                break\n            if current != 0 or next_num != 0:\n                if next_num != rotate(next_num):\n                    count += 1\n                count = helper(next_num)\n        return count\n\n    def rotate(num):\n        rotated = 0\n        original = num\n        while num > 0:\n            digit = num % 10\n            if digit in (2, 3, 4, 5, 7):\n                return original\n            revd = {0: 0, 1: 1, 6: 9, 8: 8, 9: 6}\n            rotated = rotated * 10 + revd[digit]\n            num //= 10\n        return rotated\n\n    count = 0\n    validNums = [0, 1, 6, 8, 9]\n    return helper(0)", "def duplicateZeros(arr):\n    n = len(arr)\n    i = 0\n    while i < n - 1:\n        if arr[i] == 0:\n            for j in range(n - 1, i + 1, -1):\n                arr[j] = arr[j - 1]\n            arr[i + 1] = 0\n            i += 1\n        i += 1", "from typing import List\n\ndef largestValsFromLabels(values: List[int], labels: List[int], numWanted: int, useLimit: int) -> int:\n    items = list(zip(values, labels))\n    items.sort(key=lambda x: x[0], reverse=True)\n\n    label_count = {}\n    ans = 0\n\n    for value, label in items:\n        if label not in label_count:\n            label_count[label] = 0\n        if label_count[label] < useLimit:\n            ans += value\n            label_count[label] += 1\n            numWanted -= 1\n            if numWanted == 0:\n                break\n\n    return ans", "from collections import deque\n\ndef shortestPathBinaryMatrix(grid):\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]: return -1\n\n    dir = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n    q = deque([(0, 0)])\n    grid[0][0] = 1\n\n    pathLength = 1\n\n    while q:\n        qlen = len(q)\n        for _ in range(qlen):\n            x, y = q.popleft()\n\n            if x == n - 1 and y == n - 1: return pathLength\n\n            for d in dir:\n                newX, newY = x + d[0], y + d[1]\n\n                if 0 <= newX < n and 0 <= newY < n and grid[newX][newY] == 0:\n                    q.append((newX, newY))\n                    grid[newX][newY] = 1\n        pathLength += 1\n\n    return -1", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef dfs(node):\n    if not node:\n        return 0, float('inf'), float('-inf')\n    left_diff, left_min, left_max = dfs(node.left)\n    right_diff, right_min, right_max = dfs(node.right)\n    mn = min(node.val, left_min, right_min)\n    mx = max(node.val, left_max, right_max)\n    return max(max(left_diff, right_diff), max(abs(node.val - left_min), abs(node.val - right_max))), mn, mx\n\ndef maxAncestorDiff(root):\n    diff, _, _ = dfs(root)\n    return diff", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef recoverFromPreorder(S: str) -> TreeNode:\n    def helper() -> TreeNode:\n        nonlocal depth, index\n        num_dashes = 0\n        while index < len(S) and S[index] == '-':\n            num_dashes += 1\n            index += 1\n        if num_dashes != depth:\n            index -= num_dashes\n            return None\n        val = 0\n        while index < len(S) and S[index].isdigit():\n            val = val * 10 + int(S[index])\n            index += 1\n        node = TreeNode(val)\n        depth += 1\n        node.left = helper()\n        node.right = helper()\n        depth -= 1\n        return node\n\n    depth, index = 0, 0\n    return helper()", "def allCellsDistOrder(rows, cols, rCenter, cCenter):\n    coordinates = [[i, j] for i in range(rows) for j in range(cols)]\n\n    coordinates.sort(key=lambda x: abs(x[0] - rCenter) + abs(x[1] - cCenter))\n\n    return coordinates", "def twoCitySchedCost(costs):\n    costs.sort(key=lambda x: x[0] - x[1])\n\n    totalCost = 0\n    n = len(costs) // 2\n\n    for i in range(n):\n        totalCost += costs[i][0] + costs[i + n][1]\n\n    return totalCost", "class Solution:\n    def braceExpansionII(self, expression: str) -> List[str]:\n        def parse(expr: str, i: int) -> Set[str]:\n            result, current = set(), {\"\"}\n            while i < len(expr):\n                if expr[i] == '{':\n                    update = set()\n                    for postfix in parse(expr, i + 1):\n                        for prefix in current:\n                            update.add(prefix + postfix)\n                    current = update\n                    i = expr.index('}', i)\n                elif expr[i] == '}':\n                    break\n                elif expr[i] == ',':\n                    result |= current\n                    current = {\"\"}\n                else:\n                    current = {s + expr[i] for s in current}\n                i += 1\n            return result | current\n        \n        return sorted(parse(expression, 0))", "def max_sum_under_k(nums, k):\n    max_sum = -1\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            _sum = nums[i] + nums[j]\n            if _sum < k and _sum > max_sum:\n                max_sum = _sum\n    return max_sum", "def num_k_len_substr_no_repeats(s: str, k: int) -> int:\n    n = len(s)\n    if k > n:\n        return 0\n\n    result = 0\n    window = set()\n\n    i = 0\n    for j in range(n):\n        while s[j] in window:\n            window.remove(s[i])\n            i += 1\n        window.add(s[j])\n        if j - i + 1 == k:\n            result += 1\n            window.remove(s[i])\n            i += 1\n\n    return result", "def earliestAcq(logs, n):\n    def find(x):\n        if x != parents[x]:\n            parents[x] = find(parents[x])\n        return parents[x]\n\n    parents = list(range(n))\n    logs.sort()\n\n    group_count = n\n    for timestamp, x, y in logs:\n        root_x, root_y = find(x), find(y)\n        if root_x != root_y:\n            parents[root_x] = root_y\n            group_count -= 1\n        if group_count == 1:\n            return timestamp\n    return -1", "def maxScore(grid):\n    m, n = len(grid), len(grid[0])\n\n    for i in range(1, n):\n        grid[0][i] = min(grid[0][i], grid[0][i - 1])\n\n    for i in range(1, m):\n        grid[i][0] = min(grid[i][0], grid[i - 1][0])\n\n        for j in range(1, n):\n            grid[i][j] = max(min(grid[i - 1][j], grid[i][j]), min(grid[i][j - 1], grid[i][j]))\n\n    return grid[m - 1][n - 1]", "def distribute_candies(candies, num_people):\n    result = [0] * num_people\n    i = 0\n    count = 1\n\n    while candies > 0:\n        result[i % num_people] += min(candies, count)\n        candies -= count\n        count += 1\n        i += 1\n\n    return result", "def colorBorder(grid, row, col, color):\n    def dfs(grid, row, col, current, color):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != current:\n            return\n\n        grid[row][col] = color\n        dfs(grid, row - 1, col, current, color)\n        dfs(grid, row + 1, col, current, color)\n        dfs(grid, row, col - 1, current, color)\n        dfs(grid, row, col + 1, current, color)\n\n    current = grid[row][col]\n    if current == color:\n        return grid\n\n    dfs(grid, row, col, current, color + 1000)\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] > 1000:\n                grid[i][j] -= 1000\n\n    return grid", "def max_uncrossed_lines(nums1, nums2):\n    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]", "MAX_STEPS = 200\n\ndef isEscapePossible(blocked, source, target):\n    blockedSet = set([\"{}_{}\".format(block[0], block[1]) for block in blocked])\n    visited = set()\n\n    def dfs(x, y, tx, ty, steps):\n        pos = \"{}_{}\".format(x, y)\n        if x < 0 or x >= 1000000 or y < 0 or y >= 1000000 or steps >= MAX_STEPS or pos in blockedSet or pos in visited:\n            return False\n\n        if x == tx and y == ty:\n            return True\n\n        visited.add(pos)\n\n        return (dfs(x + 1, y, tx, ty, steps + 1) or dfs(x, y + 1, tx, ty, steps + 1)\n                or dfs(x - 1, y, tx, ty, steps + 1) or dfs(x, y - 1, tx, ty, steps + 1))\n\n    return dfs(source[0], source[1], target[0], target[1], 0)", "def defangIPaddr(address: str) -> str:\n    return address.replace('.', '[.]')", "def corpFlightBookings(bookings, n):\n    seats = [0] * n\n    for booking in bookings:\n        seats[booking[0] - 1] += booking[2]\n        if booking[1] < n:\n            seats[booking[1]] -= booking[2]\n    for i in range(1, n):\n        seats[i] += seats[i - 1]\n    return seats", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef delNodes(root: TreeNode, to_delete):\n    to_delete_set = set(to_delete)\n    remaining_trees = []\n\n    def removeNodes(node):\n        if node is None:\n            return None\n        node.left = removeNodes(node.left)\n        node.right = removeNodes(node.right)\n        if node.val in to_delete_set:\n            if node.left:\n                remaining_trees.append(node.left)\n            if node.right:\n                remaining_trees.append(node.right)\n            return None\n        return node\n\n    if removeNodes(root):\n        remaining_trees.append(root)\n    return remaining_trees", "def minScoreTriangulation(values):\n    n = len(values)\n    dp = [[0] * n for _ in range(n)]\n\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = float('inf')\n            for k in range(i + 1, j):\n                dp[i][j] = min(dp[i][j], values[i] * values[j] * values[k] + dp[i][k] + dp[k][j])\n\n    return dp[0][n - 1]", "def number_of_days(year, month):\n    if month == 2:\n        if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:\n            return 29\n        return 28\n    if month in [4, 6, 9, 11]:\n        return 30\n    return 31", "def is_robot_bounded(instructions: str) -> bool:\n    x, y, dir = 0, 0, 0\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    for c in instructions:\n        if c == 'G':\n            x += moves[dir][0]\n            y += moves[dir][1]\n        elif c == 'L':\n            dir = (dir + 3) % 4\n        else:\n            dir = (dir + 1) % 4\n\n    return (x == 0 and y == 0) or dir != 0", "from collections import defaultdict\n\ndef gardenNoAdj(n, paths):\n    graph = defaultdict(set)\n    for x, y in paths:\n        graph[x - 1].add(y - 1)\n        graph[y - 1].add(x - 1)\n    \n    result = [0] * n\n    for i in range(n):\n        used_flowers = {result[neighbor] for neighbor in graph[i]}\n        for flower in range(1, 5):\n            if flower not in used_flowers:\n                result[i] = flower\n                break\n    return result", "def maxSumAfterPartitioning(arr: list, k: int) -> int:\n    n = len(arr)\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        current_max = 0\n        for j in range(1, k + 1):\n            if i - j < 0:\n                break\n            current_max = max(current_max, arr[i - j])\n            dp[i] = max(dp[i], dp[i - j] + current_max * j)\n    return dp[n]", "def longest_dup_substring(s):\n    n = len(s)\n    longest_duplicate = \"\"\n    for length in range(n - 1, 0, -1):\n        for i in range(n - length + 1):\n            substring = s[i:i + length]\n            if s.find(substring, i + 1) != -1:\n                longest_duplicate = substring\n                return longest_duplicate\n    return longest_duplicate", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef find_lca_util(root):\n    if root is None:\n        return None, 0\n\n    left_lca, left_depth = find_lca_util(root.left)\n    right_lca, right_depth = find_lca_util(root.right)\n\n    if left_depth > right_depth:\n        return left_lca, left_depth + 1\n    elif left_depth < right_depth:\n        return right_lca, right_depth + 1\n    else:\n        return root, left_depth + 1\n\ndef lca_deepest_leaves(root):\n    return find_lca_util(root)[0]", "def longestWellPerformingInterval(hours):\n    sum = 0\n    longest = 0\n    first_sum_index = {}\n\n    for i, hour in enumerate(hours):\n        sum += 1 if hour > 8 else -1\n        if sum > 0:\n            longest = i + 1\n        else:\n            if sum - 1 in first_sum_index:\n                longest = max(longest, i - first_sum_index[sum - 1])\n            if sum not in first_sum_index:\n                first_sum_index[sum] = i\n\n    return longest", "from collections import defaultdict\nfrom math import log2\n\ndef smallestSufficientTeam(req_skills, people):\n    skill_to_id = {skill: idx for idx, skill in enumerate(req_skills)}\n\n    n, m = len(people), len(req_skills)\n    dp = [float(\"inf\")] * (1 << m)\n    pre = [0] * (1 << m)\n    skill_set = [0] * (1 << m)\n\n    dp[0] = 0\n\n    for i, skills in enumerate(people):\n        skill_mask = sum(1 << skill_to_id[skill] for skill in skills)\n        for j in range((1 << m) - 1, -1, -1):\n            if dp[j | skill_mask] > dp[j] + 1:\n                dp[j | skill_mask] = dp[j] + 1\n                pre[j | skill_mask] = j\n                skill_set[j | skill_mask] = i\n\n    res = []\n    mask = (1 << m) - 1\n    while mask:\n        res.append(skill_set[mask])\n        mask = pre[mask]\n\n    return res", "def remove_duplicates(s: str) -> str:\n    stack = []\n    for c in s:\n        if stack and stack[-1] == c:\n            stack.pop()\n        else:\n            stack.append(c)\n    return \"\".join(stack)", "def longestStrChain(words):\n    words.sort(key=lambda x: len(x))\n    dp = {}\n\n    max_len = 0\n    for word in words:\n        for i in range(len(word)):\n            pre = word[:i] + word[i + 1:]\n            dp[word] = max(dp.get(word, 0), dp.get(pre, 0) + 1)\n        max_len = max(max_len, dp[word])\n\n    return max_len", "import heapq\n\ndef lastStoneWeight(stones):\n    stones = [-stone for stone in stones]\n    heapq.heapify(stones)\n    while len(stones) > 1:\n        y = -heapq.heappop(stones)\n        x = -heapq.heappop(stones)\n        if x != y:\n            heapq.heappush(stones, -(y - x))\n    return -stones[0] if stones else 0", "def maxAbsValExpr(arr1, arr2):\n    result = 0\n    max_sum = [float('-inf')] * 4\n\n    for i in range(len(arr1)):\n        max_sum[0] = max(max_sum[0], arr1[i] + arr2[i] + i)\n        max_sum[1] = max(max_sum[1], arr1[i] - arr2[i] + i)\n        max_sum[2] = max(max_sum[2], -arr1[i] + arr2[i] + i)\n        max_sum[3] = max(max_sum[3], -arr1[i] - arr2[i] + i)\n\n    for i in range(len(arr1)):\n        result = max(result, max_sum[0] - arr1[i] - arr2[i] - i)\n        result = max(result, max_sum[1] - arr1[i] + arr2[i] - i)\n        result = max(result, max_sum[2] + arr1[i] - arr2[i] - i)\n        result = max(result, max_sum[3] + arr1[i] + arr2[i] - i)\n\n    return result", "def last_substring(s: str) -> str:\n    i, j, k, n = 0, 1, 0, len(s)\n    while j + k < n:\n        if s[i + k] == s[j + k]:\n            k += 1\n        elif s[i + k] < s[j + k]:\n            i = j\n            j += 1\n            k = 0\n        else:\n            j += 1\n            k = 0\n    return s[i:]", "def is_armstrong(n: int) -> bool:\n    power_sum = 0\n    original = n\n    k = len(str(n))\n    while n > 0:\n        digit = n % 10\n        power_sum += digit ** k\n        n //= 10\n    return power_sum == original", "def find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef minimumCost(n, connections):\n    connections.sort(key=lambda x: x[2])\n\n    parent = list(range(n + 1))\n\n    cost = 0\n    edges = 0\n    for c in connections:\n        root_x = find(parent, c[0])\n        root_y = find(parent, c[1])\n\n        if root_x != root_y:\n            parent[root_y] = root_x\n            cost += c[2]\n            edges += 1\n\n        if edges == n - 1:\n            break\n\n    return cost if edges == n - 1 else -1", "def minimum_semesters(n: int, relations: List[List[int]]) -> int:\n    in_degree = [0] * (n + 1)\n    graph = [[] for _ in range(n + 1)]\n\n    for prev, next in relations:\n        graph[prev].append(next)\n        in_degree[next] += 1\n\n    q = [i for i in range(1, n + 1) if in_degree[i] == 0]\n    semesters = 0\n\n    while q:\n        next_q = []\n        semesters += 1\n        for course in q:\n            n -= 1\n            for next_course in graph[course]:\n                in_degree[next_course] -= 1\n                if in_degree[next_course] == 0:\n                    next_q.append(next_course)\n        q = next_q\n\n    return semesters if n == 0 else -1", "def height_checker(heights):\n    expected = sorted(heights)\n    count = 0\n    for i in range(len(heights)):\n        if heights[i] != expected[i]:\n            count += 1\n    return count", "def maxSatisfied(customers, grumpy, minutes):\n    total, max_increase, window_increase = 0, 0, 0\n    i, j = 0, 0\n    while i < len(customers):\n        if i - j == minutes:\n            window_increase -= customers[j] * grumpy[j]\n            j += 1\n        window_increase += customers[i] * grumpy[i]\n        total += customers[i] * (1 - grumpy[i])\n        max_increase = max(max_increase, window_increase)\n        i += 1\n    return total + max_increase", "def prev_perm_opt1(arr):\n    n = len(arr)\n    for i in range(n - 2, -1, -1):\n        if arr[i] > arr[i + 1]:\n            j = i + 1\n            while j < n and arr[j] < arr[i]:\n                j += 1\n            arr[i], arr[j - 1] = arr[j - 1], arr[i]\n            return arr\n    return arr", "from heapq import heappush, heappop\n\ndef rearrange_barcodes(barcodes):\n    count = {}\n    for barcode in barcodes:\n        if barcode not in count:\n            count[barcode] = 0\n        count[barcode] += 1\n\n    pq = []\n    for key, value in count.items():\n        heappush(pq, (-value, key))\n\n    idx = 0\n    while pq:\n        curr = heappop(pq)\n        while curr[0] < 0:\n            barcodes[idx] = curr[1]\n            curr = (curr[0] + 1, curr[1])\n            idx += 2\n            if idx >= len(barcodes):\n                idx = 1\n    return barcodes", "def longestCommonSubsequence(text1: str, text2: str) -> int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]", "def movesToMakeZigzag(nums):\n    even_moves, odd_moves = 0, 0\n    for i in range(len(nums)):\n        left = nums[i - 1] if i > 0 else 1001\n        right = nums[i + 1] if i < len(nums) - 1 else 1001\n        min_value = min(left, right)\n        if nums[i] >= min_value:\n            if i % 2 == 0:\n                even_moves += nums[i] - min_value + 1\n            else:\n                odd_moves += nums[i] - min_value + 1\n    return min(even_moves, odd_moves)", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef btree_game_winning_move(root: TreeNode, n: int, x: int) -> bool:\n    def count_nodes(node: TreeNode) -> int:\n        if not node:\n            return 0\n        return count_nodes(node.left) + count_nodes(node.right) + 1\n\n    def find_node(node: TreeNode, x: int) -> TreeNode:\n        if not node:\n            return None\n        if node.val == x:\n            return node\n        left_search = find_node(node.left, x)\n        if left_search:\n            return left_search\n        return find_node(node.right, x)\n\n    x_node = find_node(root, x)\n    left_nodes = count_nodes(x_node.left)\n    right_nodes = count_nodes(x_node.right)\n    parent_nodes = n - left_nodes - right_nodes - 1\n\n    return max(max(left_nodes, right_nodes), parent_nodes) > n // 2", "def gcd_of_strings(str1: str, str2: str) -> str:\n    if str1 + str2 != str2 + str1:\n        return ''\n    gcd = lambda a, b: a if not b else gcd(b, a % b)\n    return str1[:gcd(len(str1), len(str2))]", "from collections import defaultdict\n\ndef maxEqualRowsAfterFlips(matrix):\n    count = defaultdict(int)\n    for row in matrix:\n        row_str = \"\".join(str(row[0] ^ val) for val in row)\n        count[row_str] += 1\n    return max(count.values())", "def is_majority_element(nums, target):\n    count = 0\n    for num in nums:\n        if num == target: count += 1\n        if count > len(nums) / 2: return True\n    return False", "def minSwaps(data):\n    ones = sum(data)\n    cur_ones, max_ones = 0, 0\n    for i, d in enumerate(data):\n        cur_ones += d\n        if i >= ones:\n            cur_ones -= data[i - ones]\n        max_ones = max(max_ones, cur_ones)\n    return ones - max_ones", "from typing import List\nfrom collections import defaultdict\nfrom itertools import combinations\n\nclass Solution:\n    def mostVisitedPattern(self, username: List[str], timestamp: List[int], website: List[str]) -> List[str]:\n        n = len(username)\n        visits = defaultdict(list)\n        \n        # user_visits: {user: [(timestamp, website),...]}\n        for i in range(n):\n            visits[username[i]].append((timestamp[i], website[i]))\n\n\n        for user in visits:\n            visits[user].sort()\n        \n        patterns = defaultdict(int)\n        \n        for user in visits:\n            websites = [web for _, web in visits[user]]\n            patterns_set = set(combinations(websites, 3))\n\n            for pattern in patterns_set:\n                patterns[pattern] += 1\n                \n        patterns = sorted(patterns.items(), key=lambda x: (-x[1], x[0]))\n        \n        return list(patterns[0][0])", "def canConvert(str1, str2):\n    if str1 == str2: return True;\n    conversion = {}\n    for c1, c2 in zip(str1, str2):\n        if c1 in conversion and conversion[c1] != c2: return False\n        conversion[c1] = c2\n    return len(set(str2)) < 26", "def is_leap_year(year: int) -> bool:\n    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n\ndef day_of_year(date: str) -> int:\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    year, month, day = int(date[:4]), int(date[5:7]), int(date[8:])\n\n    if is_leap_year(year):\n        days_in_month[1] = 29\n\n    return sum(days_in_month[:month-1]) + day", "def numRollsToTarget(n, k, target):\n    MOD = 1000000007\n    dp = [[0 for _ in range(target + 1)] for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(i, target + 1):\n            for d in range(1, k + 1):\n                if j - d >= 0:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - d]) % MOD\n    return dp[n][target]", "def find_third_words(text, first, second):\n    words = text.split()\n    result = []\n    \n    for i in range(len(words) - 2):\n        if words[i] == first and words[i + 1] == second:\n            result.append(words[i + 2])\n            \n    return result", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_insufficient(node, limit, current_sum):\n    if not node:\n        return True\n\n    current_sum += node.val\n    if not node.left and not node.right:\n        return current_sum < limit\n\n    left_insufficient = is_insufficient(node.left, limit, current_sum)\n    right_insufficient = is_insufficient(node.right, limit, current_sum)\n\n    if left_insufficient:\n        node.left = None\n    if right_insufficient:\n        node.right = None\n\n    return left_insufficient and right_insufficient\n\ndef sufficient_subset(root, limit):\n    if is_insufficient(root, limit, 0):\n        return None\n    return root", "def num_tile_possibilities(tiles: str) -> int:\n    freq = [0] * 26\n    for c in tiles:\n        freq[ord(c) - ord('A')] += 1\n\n    def dfs(freq):\n        result = 0\n        for i in range(26):\n            if freq[i] > 0:\n                freq[i] -= 1\n                result += 1 + dfs(freq)\n                freq[i] += 1\n        return result\n\n    return dfs(freq)", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef maxLevelSum(root):\n    if not root: return 0\n\n    q = [root]\n    level, max_sum, result_level = 0, float('-inf'), 0\n    \n    while q:\n        qlen, sum = len(q), 0\n        level += 1\n\n        for i in range(qlen):\n            temp = q.pop(0)\n            sum += temp.val\n\n            if temp.left: q.append(temp.left)\n            if temp.right: q.append(temp.right)\n\n        if sum > max_sum:\n            max_sum = sum\n            result_level = level\n    \n    return result_level", "from collections import deque\n\ndef maxDistance(grid):\n    distance = -1\n    water_cells = deque()\n    n = len(grid)\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                water_cells.append((i, j))\n\n    if not water_cells or len(water_cells) == n * n:\n        return distance\n\n    directions = ((0, 1), (0, -1), (1, 0), (-1, 0))\n\n    while water_cells:\n        size = len(water_cells)\n        for _ in range(size):\n            x, y = water_cells.popleft()\n            for dx, dy in directions:\n                newX, newY = x + dx, y + dy\n                if 0 <= newX < n and 0 <= newY < n and grid[newX][newY] == 0:\n                    grid[newX][newY] = 1\n                    water_cells.append((newX, newY))\n        distance += 1\n        \n    return distance - 1", "def lastSubstring(s: str) -> str:\n    maxIndex = 0\n    curIndex = 1\n    while curIndex < len(s):\n        i = 0\n        while curIndex + i < len(s) and s[maxIndex + i] == s[curIndex + i]:\n            i += 1\n        if curIndex + i == len(s):\n            break\n        if s[maxIndex + i] < s[curIndex + i]:\n            maxIndex = curIndex\n        curIndex += 1\n    return s[maxIndex:]", "def calculate_time(keyboard: str, word: str) -> int:\n    time = 0\n    prev_index = 0\n    char_to_index = {char: i for i, char in enumerate(keyboard)}\n\n    for c in word:\n        time += abs(char_to_index[c] - prev_index)\n        prev_index = char_to_index[c]\n\n    return time", "class FileSystem:\n    def __init__(self):\n        self.path_map = {}\n\n    def create_path(self, path: str, value: int) -> bool:\n        if path in self.path_map:\n            return False\n        parent_path = path[:path.rfind('/')]\n        if parent_path and parent_path not in self.path_map:\n            return False\n        self.path_map[path] = value\n        return True\n\n    def get(self, path: str) -> int:\n        return self.path_map.get(path, -1)", "import heapq\n\ndef connectSticks(sticks):\n    heapq.heapify(sticks)\n    cost = 0\n    while len(sticks) > 1:\n        first = heapq.heappop(sticks)\n        second = heapq.heappop(sticks)\n        cost += first + second\n        heapq.heappush(sticks, first + second)\n    return cost", "def duplicateZeros(arr):\n    n = len(arr)\n    i = 0\n    while i < n - 1:\n        if arr[i] == 0:\n            for j in range(n - 2, i, -1):\n                arr[j + 1] = arr[j]\n            arr[i + 1] = 0\n            i += 2\n        else:\n            i += 1", "from typing import List\n\ndef largestValsFromLabels(values: List[int], labels: List[int], numWanted: int, useLimit: int) -> int:\n    items = sorted(zip(values, labels), reverse=True)\n    label_count = {}\n    result = 0\n    \n    for value, label in items:\n        if numWanted > 0 and label_count.get(label, 0) < useLimit:\n            result += value\n            label_count[label] = label_count.get(label, 0) + 1\n            numWanted -= 1\n    \n    return result", "def shortest_common_supersequence(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif str1[i - 1] == str2[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1])\n\n    i, j = m, n\n    result = []\n\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1]:\n            result.append(str1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            j -= 1\n            result.append(str2[j])\n        else:\n            i -= 1\n            result.append(str1[i])\n\n    while i > 0:\n        i -= 1\n        result.append(str1[i])\n\n    while j > 0:\n        j -= 1\n        result.append(str2[j])\n\n    return \"\".join(result[::-1])", "from collections import deque\n\ndef shortestPathBinaryMatrix(grid):\n    n = len(grid)\n    if grid[0][0] == 1 or grid[n - 1][n - 1] == 1:\n        return -1\n    q = deque([(0, 0)])\n    dirs = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    grid[0][0] = 1\n    steps = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            x, y = q.popleft()\n\n            if x == n - 1 and y == n - 1:\n                return steps\n\n            for dx, dy in dirs:\n                newX, newY = x + dx, y + dy\n\n                if 0 <= newX < n and 0 <= newY < n and grid[newX][newY] == 0:\n                    q.append((newX, newY))\n                    grid[newX][newY] = 1\n\n        steps += 1\n\n    return -1", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stacks = []\n\n    def push(self, val: int) -> None:\n        for stack in self.stacks:\n            if len(stack) < self.capacity:\n                stack.append(val)\n                return\n        self.stacks.append([val])\n\n    def pop(self) -> int:\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n        if not self.stacks:\n            return -1\n        return self.stacks[-1].pop()\n\n    def popAtStack(self, index: int) -> int:\n        if index >= len(self.stacks) or not self.stacks[index]:\n            return -1\n        return self.stacks[index].pop()", "def numPrimeArrangements(n: int) -> int:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_count = sum(1 for i in range(2, n + 1) if is_prime(i))\n    composite_count = n - prime_count\n\n    MOD = 10**9 + 7\n    res = 1\n    for i in range(1, prime_count + 1):\n        res = res * i % MOD\n    for i in range(1, composite_count + 1):\n        res = res * i % MOD\n\n    return res", "def dietPlanPerformance(calories, k, lower, upper):\n    points = 0\n    T = 0\n\n    for i in range(len(calories)):\n        T += calories[i]\n        if i >= k:\n            T -= calories[i-k]\n        if i >= k-1:\n            if T < lower: points -= 1\n            if T > upper: points += 1\n\n    return points", "def canMakePaliQueries(s, queries):\n    answer = []\n    prefixSum = [0] * (len(s) + 1)\n\n    for i in range(len(s)):\n        prefixSum[i + 1] = prefixSum[i] ^ (1 << (ord(s[i]) - ord('a')))\n\n    for query in queries:\n        left, right, k = query\n        diffCount = bin(prefixSum[right + 1] ^ prefixSum[left]).count('1')\n        answer.append((diffCount // 2) <= k)\n\n    return answer", "def find_num_of_valid_words(words, puzzles):\n    result = []\n    for puzzle in puzzles:\n        count = 0\n        puzzle_set = set(puzzle)\n        for word in words:\n            if puzzle[0] in word:\n                if all(c in puzzle_set for c in word):\n                    count += 1\n        result.append(count)\n    return result", "def count_letters(s: str) -> int:\n    count = 0\n    current = 1\n\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            current += 1\n        else:\n            count += (current * (current + 1)) // 2\n            current = 1\n\n    count += (current * (current + 1)) // 2\n    return count", "from collections import defaultdict\n\ndef beforeAndAfterPuzzles(phrases):\n    first_word_map = defaultdict(set)\n    result = set()\n\n    for phrase in phrases:\n        first_word = phrase.split(' ')[0]\n        first_word_map[first_word].add(phrase)\n\n    for phrase in phrases:\n        last_word = phrase.split(' ')[-1]\n        if last_word in first_word_map:\n            for cur_phrase in first_word_map[last_word]:\n                if phrase != cur_phrase:\n                    result.add(phrase + cur_phrase[cur_phrase.index(' '):])\n\n    return sorted(list(result))", "def shortestDistance(colors, queries):\n    result = []\n    positions = [[] for _ in range(3)]\n\n    for i, color in enumerate(colors):\n        positions[color - 1].append(i)\n\n    for query in queries:\n        index_positions = positions[query[1] - 1]\n\n        if not index_positions:\n            result.append(-1)\n        else:\n            dist = float('inf')\n\n            for pos in index_positions:\n                dist = min(dist, abs(pos - query[0]))\n\n            result.append(dist)\n\n    return result", "def sampleStats(count):\n    minVal, maxVal, mode, median, mean = -1, -1, 0, 0, 0\n    totalCount, modeCount, curCount = 0, 0, 0\n    sum = 0\n\n    for i in range(256):\n        if count[i] > 0:\n            if minVal == -1:\n                minVal = i\n            maxVal = i\n            sum += i * count[i]\n            totalCount += count[i]\n            if count[i] > modeCount:\n                modeCount = count[i]\n                mode = i\n\n    mean = sum / totalCount\n    isEven = (totalCount % 2 == 0)\n    mid1 = totalCount // 2\n    mid2 = mid1 - 1\n    if isEven:\n        mid2 += 1\n\n    for i in range(256):\n        curCount += count[i]\n        if isEven and curCount >= mid2:\n            median += i\n            mid2 = totalCount\n            isEven = False\n\n        if curCount >= mid1:\n            median += i\n            break\n\n    if not isEven:\n        median /= 2\n    return [minVal, maxVal, mean, median, mode]", "def carPooling(trips, capacity):\n    stops = [0] * 1001\n    for num, start, end in trips:\n        stops[start] += num\n        stops[end] -= num\n    for i in stops:\n        capacity -= i\n        if capacity < 0:\n            return False\n    return True", "def day_of_the_week(day, month, year):\n    from datetime import date\n    days = [\"Sunday \", \"Monday \", \"Tuesday \", \"Wednesday \", \"Thursday \", \"Friday \", \"Saturday \"]\n    return days[date(year, month, day).weekday()]", "from threading import Semaphore\n\nclass H2O:\n    def __init__(self):\n        self.hydrogenSemaphore = Semaphore(2)\n        self.oxygenSemaphore = Semaphore(1)\n\n    def hydrogen(self, releaseHydrogen):\n        self.hydrogenSemaphore.acquire()\n        releaseHydrogen()\n        self.oxygenSemaphore.release()\n\n    def oxygen(self, releaseOxygen):\n        self.oxygenSemaphore.acquire()\n        releaseOxygen()\n        self.hydrogenSemaphore.release(2)", "from threading import Lock\n\nclass FooBar:\n    def __init__(self, n: int):\n        self.n = n\n        self.foo_lock = Lock()\n        self.bar_lock = Lock()\n        self.bar_lock.acquire()\n\n    def foo(self, printFoo) -> None:\n        for _ in range(self.n):\n            self.foo_lock.acquire()\n            printFoo()\n            self.bar_lock.release()\n\n    def bar(self, printBar) -> None:\n        for _ in range(self.n):\n            self.bar_lock.acquire()\n            printBar()\n            self.foo_lock.release()", "def max_number_of_balloons(text: str) -> int:\n    letter_count = [0] * 5\n    for c in text:\n        if c == 'b': letter_count[0] += 1\n        if c == 'a': letter_count[1] += 1\n        if c == 'l': letter_count[2] += 1\n        if c == 'o': letter_count[3] += 1\n        if c == 'n': letter_count[4] += 1\n    letter_count[2] //= 2\n    letter_count[3] //= 2\n    return min(letter_count)", "def reverseParentheses(s: str) -> str:\n    stack = []\n    for i, c in enumerate(s):\n        if c == '(':\n            stack.append(i)\n        elif c == ')':\n            start, end = stack.pop(), i\n            # reversal of the substring\n            s = s[:start] + s[start+1:end][::-1] + s[end+1:]\n    return ''.join(c for c in s if c.isalpha())", "def kConcatenationMaxSum(arr, k):\n    mod = 10**9 + 7\n    n = len(arr)\n    max_sum, max_left, max_right = 0, 0, 0\n    total_sum = sum(arr)\n    temp_sum = 0\n\n    for i in range(n):\n        temp_sum += arr[i]\n        max_sum = max(max_sum, temp_sum)\n        temp_sum = max(0, temp_sum)\n        max_left = max(max_left, temp_sum)\n\n    temp = total_sum\n    for i in range(n - 1, -1, -1):\n        temp -= arr[i]\n        max_right = max(max_right, temp)\n\n    ans = max(max_sum, max_left + max_right + total_sum * (k - 2), 0)\n    return ans % mod", "from collections import defaultdict\n\ndef criticalConnections(n, connections):\n    def dfs(node, parent, depth, rank, graph, result):\n        rank[node] = depth\n        for neighbor in graph[node]:\n            if neighbor == parent:\n                continue\n            if rank[neighbor] == -1:\n                dfs(neighbor, node, depth + 1, rank, graph, result)\n            rank[node] = min(rank[node], rank[neighbor])\n            if rank[neighbor] == depth + 1:\n                result.append((node, neighbor))\n\n    graph = defaultdict(list)\n    for fr, to in connections:\n        graph[fr].append(to)\n        graph[to].append(fr)\n\n    rank = [-1] * n\n    result = []\n    dfs(0, -1, 0, rank, graph, result)\n    return result", "def minHeightShelves(books, shelfWidth):\n    n = len(books)\n    dp = [1000000] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(1, n + 1):\n        width = 0\n        height = 0\n        j = i\n        while j >= 1:\n            width += books[j - 1][0]\n            height = max(height, books[j - 1][1])\n            \n            if width <= shelfWidth:\n                dp[i] = min(dp[i], dp[j - 1] + height)\n            j -= 1\n    \n    return dp[n]", "def parse_bool_expr(expression, pos=None):\n    if pos is None:\n        pos = [0]\n    current = expression[pos[0]]\n    pos[0] += 1\n    if current == 't': return True\n    if current == 'f': return False\n    if current == '!':\n        pos[0] += 1\n        return not parse_bool_expr(expression, pos)\n    if current == '&':\n        pos[0] += 1\n        result = True\n        while expression[pos[0]] != ')':\n            result &= parse_bool_expr(expression, pos)\n            if expression[pos[0]] == ',': pos[0] += 1\n    elif current == '|':\n        pos[0] += 1\n        result = False\n        while expression[pos[0]] != ')':\n            result |= parse_bool_expr(expression, pos)\n            if expression[pos[0]] == ',': pos[0] += 1\n    pos[0] += 1\n    return result", "def smallest_common_element(mat):\n    counts = {}\n    for row in mat:\n        for num in row:\n            counts[num] = counts.get(num, 0) + 1\n            if counts[num] == len(mat):\n                return num\n    return -1", "import heapq\n\ndef min_build_time(blocks, split):\n    heapq.heapify(blocks)\n    \n    while len(blocks) > 1:\n        a = heapq.heappop(blocks)\n        b = heapq.heappop(blocks)\n        heapq.heappush(blocks, b + split)\n    \n    return blocks[0]", "from typing import List\n\ndef minimumAbsDifference(arr: List[int]) -> List[List[int]]:\n    arr.sort()\n    min_diff = min(arr[i] - arr[i - 1] for i in range(1, len(arr)))\n\n    result = []\n    for i in range(1, len(arr)):\n        if arr[i] - arr[i - 1] == min_diff:\n            result.append([arr[i - 1], arr[i]])\n\n    return result", "import math\n\ndef nthUglyNumber(n, a, b, c):\n    left, right = 1, int(2e9)\n    lcm_ab, lcm_ac, lcm_bc = a * b // math.gcd(a, b), a * c // math.gcd(a, c), b * c // math.gcd(b, c)\n    lcm_abc = a * lcm_bc // math.gcd(a, lcm_bc)\n\n    while left < right:\n        mid = left + (right - left) // 2\n        count = mid // a + mid // b + mid // c - mid // lcm_ab - mid // lcm_ac - mid // lcm_bc + mid // lcm_abc\n        if count < n:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "from collections import defaultdict\n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n = len(s)\n\n        # Initialize the parents array\n        p = list(range(n))\n\n        # Helper function to find the parent of an index\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        # Union-find, grouping connected indices together\n        for pair in pairs:\n            root1 = find(pair[0])\n            root2 = find(pair[1])\n            if root1 != root2:\n                p[root2] = root1\n                \n        # Group all the characters together according to their representatives (parent)\n        groups = defaultdict(list)\n        for i in range(n):\n            root = find(i)\n            groups[root].append(s[i])\n\n        # Sort each group\n        for group in groups.values():\n            group.sort(reverse=True)\n\n        # Build the result string\n        res = []\n        for i in range(n):\n            root = find(i)\n            res.append(groups[root].pop())\n\n        return \"\".join(res)", "from threading import Condition\n\nclass Foo:\n    def __init__(self):\n        self.order = 1\n        self.cv = Condition()\n\n    def first(self):\n        with self.cv:\n            # printFirst() outputs \"first\". Do not change or remove this line.\n            printFirst()\n            self.order = 2\n            self.cv.notify_all()\n\n    def second(self):\n        with self.cv:\n            self.cv.wait_for(lambda: self.order == 2)\n            # printSecond() outputs \"second\". Do not change or remove this line.\n            printSecond()\n            self.order = 3\n            self.cv.notify_all()\n\n    def third(self):\n        with self.cv:\n            self.cv.wait_for(lambda: self.order == 3)\n            # printThird() outputs \"third\". Do not change or remove this line.\n            printThird()", "def corp_flight_bookings(bookings, n):\n    answer = [0] * n\n    for start, end, seats in bookings:\n        answer[start - 1] += seats\n        if end < n:\n            answer[end] -= seats\n    for i in range(1, n):\n        answer[i] += answer[i - 1]\n    return answer", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef delNodes(root, to_delete):\n    forest = []\n    to_delete_set = set(to_delete)\n    helper(root, True, to_delete_set, forest)\n    return forest\n\ndef helper(node, isRoot, to_delete, forest):\n    if not node:\n        return None\n    deleted = node.val in to_delete\n    if isRoot and not deleted:\n        forest.append(node)\n    node.left = helper(node.left, deleted, to_delete, forest)\n    node.right = helper(node.right, deleted, to_delete, forest)\n    return None if deleted else node", "def split_string(seq: str):\n    result = [0] * len(seq)\n    count = 0\n\n    for i in range(len(seq)):\n        if seq[i] == '(':\n            result[i] = count % 2\n            count += 1\n        else:\n            count -= 1\n            result[i] = count % 2\n\n    return result", "def removeDuplicates(s: str, k: int) -> str:\n    stack = []\n    for c in s:\n        if not stack or stack[-1][0] != c:\n            stack.append((c, 1))\n        elif stack[-1][1] + 1 != k:\n            stack[-1] = (c, stack[-1][1] + 1)\n        else:\n            stack.pop()\n    return ''.join(c * count for c, count in stack)", "def trimmed_mean(arr):\n    n = len(arr)\n    remove = int(n * 0.05)\n    arr.sort()\n    return sum(arr[remove:n - remove]) / (n - 2 * remove)", "def arraysIntersection(arr1, arr2, arr3):\n    i, j, k = 0, 0, 0\n    result = []\n    while i < len(arr1) and j < len(arr2) and k < len(arr3):\n        if arr1[i] == arr2[j] and arr2[j] == arr3[k]:\n            result.append(arr1[i])\n            i, j, k = i + 1, j + 1, k + 1\n        else:\n            if arr1[i] <= arr2[j] and arr1[i] <= arr3[k]:\n                i += 1\n            elif arr2[j] <= arr3[k]:\n                j += 1\n            else:\n                k += 1\n    return result", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef twoSumBSTs(root1, root2, target):\n    def build_set(node, s):\n        if node:\n            s.add(node.val)\n            build_set(node.left, s)\n            build_set(node.right, s)\n\n    def find_pair(node, target, s):\n        if node:\n            if target - node.val in s:\n                return True\n            return find_pair(node.left, target, s) or find_pair(node.right, target, s)\n        return False\n\n    s = set()\n    build_set(root1, s)\n    return find_pair(root2, target, s)", "def countSteppingNumbers(low, high):\n    results = []\n    for i in range(low, high+1):\n        prev = -1\n        j = i\n        is_stepping = True\n        while j > 0:\n            digit = j % 10\n            if prev != -1 and abs(prev - digit) != 1:\n                is_stepping = False\n                break\n            prev = digit\n            j //= 10\n        if is_stepping:\n            results.append(i)\n    return results", "from threading import Lock\n\nclass ZeroEvenOdd:\n    def __init__(self, n):\n        self.n = n\n        self.cnt = 1\n        self.lock = Lock()\n\n    def zero(self, printNumber):\n        for i in range(1, self.n + 1):\n            with self.lock:\n                while self.cnt % 2 == 0:\n                    self.lock.wait()\n                printNumber(0)\n                self.cnt += 1\n                self.lock.notify_all()\n\n    def even(self, printNumber):\n        for i in range(2, self.n + 1, 2):\n            with self.lock:\n                while self.cnt != 2 * i:\n                    self.lock.wait()\n                printNumber(i)\n                self.cnt += 1\n                self.lock.notify_all()\n\n    def odd(self, printNumber):\n        for i in range(1, self.n + 1, 2):\n            with self.lock:\n                while self.cnt != 2 * i - 1:\n                    self.lock.wait()\n                printNumber(i)\n                self.cnt += 1\n                self.lock.notify_all()", "def sort_array(arr1, arr2):\n    counts = {}\n    result = []\n\n    for num in arr1:\n        counts[num] = counts.get(num, 0) + 1\n\n    for num in arr2:\n        if num in counts:\n            result.extend([num] * counts[num])\n            del counts[num]\n\n    for num in sorted(counts.keys()):\n        result.extend([num] * counts[num])\n\n    return result", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n        def dfs(node):\n            if not node:\n                return (None, 0)\n            left, right = dfs(node.left), dfs(node.right)\n            if left[1] > right[1]:\n                return (left[0], left[1] + 1)\n            elif left[1] < right[1]:\n                return (right[0], right[1] + 1)\n            else:\n                return (node, left[1] + 1)\n        \n        return dfs(root)[0]", "def longest_wpi(hours):\n    score = 0\n    max_length = 0\n    first_occurrence = {}\n\n    for i, h in enumerate(hours):\n        score += 1 if h > 8 else -1\n        if score > 0:\n            max_length = i + 1\n        else:\n            if score not in first_occurrence:\n                first_occurrence[score] = i\n            if score - 1 in first_occurrence:\n                max_length = max(max_length, i - first_occurrence[score - 1])\n    return max_length", "from typing import List\n\ndef smallestSufficientTeam(req_skills: List[str], people: List[List[str]]) -> List[int]:\n    skill_to_int = {s: i for i, s in enumerate(req_skills)}\n    people_skills = [sum(1 << skill_to_int[skill] for skill in person) for person in people]\n        \n    n = len(req_skills)\n    INF = 64\n    dp = [INF] * (1 << n)\n    dp[0] = 0\n    parent = [None] * (1 << n)\n        \n    for i, person_skills in enumerate(people_skills):\n        for completed_skills in range((1 << n) - 1, -1, -1):\n            with_person_skills = completed_skills | person_skills\n            if dp[with_person_skills] > dp[completed_skills] + 1:\n                dp[with_person_skills] = dp[completed_skills] + 1\n                parent[with_person_skills] = completed_skills\n                \n    ans = [0] * dp[-1]\n    cur = (1 << n) - 1\n    t = dp[-1] - 1\n        \n    for i in range(len(people) - 1, -1, -1):\n        old = parent[cur]\n        diff = cur ^ old\n        is_essential = (people_skills[i] & diff) > 0\n        if is_essential:\n            ans[t] = i\n            t -= 1\n        cur = old\n    return ans", "def find_special_integer(arr):\n    n = len(arr)\n    required_count = n // 4\n    for i in range(n):\n        if arr[i] == arr[i + required_count]:\n            return arr[i]\n    return -1", "def remove_covered_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    \n    count = 0\n    end = 0\n    for i in intervals:\n        if i[1] > end:\n            count += 1\n            end = i[1]\n    return count", "def areConnected(n, threshold, queries):\n    answer = [False] * len(queries)\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def unite(x, y):\n        rootx = find(x)\n        rooty = find(y)\n        if rootx != rooty:\n            if rank[rootx] > rank[rooty]:\n                rootx, rooty = rooty, rootx\n            parent[rootx] = rooty\n            if rank[rootx] == rank[rooty]:\n                rank[rooty] += 1\n\n    for i in range(threshold + 1, n + 1):\n        for j in range(i * 2, n + 1, i):\n            unite(i, j)\n\n    for i, query in enumerate(queries):\n        answer[i] = find(query[0]) == find(query[1])\n\n    return answer", "def minFallingPathSum(grid):\n    n = len(grid)\n    for i in range(1, n):\n        for j in range(n):\n            minVal = float('inf')\n            for k in range(n):\n                if k == j:\n                    continue\n                minVal = min(minVal, grid[i - 1][k])\n            grid[i][j] += minVal\n    return min(grid[n - 1])", "from collections import defaultdict\n\ndef num_equiv_domino_pairs(dominoes):\n    freq = defaultdict(int)\n    result = 0\n    for domino in dominoes:\n        key = min(domino[0], domino[1]) * 10 + max(domino[0], domino[1])\n        result += freq[key]\n        freq[key] += 1\n    return result", "def mctFromLeafValues(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [[0] * n for _ in range(n)]\n    maxs = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i, n):\n            maxs[i][j] = max(arr[i:j+1])\n\n    for len_ in range(1, n):\n        for i in range(n - len_):\n            j = i + len_\n            dp[i][j] = float('inf')\n            for k in range(i, j):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + maxs[i][k] * maxs[k+1][j])\n\n    return dp[0][n - 1]", "from collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, redEdges, blueEdges):\n    adj_list = defaultdict(lambda: defaultdict(set))\n    \n    for u, v in redEdges:\n        adj_list[u][0].add(v)\n        \n    for u, v in blueEdges:\n        adj_list[u][1].add(v)\n        \n    dist = [[-1] * 2 for _ in range(n)]\n    dist[0] = [0, 0]\n    \n    q = deque([(0,0), (0,1)])\n\n    while q:\n        node, color = q.popleft()\n        next_color = color ^ 1\n        \n        for neighbor in adj_list[node][next_color]:\n            if dist[neighbor][next_color] == -1:\n                dist[neighbor][next_color] = dist[node][color] + 1\n                q.append((neighbor, next_color))\n                \n    result = []\n    for a, b in dist:\n        result.append(min(a, b) if a != -1 and b != -1 else max(a, b))\n        \n    return result", "def max_value(arr1, arr2):\n    n = len(arr1)\n    max1 = max2 = max3 = max4 = float('-inf')\n    min1 = min2 = min3 = min4 = float('inf')\n\n    for i in range(n):\n        max1 = max(max1, arr1[i] - arr2[i] + i)\n        max2 = max(max2, arr1[i] + arr2[i] + i)\n        max3 = max(max3, -arr1[i] + arr2[i] + i)\n        max4 = max(max4, -arr1[i] - arr2[i] + i)\n\n        min1 = min(min1, arr1[i] - arr2[i] + i)\n        min2 = min(min2, arr1[i] + arr2[i] + i)\n        min3 = min(min3, -arr1[i] + arr2[i] + i)\n        min4 = min(min4, -arr1[i] - arr2[i] + i)\n\n    return max(max1 - min1, max2 - min2, max3 - min3, max4 - min4)", "def replaceElements(arr):\n    n = len(arr)\n    maxElement = -1\n    for i in range(n - 1, -1, -1):\n        temp = arr[i]\n        arr[i] = maxElement\n        maxElement = max(maxElement, temp)\n    return arr", "def findBestValue(arr, target):\n    left = 0\n    right = max(arr)\n    result = -1\n    min_diff = float('inf')\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        total_sum = sum(min(x, mid) for x in arr)\n        if total_sum == target:\n            return mid\n        elif total_sum > target:\n            right = mid - 1\n        else:\n            left = mid + 1\n\n        if abs(target - total_sum) < min_diff or (\n                abs(target - total_sum) == min_diff and mid < result):\n            min_diff = abs(target - total_sum)\n            result = mid\n\n    return result", "from typing import List\n\ndef removeSubfolders(folder: List[str]) -> List[str]:\n    result = []\n    folder.sort()\n    prefix = \"/\"\n    \n    for path in folder:\n        if not path.startswith(prefix):\n            result.append(path)\n            prefix = path + \"/\"\n    return result", "def getMaxSumAndCount(board):\n    mod = 1000000007\n    n = len(board)\n    dp = [[(0, 0) for _ in range(n)] for _ in range(n)]\n    dp[n - 1][n - 1] = (0, 1)\n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if board[i][j] == 'X' or (i == n - 1 and j == n - 1):\n                continue\n            currVal = 0 if board[i][j] == 'E' else int(board[i][j])\n            up = dp[i - 1][j] if i > 0 else (-1, 0)\n            left = dp[i][j - 1] if j > 0 else (-1, 0)\n            diag = dp[i - 1][j - 1] if i > 0 and j > 0 else (-1, 0)\n\n            maxTuple = max(up, left, diag)\n            if maxTuple[0] == -1:\n                continue\n\n            dp[i][j] = (maxTuple[0] + currVal, dp[i][j][1])\n\n            if up == maxTuple:\n                dp[i][j] = (dp[i][j][0], (dp[i][j][1] + up[1]) % mod)\n            if left == maxTuple:\n                dp[i][j] = (dp[i][j][0], (dp[i][j][1] + left[1]) % mod)\n            if diag == maxTuple:\n                dp[i][j] = (dp[i][j][0], (dp[i][j][1] + diag[1]) % mod)\n\n    return dp[0][0]", "from bisect import bisect_left\n\ndef jobScheduling(startTime, endTime, profit):\n    jobs = sorted(zip(endTime, startTime, profit))\n    dp = [jobs[0][2]]\n    \n    def latestNonConflict(index):\n        startTimeToFind = jobs[index][1]\n        index = bisect_left([job[0] for job in jobs], startTimeToFind)\n        if index:\n            return index - 1\n        return -1\n\n    for i in range(1, len(jobs)):\n        L = latestNonConflict(i)\n        dp.append(max(dp[-1], (0 if L == -1 else dp[L]) + jobs[i][2]))\n\n    return dp[-1]", "def tribonacci(n: int) -> int:\n    if n == 0: return 0\n    if n == 1 or n == 2: return 1\n    a, b, c = 0, 1, 1\n    for _ in range(3, n + 1):\n        a, b, c = b, c, a + b + c\n    return c", "def findSolution(customfunction: 'CustomFunction', z: int) -> List[List[int]]:\n    results = []\n    for x in range(1, 1001):\n        for y in range(1, 1001):\n            if customfunction.f(x, y) == z:\n                results.append([x, y])\n            elif customfunction.f(x, y) > z:\n                break\n    return results", "def alphabet_board_path(target: str) -> str:\n    startX, startY = 0, 0\n    result = []\n\n    for t in target:\n        targetX, targetY = divmod(ord(t) - ord('a'), 5)\n        while startX > targetX:\n            result.append('U')\n            startX -= 1\n        while startY > targetY:\n            result.append('L')\n            startY -= 1\n        while startX < targetX:\n            result.append('D')\n            startX += 1\n        while startY < targetY:\n            result.append('R')\n            startY += 1\n        result.append('!')\n\n    return ''.join(result)", "def largest1BorderedSquare(grid):\n    m, n = len(grid), len(grid[0])\n    horizontal, vertical = [[0] * n for _ in range(m)], [[0] * n for _ in range(m)]\n\n    max_square_size = 0\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                horizontal[i][j] = 1 if j == 0 else horizontal[i][j - 1] + 1\n                vertical[i][j] = 1 if i == 0 else vertical[i - 1][j] + 1\n\n                min_size = min(horizontal[i][j], vertical[i][j])\n                while min_size > max_square_size:\n                    if (horizontal[i - min_size + 1][j] >= min_size and\n                        vertical[i][j - min_size + 1] >= min_size):\n                        max_square_size = min_size\n                    min_size -= 1\n\n    return max_square_size * max_square_size", "from functools import lru_cache\n\ndef stoneGameII(piles):\n    n = len(piles)\n    for i in range(n - 2, -1, -1):\n        piles[i] += piles[i + 1]\n\n    @lru_cache(None)\n    def search(idx, M):\n        if idx + 2 * M >= n:\n            return piles[idx]\n        return max(piles[idx] - search(idx + x, max(M, x)) for x in range(1, 2 * M + 1))\n\n    return search(0, 1)", "def sumEvenGrandparent(root, parent=None, grandparent=None):\n    if not root:\n        return 0\n    sum = 0\n    if grandparent and grandparent.val % 2 == 0:\n        sum += root.val\n    sum += sumEvenGrandparent(root.left, root, parent) + sumEvenGrandparent(root.right, root, parent)\n    return sum", "def num_distinct_repeated_substrings(s):\n    seen = set()\n    for length in range(len(s) // 2, 0, -1):\n        for i in range(len(s) - 2 * length + 1):\n            substr = s[i:i + length]\n            if substr in s[i + length:]:\n                seen.add(substr)\n    return len(seen)", "from collections import deque, defaultdict\n\ndef tree_diameter(edges):\n    tree = defaultdict(list)\n    for edge in edges:\n        tree[edge[0]].append(edge[1])\n        tree[edge[1]].append(edge[0])\n\n    queue = deque([(0, 0)])\n    furthest, max_distance = 0, 0\n    while queue:\n        node, distance = queue.popleft()\n        if distance > max_distance:\n            max_distance = distance\n            furthest = node\n        for neighbor in tree[node]:\n            tree[neighbor].remove(node)\n            queue.append((neighbor, distance + 1))\n\n    queue.append((furthest, 0))\n    max_distance = 0\n    while queue:\n        node, distance = queue.popleft()\n        if distance > max_distance:\n            max_distance = distance\n        for neighbor in tree[node]:\n            tree[neighbor].remove(node)\n            queue.append((neighbor, distance + 1))\n\n    return max_distance", "def minimumMoves(arr):\n    def minRemovals(i, j):\n        if i > j:\n            return 0\n        if i == j:\n            return 1\n        if dp[i][j] != -1:\n            return dp[i][j]\n\n        ans = minRemovals(i + 1, j) + 1\n        for k in range(i + 1, j + 1):\n            if arr[i] == arr[k]:\n                ans = min(ans, minRemovals(i + 1, k - 1) + minRemovals(k + 1, j))\n        dp[i][j] = ans\n        return ans\n\n    dp = [[-1] * len(arr) for _ in range(len(arr))]\n    return minRemovals(0, len(arr) - 1)", "def moves_to_make_zigzag(nums):\n    moves1, moves2 = 0, 0\n    for i in range(len(nums)):\n        left = nums[i - 1] if i > 0 else float('inf')\n        right = nums[i + 1] if i + 1 < len(nums) else float('inf')\n        diff1 = nums[i] - min(left, right) + 1\n        diff2 = nums[i] - min(left, right) + 1\n        if i % 2 == 0:\n            moves1 += max(0, diff1)\n        else:\n            moves2 += max(0, diff2)\n    return min(moves1, moves2)", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef can_win(root, x):\n    if not root:\n        return False\n    if root.val == x:\n        left_nodes = 1 + can_win(root.left, x) if root.left else 0\n        right_nodes = 1 + can_win(root.right, x) if root.right else 0\n        return left_nodes % 2 != 0 or right_nodes % 2 != 0\n    return can_win(root.left, x) or can_win(root.right, x)", "from math import gcd\nfrom functools import reduce\n\ndef isGoodArray(nums):\n    return reduce(gcd, nums) == 1", "def break_palindrome(palindrome: str) -> str:\n    n = len(palindrome)\n    if n < 2:\n        return \"\"\n    \n    palindrome = list(palindrome)\n    for i in range(n // 2):\n        if palindrome[i] != 'a':\n            palindrome[i] = 'a'\n            return \"\".join(palindrome)\n    \n    palindrome[-1] = 'b'\n    return \"\".join(palindrome)", "from heapq import heappush, heappop\n\ndef diagonalSort(mat):\n    m, n = len(mat), len(mat[0])\n    for i in range(m):\n        pq = []\n        row, col = i, 0\n        while row < m and col < n:\n            heappush(pq, mat[row][col])\n            row += 1\n            col += 1\n        row, col = i, 0\n        while row < m and col < n:\n            mat[row][col] = heappop(pq)\n            row += 1\n            col += 1\n        \n    for i in range(1, n):\n        pq = []\n        row, col = 0, i\n        while row < m and col < n:\n            heappush(pq, mat[row][col])\n            row += 1\n            col += 1\n        row, col = 0, i\n        while row < m and col < n:\n            mat[row][col] = heappop(pq)\n            row += 1\n            col += 1\n    return mat", "def closedIsland(grid):\n    def dfs(grid, i, j):\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]):\n            return False\n\n        if grid[i][j] == 1:\n            return True\n\n        grid[i][j] = 1\n\n        up = dfs(grid, i - 1, j)\n        down = dfs(grid, i + 1, j)\n        left = dfs(grid, i, j - 1)\n        right = dfs(grid, i, j + 1)\n\n        return up and down and left and right\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 0 and dfs(grid, i, j):\n                count += 1\n\n    return count", "def maxValueAfterReverse(nums):\n    total, diff = 0, 0\n    min2, max2 = float('inf'), float('-inf')\n    for i in range(len(nums) - 1):\n        total += abs(nums[i] - nums[i + 1])\n        min2 = min(min2, max(nums[i], nums[i + 1]))\n        max2 = max(max2, min(nums[i], nums[i + 1]))\n        diff = max(diff, abs(nums[i + 1] - nums[0]) - abs(nums[i + 1] - nums[i]))\n        diff = max(diff, abs(nums[i] - nums[-1]) - abs(nums[i] - nums[i + 1]))\n    return total + max(diff, 2 * (max2 - min2))", "def arrayRankTransform(arr):\n    sorted_arr = sorted(arr)\n    rank_map = {}\n    rank = 1\n\n    for num in sorted_arr:\n        if num not in rank_map:\n            rank_map[num] = rank\n            rank += 1\n\n    return [rank_map[num] for num in arr]", "from collections import deque\nfrom itertools import chain\n\ndef matrix_rank_transform(matrix):\n    def neighbours(r, c):\n        for i in range(m):\n            if i != r:\n                yield i, c\n        for i in range(n):\n            if i != c:\n                yield r, i\n\n    m, n = len(matrix), len(matrix[0])\n    rank = [[0] * n for _ in range(m)]\n    sorted_row = [0] * m\n    sorted_col = [0] * n\n\n    for bound in range(200001):\n        q = deque((r, c) for r in range(m) for c in range(n) if matrix[r][c] == bound and rank[r][c] == 0)\n        if not q:\n            break\n        while q:\n            r, c = rc = q.popleft()\n            potential_rank = sorted_row[r] + 1\n            for row, col in neighbours(r, c):\n                if matrix[row][col] <= matrix[r][c]:\n                    potential_rank = max(potential_rank, rank[row][col] + (matrix[row][col] < matrix[r][c]))\n            if potential_rank == sorted_col[c] + 1:\n                rank[r][c] = sorted_row[r] = sorted_col[c] = potential_rank\n            else:\n                q.append(rc)\n    return rank", "from typing import List\n\n\ndef generateSentences(synonyms: List[List[str]], text: str) -> List[str]:\n    synonym_map = {}\n\n    for s, t in synonyms:\n        if s not in synonym_map:\n            synonym_map[s] = {s}\n        if t not in synonym_map:\n            synonym_map[t] = {t}\n        synonym_map[s].add(t)\n        synonym_map[t].add(s)\n\n    words = text.split()\n    results = []\n\n    def helper(index: int, cur_sentence: List[str]) -> None:\n        if index == len(words):\n            results.append(\" \".join(cur_sentence))\n            return\n        for w in synonym_map.get(words[index], {words[index]}):\n            cur_sentence.append(w)\n            helper(index + 1, cur_sentence)\n            cur_sentence.pop()\n\n    helper(0, [])\n\n    return sorted(results)", "def numberOfWays(numPeople: int) -> int:\n    MOD = 1000000007\n    dp = [0] * (numPeople // 2 + 1)\n    dp[0] = 1\n    for i in range(1, numPeople // 2 + 1):\n        for j in range(1, i + 1):\n            dp[i] = (dp[i] + dp[i - j] * dp[j - 1]) % MOD\n    return dp[numPeople // 2]", "def dayOfYear(date: str) -> int:\n    year, month, day = map(int, date.split('-'))\n\n    daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n        daysInMonth[2] = 29\n\n    dayOfYear = sum(daysInMonth[:month]) + day\n    return dayOfYear", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass FindElements:\n    def __init__(self, root: TreeNode):\n        self.values = set()\n        self.recoverTree(root, 0)\n\n    def find(self, target: int) -> bool:\n        return target in self.values\n\n    def recoverTree(self, node: TreeNode, val: int):\n        if node is None:\n            return\n\n        node.val = val\n        self.values.add(val)\n\n        self.recoverTree(node.left, val * 2 + 1)\n        self.recoverTree(node.right, val * 2 + 2)", "from collections import defaultdict\nfrom random import randint\n\nclass MajorityChecker:\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        self.positions = defaultdict(list)\n        for i, num in enumerate(arr):\n            self.positions[num].append(i)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        for _ in range(20):\n            randomIndex = randint(left, right)\n            num = self.arr[randomIndex]\n            lb = self.lower_bound(self.positions[num], left)\n            ub = self.upper_bound(self.positions[num], right)\n            if ub - lb >= threshold:\n                return num\n        return -1\n\n    def lower_bound(self, nums, target):\n        l, r = 0, len(nums)\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid\n        return l\n\n    def upper_bound(self, nums, target):\n        l, r = 0, len(nums)\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] <= target:\n                l = mid + 1\n            else:\n                r = mid\n        return l", "def numRollsToTarget(n, k, target):\n    MOD = 10**9 + 7\n    dp = [[0] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            for l in range(1, k + 1):\n                if j >= l:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - l]) % MOD\n    return dp[n][target]", "def printLinkedListInReverse(head: 'ImmutableListNode') -> None:\n    if head is not None:\n        printLinkedListInReverse(head.getNext())\n        head.printValue()", "def minTimeToVisitAllPoints(points):\n    time = 0\n    for i in range(1, len(points)):\n        dx = abs(points[i][0] - points[i - 1][0])\n        dy = abs(points[i][1] - points[i - 1][1])\n        time += max(dx, dy)\n    return time", "def remove_zero_sum_sublists(head):\n    dummy = ListNode(0)\n    dummy.next = head\n    current = dummy\n\n    while current:\n        sum = 0\n        while head:\n            sum += head.val\n            if sum == 0:\n                current.next = head.next\n            head = head.next\n        current = current.next\n        if current:\n            head = current.next\n\n    return dummy.next", "def suggestedProducts(products, searchWord):\n    result = []\n    products.sort()\n    \n    for i in range(len(searchWord)):\n        suggestions = []\n        for product in products:\n            if len(product) > i and product[i] == searchWord[i]:\n                suggestions.append(product)\n                if len(suggestions) == 3:\n                    break\n        result.append(suggestions)\n    \n    return result", "from functools import lru_cache\n\nmod = 10**9 + 7\n\ndef numOfWays(steps: int, arrLen: int) -> int:\n    @lru_cache(None)\n    def dp(s, p):\n        if p < 0 or p >= arrLen or p > steps - p:\n            return 0\n        if s == 0:\n            return p == 0\n        return (dp(s - 1, p - 1) + dp(s - 1, p) + dp(s - 1, p + 1)) % mod\n\n    return dp(steps, 0)", "def to_hexspeak(num: str) -> str:\n    n = int(num)\n    hex_str = []\n    while n:\n        rem = n % 16\n        if rem == 1: hex_str.insert(0, 'I')\n        elif rem == 0: hex_str.insert(0, 'O')\n        elif rem > 9: hex_str.insert(0, chr(rem - 10 + ord('A')))\n        else: return 'ERROR'\n        n //= 16\n    return ''.join(hex_str)", "def invalid_transactions(transactions):\n    trans_map = {}\n    \n    for trans in transactions:\n        temp = trans.split(\",\")\n        trans_map.setdefault(temp[0], []).append(temp)\n    \n    ans = []\n\n    for trans in transactions:\n        temp = trans.split(\",\")\n\n        if int(temp[2]) > 1000:\n            ans.append(trans)\n            continue\n\n        for other in trans_map[temp[0]]:\n            if other[3] != temp[3] and abs(int(other[1]) - int(temp[1])) <= 60:\n                ans.append(trans)\n                break\n\n    return ans", "def countSmallerFrequencies(words, queries):\n    freqWords = [word.count(min(word)) for word in words]\n    \n    ans = []\n    for query in queries:\n        freqQuery = query.count(min(query))\n        ans.append(sum(f > freqQuery for f in freqWords))\n        \n    return ans", "from datetime import datetime\n\ndef countDaysBetweenDates(date1, date2):\n    d1 = datetime.strptime(date1, \"%Y-%m-%d\")\n    d2 = datetime.strptime(date2, \"%Y-%m-%d\")\n    return abs((d2 - d1).days)", "def validateBinaryTreeNodes(n, leftChild, rightChild):\n    parent = [-1] * n\n    for i in range(n):\n        if leftChild[i] != -1:\n            if parent[leftChild[i]] != -1:\n                return False\n            parent[leftChild[i]] = i\n        if rightChild[i] != -1:\n            if parent[rightChild[i]] != -1:\n                return False\n            parent[rightChild[i]] = i\n    \n    root = -1\n    for i in range(n):\n        if parent[i] == -1:\n            if root != -1:\n                return False\n            root = i\n\n    return root != -1", "def closest_factors(num):\n    factor1 = int((num + 2) ** 0.5)\n    while True:\n        factor2 = (num + 2) // factor1\n        if factor1 * factor2 == num + 2:\n            return factor1, factor2\n        factor2 = (num + 1) // factor1\n        if factor1 * factor2 == num + 1:\n            return factor1, factor2\n        factor1 -= 1", "def largest_multiple_of_three(digits):\n    count = [0] * 3\n    num_sum = sum(digits)\n    \n    for d in digits:\n        count[d % 3] += 1\n\n    if num_sum % 3 == 1:\n        if count[1] >= 1:\n            count[1] -= 1\n        else:\n            count[2] -= 2\n    elif num_sum % 3 == 2:\n        if count[2] >= 1:\n            count[2] -= 1\n        else:\n            count[1] -= 2\n\n    res = \"\"\n    for i in range(10):\n        res += str(i) * count[i % 3]\n    \n    if res and res[-1] == \"0\":\n        return \"0\"\n    return res[::-1]", "def palindromePartition(s: str, k: int) -> int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for len in range(2, n + 1):\n        for i in range(n - len + 1):\n            j = i + len - 1\n            dp[i][j] = dp[i + 1][j - 1] + (s[i] != s[j])\n\n    memo = [float('inf')] * n\n    for i in range(n):\n        if dp[0][i] == 0:\n            memo[i] = 0\n        else:\n            for j in range(i):\n                memo[i] = min(memo[i], memo[j] + dp[j + 1][i])\n\n    return memo[-1] + k", "def can_make_pali_queries(s, queries):\n    result = []\n    for left, right, k in queries:\n        count = [0] * 26\n        for i in range(left, right + 1):\n            count[ord(s[i]) - ord('a')] += 1\n        odd_count = sum(c % 2 for c in count)\n        result.append(odd_count // 2 <= k)\n    return result", "from collections import defaultdict\n\ndef groupThePeople(groupSizes):\n    groups = defaultdict(list)\n    result = []\n\n    for i, size in enumerate(groupSizes):\n        groups[size].append(i)\n        if len(groups[size]) == size:\n            result.append(groups[size])\n            groups[size] = []\n\n    return result", "def format_date(date):\n    months = {\n        \"Jan\": \"01\",\n        \"Feb\": \"02\",\n        \"Mar\": \"03\",\n        \"Apr\": \"04\",\n        \"May\": \"05\",\n        \"Jun\": \"06\",\n        \"Jul\": \"07\",\n        \"Aug\": \"08\",\n        \"Sep\": \"09\",\n        \"Oct\": \"10\",\n        \"Nov\": \"11\",\n        \"Dec\": \"12\",\n    }\n\n    day, month, year = date.split()\n    return f\"{year}-{months[month]}-{day}\"", "def sum_of_divisors_with_four_divisors(nums):\n    total_sum = 0\n\n    for num in nums:\n        div_count = 0\n        div_sum = 0\n\n        for i in range(1, int(num ** 0.5) + 1):\n            if num % i == 0:\n                div_sum += i\n                div_count += 1\n\n                if num // i != i:\n                    div_sum += num // i\n                    div_count += 1\n\n            if div_count > 4:\n                break\n\n        if div_count == 4:\n            total_sum += div_sum\n\n    return total_sum", "def max_sum_subsequence(nums: List[int], k: int) -> int:\n    n = len(nums)\n    dp = [0] * n\n    result = 0\n\n    for i in range(n):\n        dp[i] = nums[i]\n        for j in range(max(0, i - k), i):\n            dp[i] = max(dp[i], dp[j] + nums[i])\n        result = max(result, dp[i])\n\n    return result", "def shortest_distance(distance, start, destination):\n    total_distance = sum(distance)\n    clockwise_distance = sum(distance[start:destination])\n    \n    return min(clockwise_distance, total_distance - clockwise_distance)", "def maximum_sum(arr):\n    n = len(arr)\n    sum_without_deletion = [0] * n\n    sum_with_deletion = [0] * n\n    sum_without_deletion[0] = arr[0]\n    sum_with_deletion[0] = 0\n    max_sum = arr[0]\n\n    for i in range(1, n):\n        sum_without_deletion[i] = max(arr[i], sum_without_deletion[i - 1] + arr[i])\n        sum_with_deletion[i] = max(sum_with_deletion[i - 1] + arr[i], sum_without_deletion[i - 1])\n        max_sum = max(max_sum, max(sum_without_deletion[i], sum_with_deletion[i]))\n    return max_sum", "def day_of_the_week(day, month, year):\n    days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    if month < 3:\n        month += 12\n        year -= 1\n    k = year % 100\n    j = year // 100\n    day_of_week = (day + 13 * (month + 1) // 5 + k + k // 4 + 5 * j + j // 4) % 7\n    return days[day_of_week]", "def min_operations(arr1, arr2):\n    n = len(arr1)\n    dp = [float('inf')] * n\n    for a in arr2:\n        new_dp = [float('inf')] * n\n        p = 0\n        for i in range(n):\n            if a < arr1[i]:\n                new_dp[i] = p\n            if i > 0 and dp[i - 1] < p:\n                p = dp[i - 1]\n            if arr1[i] > arr1[i + 1]:\n                return -1\n        dp = new_dp\n    return dp[-1]", "def sequential_digits(low, high):\n    result = []\n    for i in range(1, 10):\n        number = i\n        for j in range(i + 1, 10):\n            number = number * 10 + j\n            if low <= number <= high:\n                result.append(number)\n    return sorted(result)", "def maxSideLength(mat: List[List[int]], threshold: int) -> int:\n    m, n = len(mat), len(mat[0])\n    preSum = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            preSum[i][j] = mat[i - 1][j - 1] + preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1]\n\n    maxSide = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, min(m, n) + 1):\n                endX, endY = i + k - 1, j + k - 1\n                if endX <= m and endY <= n:\n                    sum = preSum[endX][endY] - preSum[endX][j - 1] - preSum[i - 1][endY] + preSum[i - 1][j - 1]\n                    if sum <= threshold:\n                        maxSide = max(maxSide, k)\n                else:\n                    break\n    return maxSide", "from collections import deque\n\ndef shortestPath(grid, k):\n    m, n = len(grid), len(grid[0])\n    visited = [[[False for _ in range(k + 1)] for _ in range(n)] for _ in range(m)]\n    q = deque([(0, 0, 0, k)])\n    moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    steps = 0\n\n    while q:\n        for _ in range(len(q)):\n            x, y, steps, k_remaining = q.popleft()\n            if x == m - 1 and y == n - 1:\n                return steps\n            for dx, dy in moves:\n                new_x, new_y, = x + dx, y + dy\n                if 0 <= new_x < m and 0 <= new_y < n:\n                    new_k_remaining = k_remaining - grid[new_x][new_y]\n                    if new_k_remaining >= 0 and not visited[new_x][new_y][new_k_remaining]:\n                        visited[new_x][new_y][new_k_remaining] = True\n                        q.append((new_x, new_y, steps + 1, new_k_remaining))\n        steps += 1\n\n    return -1", "def min_perimeter(neededApples):\n    layer = 0\n    apples = 0\n\n    while apples < neededApples:\n        layer += 1\n        apples += 12 * layer\n\n    return 8 * layer", "class TreeAncestor:\n\n    def __init__(self, n: int, parent: List[int]):\n        self.dp = [[0] * 20 for _ in range(n)]\n        for i in range(n):\n            self.dp[i][0] = parent[i]\n        for k in range(1, 20):\n            for i in range(n):\n                if self.dp[i][k - 1] != -1:\n                    self.dp[i][k] = self.dp[self.dp[i][k - 1]][k - 1]\n                else:\n                    self.dp[i][k] = -1\n\n    def getKthAncestor(self, node: int, k: int) -> int:\n        for i in range(20):\n            if k & (1 << i):\n                node = self.dp[node][i]\n                if node == -1:\n                    return -1\n        return node", "def maxNumberOfBalloons(text):\n    freqs = [0] * 26\n    for c in text:\n        freqs[ord(c) - ord('a')] += 1\n    subs = [freqs[ord('b') - ord('a')], freqs[ord('a') - ord('a')], freqs[ord('l') - ord('a')] // 2, freqs[ord('o') - ord('a')] // 2, freqs[ord('n') - ord('a')]]\n    return min(subs)", "def reverseParentheses(s: str) -> str:\n    st = []\n    result = []\n\n    for c in s:\n        if c != ')':\n            st.append(c)\n        else:\n            temp = []\n            while st and st[-1] != '(':\n                temp.append(st.pop())\n            if st: st.pop()  # Remove '('\n            st.extend(temp)\n\n    result = \"\".join(st)\n    return result", "def kConcatenationMaxSum(arr, k):\n    M = 10**9 + 7\n    s = sum(arr)\n    max_sum = max_ending_here = 0\n    for i in range(len(arr) * min(2, k)):\n        max_ending_here = max(arr[i % len(arr)], max_ending_here + arr[i % len(arr)])\n        max_sum = max(max_sum, max_ending_here)\n    return 0 if k == 1 else (((max_sum - max_ending_here) % M) * (k - 2) % M + max_ending_here) % M", "from collections import defaultdict\n\ndef criticalConnections(n, connections):\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    ans = []\n    low, disc = [-1] * n, [-1] * n\n    time = [0]\n\n    def dfs(u, parent):\n        low[u] = disc[u] = time[0]\n        time[0] += 1\n        for v in graph[u]:\n            if v == parent:\n                continue\n            if disc[v] == -1:\n                dfs(v, u)\n                low[u] = min(low[u], low[v])\n                if low[v] > disc[u]:\n                    ans.append([u, v])\n            else:\n                low[u] = min(low[u], disc[v])\n\n    dfs(0, -1)\n    return ans", "from typing import List\n\nMOD = 10**9 + 7\n\ndef pathsWithMaxScore(board: List[str]) -> List[int]:\n    n = len(board)\n    dp = [[0] * n for _ in range(n)]\n    cnt = [[0] * n for _ in range(n)]\n\n    board[0] = list(board[0])\n    board[0][0] = '0'\n    board[n-1] = list(board[n-1])\n    board[n-1][n-1] = '0'\n    cnt[n-1][n-1] = 1\n\n    for i in range(n-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            if board[i][j] != 'X':\n                neighbors = [(i-1, j), (i, j-1), (i-1, j-1)]\n                for x, y in neighbors:\n                    if x >= 0 and y >= 0:\n                        if dp[i][j] < dp[x][y] + int(board[i][j]):\n                            dp[i][j] = dp[x][y] + int(board[i][j])\n                            cnt[i][j] = cnt[x][y]\n                        elif dp[i][j] == dp[x][y] + int(board[i][j]):\n                            cnt[i][j] = (cnt[i][j] + cnt[x][y]) % MOD\n\n    return [dp[0][0], cnt[0][0]]", "def make_fancy_string(s: str) -> str:\n    result = [s[0]]\n    count = 1\n\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            count = 1\n        if count < 3:\n            result.append(s[i])\n\n    return ''.join(result)", "from heapq import heappush, heappop\n\ndef longestHappyString(a, b, c):\n    res = \"\"\n    pq = []\n    if a: heappush(pq, (-a, 'a'))\n    if b: heappush(pq, (-b, 'b'))\n    if c: heappush(pq, (-c, 'c'))\n\n    while pq:\n        curr = heappop(pq)\n        if len(res) >= 2 and res[-1] == curr[1] and res[-2] == curr[1]:\n            if not pq: break\n            next = heappop(pq)\n            res += next[1]\n            if next[0] < -1: heappush(pq, (next[0] + 1, next[1]))\n            heappush(pq, curr)\n        else:\n            res += curr[1]\n            if curr[0] < -1: heappush(pq, (curr[0] + 1, curr[1]))\n\n    return res", "def people_can_see(heights):\n    n = len(heights)\n    ans = [0] * n\n    st = []\n\n    for i in range(n - 1, -1, -1):\n        while st and heights[st[-1]] < heights[i]:\n            idx = st.pop()\n            ans[i] += 1\n            ans[i] += ans[idx]\n        st.append(i)\n\n    return ans", "def minimumAbsDifference(arr):\n    arr.sort()\n    min_difference = float('inf')\n    result = []\n\n    for i in range(1, len(arr)):\n        difference = arr[i] - arr[i - 1]\n        if difference < min_difference:\n            min_difference = difference\n            result = [[arr[i - 1], arr[i]]]\n        elif difference == min_difference:\n            result.append([arr[i - 1], arr[i]])\n\n    return result", "def nthUglyNumber(n, a, b, c):\n    from math import gcd\n\n    ab = a * b // gcd(a, b)\n    ac = a * c // gcd(a, c)\n    bc = b * c // gcd(b, c)\n    abc = a * bc // gcd(a, bc)\n\n    left, right = 0, 2 * 10**9\n    while left < right:\n        mid = left + (right - left) // 2\n        cnt = mid // a + mid // b + mid // c - mid // ab - mid // ac - mid // bc + mid // abc\n        if cnt < n:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left", "from collections import defaultdict, deque\n\ndef sortItems(n, m, group, beforeItems):\n    def topological_sort(outdegree, edges):\n        res = []\n        q = deque([i for i in range(len(outdegree)) if outdegree[i] == 0])\n        while q:\n            u = q.pop()\n            res.append(u)\n            for v in edges[u]:\n                outdegree[v] -= 1\n                if outdegree[v] == 0:\n                    q.append(v)\n        return res\n\n    # Calculate outdegrees and dependencies for groups and items\n    group_outdegree = [0] * m\n    group_edges = defaultdict(list)\n\n    item_outdegree = [0] * n\n    item_edges = defaultdict(list)\n\n    for i in range(n):\n        for dep in beforeItems[i]:\n            a, b = group[i], group[dep]\n            if a != -1 and a != b and not (group_edges[b] and group_edges[b][-1] == a):\n                group_edges[b].append(a)\n                group_outdegree[a] += 1\n            if a != b:\n                item_edges[dep].append(i)\n                item_outdegree[i] += 1\n\n    group_order = topological_sort(group_outdegree, group_edges)\n    if len(group_order) < m:\n        return []\n\n    item_order = topological_sort(item_outdegree, item_edges)\n    if len(item_order) < n:\n        return []\n\n    # Combine orders\n    res = [0] * n\n    idx = 0\n    for gi in group_order:\n        for item_idx in item_order:\n            if group[item_idx] == gi:\n                res[idx] = item_idx\n                idx += 1\n\n    return res", "def water_plants(plants, capacity):\n    steps = 0\n    water_left = 0\n\n    for i, plant in enumerate(plants):\n        if water_left < plant:\n            steps += 2 * i + 1  # Refill the watering can\n            water_left = capacity\n        water_left -= plant\n        steps += 1  # Move to the next plant\n\n    return steps", "def largestMagicSquare(grid):\n    m, n = len(grid), len(grid[0])\n    row = [[0] * (n + 1) for _ in range(m)]\n    col = [[0] * n for _ in range(m + 1)]\n\n    for i in range(m):\n        for j in range(n):\n            row[i][j + 1] = row[i][j] + grid[i][j]\n            col[i + 1][j] = col[i][j] + grid[i][j]\n\n    for k in reversed(range(2, min(m, n) + 1)):\n        for i in range(m - k + 1):\n            for j in range(n - k + 1):\n                _sum = row[i][j + k] - row[i][j]\n                ok = all(row[i + t][j + k] - row[i + t][j] == _sum for t in range(1, k)) and all(\n                    col[i + k][j + t] - col[i][j + t] == _sum for t in range(1, k))\n\n                if not ok: continue\n                \n                diag1 = sum(grid[i + t][j + t] for t in range(k))\n                diag2 = sum(grid[i + t][j + k - 1 - t] for t in range(k))\n                \n                if diag1 == _sum and diag2 == _sum: return k\n\n    return 1", "def extract_artifacts(n, artifacts, dig):\n    artifact_cells = {}\n    artifact_count = {}\n\n    for i, (r1, c1, r2, c2) in enumerate(artifacts):\n        for r in range(r1, r2 + 1):\n            for c in range(c1, c2 + 1):\n                cell = r * n + c\n                if cell not in artifact_cells:\n                    artifact_cells[cell] = set()\n                artifact_cells[cell].add(i)\n                artifact_count[i] = artifact_count.get(i, 0) + 1\n\n    ans = 0\n    for r, c in dig:\n        cell = r * n + c\n        if cell in artifact_cells:\n            for artifact_id in artifact_cells[cell]:\n                artifact_count[artifact_id] -= 1\n                if artifact_count[artifact_id] == 0:\n                    ans += 1\n            del artifact_cells[cell]\n\n    return ans", "MOD = 10**9 + 7\n\ndef add_rooms(idx, children, memo):\n    if not children[idx]:\n        return 1\n    if memo[idx] != -1:\n        return memo[idx]\n\n    res = 1\n    cnt = 0\n    for child in children[idx]:\n        cnt += 1\n        res = (res * add_rooms(child, children, memo)) % MOD\n    \n    for i in range(2, cnt + 1):\n        res = (res * i) % MOD\n    \n    memo[idx] = res\n    return res\n\ndef num_of_ways(prev_room):\n    n = len(prev_room)\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[prev_room[i]].append(i)\n\n    memo = [-1] * n\n    return add_rooms(0, children, memo)", "def matrix_block_sum(mat, k):\n    m, n = len(mat), len(mat[0])\n    answer = [[0 for _ in range(n)] for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            for r in range(max(0, i - k), min(m, i + k + 1)):\n                for c in range(max(0, j - k), min(n, j + k + 1)):\n                    answer[i][j] += mat[r][c]\n                    \n    return answer", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef sumEvenGrandparent(root, parent=None, grandparent=None):\n    if root is None:\n        return 0\n    sum = root.val if grandparent and grandparent.val % 2 == 0 else 0\n    return sum + sumEvenGrandparent(root.left, root, parent) + sumEvenGrandparent(root.right, root, parent)", "def no_zero_integers(n: int):\n    for a in range(1, n):\n        if '0' not in str(a) and '0' not in str(n - a):\n            return [a, n - a]\n    return [0, 0]  # never gets here", "def minFlips(a: int, b: int, c: int) -> int:\n    count = 0\n    for i in range(32):\n        bitA = (a >> i) & 1\n        bitB = (b >> i) & 1\n        bitC = (c >> i) & 1\n        if bitC == 0:\n            count += bitA + bitB\n        else:\n            count += 1 - (bitA | bitB)\n    return count", "def unique_occurrences(arr):\n    counts = {}\n    for num in arr:\n        counts[num] = counts.get(num, 0) + 1\n    \n    unique_counts = set()\n    for count in counts.values():\n        if count in unique_counts:\n            return False\n        unique_counts.add(count)\n    \n    return True", "def removeDuplicates(s: str, k: int) -> str:\n    stack = []\n    for c in s:\n        if stack and stack[-1][0] == c:\n            stack[-1][1] += 1\n            if stack[-1][1] == k:\n                stack.pop()\n        else:\n            stack.append([c, 1])\n    return ''.join(c * n for c, n in stack)", "def maximum69Number(num: int) -> int:\n    num_str = list(str(num))\n    for i in range(len(num_str)):\n        if num_str[i] == '6':\n            num_str[i] = '9'\n            break\n    return int(''.join(num_str))", "def findBall(grid):\n    m, n = len(grid), len(grid[0])\n    result = [-1] * n\n\n    for i in range(n):\n        x, y = 0, i\n\n        while x < m:\n            nx, ny = x + 1, y + grid[x][y]\n            if ny < 0 or ny >= n or grid[x][ny] != grid[x][y]:\n                break\n            x, y = nx, ny\n\n        if x == m:\n            result[i] = y\n\n    return result", "from heapq import heappush, heappop\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = [[] for _ in range(n)]\n    for i in range(len(edges)):\n        a, b = edges[i]\n        graph[a].append((b, succProb[i]))\n        graph[b].append((a, succProb[i]))\n\n    max_prob = [0] * n\n    max_prob[start] = 1\n\n    pq = [(-1, start)]\n    \n    while pq:\n        prob, node = heappop(pq)\n\n        if node == end:\n            return -prob\n\n        if -prob < max_prob[node]:\n            continue\n\n        for neighbor, edge_prob in graph[node]:\n            new_prob = -prob * edge_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heappush(pq, (-new_prob, neighbor))\n\n    return 0", "def sum_of_floored_pairs(nums):\n    mod = 10**9 + 7\n    max_val = max(nums)\n    count = [0] * (max_val + 1)\n    pref_sum = [0] * (max_val + 1)\n\n    for num in nums:\n        count[num] += 1\n\n    for i in range(1, max_val + 1):\n        pref_sum[i] = (pref_sum[i - 1] + count[i]) % mod\n\n    res = 0\n    for x in range(1, max_val + 1):\n        nx = x\n        k = 1\n        while nx <= max_val:\n            res = (res + ((pref_sum[nx] - pref_sum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod\n            k += 1\n            nx += x\n    return res", "def breakPalindrome(palindrome: str) -> str:\n    length = len(palindrome)\n    if length == 1:\n        return \"\"\n    \n    chars = list(palindrome)\n    for i in range(length // 2):\n        if chars[i] != 'a':\n            chars[i] = 'a'\n            return \"\".join(chars)\n    \n    chars[length - 1] = 'b'\n    return \"\".join(chars)", "def minCostToMoveChips(position):\n    evenCount, oddCount = 0, 0\n    for i in position:\n        if i % 2 == 0:\n            evenCount += 1\n        else:\n            oddCount += 1\n    return min(evenCount, oddCount)", "def longestSubsequence(arr, difference):\n    dp = {}\n    maxLength = 0\n    for num in arr:\n        dp[num] = dp.get(num - difference, 0) + 1\n        maxLength = max(maxLength, dp[num])\n    return maxLength", "def getMaximumGold(grid):\n    m, n, max_gold = len(grid), len(grid[0]), 0\n\n    def getMaximumGoldHelper(x, y):\n        if not (0 <= x < m) or not (0 <= y < n) or grid[x][y] == 0:\n            return 0\n\n        original_gold = grid[x][y]\n        grid[x][y] = 0\n\n        max_gold = 0\n        max_gold = max(max_gold, getMaximumGoldHelper(x + 1, y))\n        max_gold = max(max_gold, getMaximumGoldHelper(x - 1, y))\n        max_gold = max(max_gold, getMaximumGoldHelper(x, y + 1))\n        max_gold = max(max_gold, getMaximumGoldHelper(x, y - 1))\n\n        grid[x][y] = original_gold\n        return max_gold + original_gold\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                max_gold = max(max_gold, getMaximumGoldHelper(i, j))\n\n    return max_gold", "def countStrings(n):\n    mod = 10**9 + 7\n    a, b = 1, 1\n    for _ in range(n):\n        a = (a * 2) % mod\n        b = (b * 3) % mod\n    return (b - a + mod) % mod", "def sort_based_on_mapping(mapping, nums):\n    def mapped_value(num):\n        return int(''.join(str(mapping[int(d)]) for d in str(num)))\n    \n    return sorted(nums, key=mapped_value)", "def findTheCity(n, edges, distanceThreshold):\n    distance = [[1e5] * n for _ in range(n)]\n\n    for edge in edges:\n        distance[edge[0]][edge[1]] = edge[2]\n        distance[edge[1]][edge[0]] = edge[2]\n\n    for i in range(n):\n        distance[i][i] = 0\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n\n    res, minReachable = 0, n\n    for i in range(n):\n        reachable = sum(1 for j in range(n) if distance[i][j] <= distanceThreshold)\n        if reachable <= minReachable:\n            minReachable = reachable\n            res = i\n    return res", "def max_candies(candies, k):\n    left, right = 1, max(candies)\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        count = sum(candy // mid for candy in candies)\n        if count >= k:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return right", "from typing import List\n\ndef kWeakestRows(mat: List[List[int]], k: int) -> List[int]:\n    soldiers_count = [(sum(row), idx) for idx, row in enumerate(mat)]\n    soldiers_count.sort()\n    return [x[1] for x in soldiers_count[:k]]", "from collections import Counter\nimport heapq\n\ndef minSetSize(arr):\n    freq_map = Counter(arr)\n    max_heap = [-cnt for cnt in freq_map.values()]\n    heapq.heapify(max_heap)\n    half = len(arr) // 2\n    cnt = 0\n    size = 0\n    while size < half:\n        size -= heapq.heappop(max_heap)\n        cnt += 1\n    return cnt", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def sum_subtrees(self, root, sums):\n        if not root: return 0\n        s = root.val + self.sum_subtrees(root.left, sums) + self.sum_subtrees(root.right, sums)\n        sums.append(s)\n        return s\n\n    def maxProduct(self, root):\n        sums = []\n        total = self.sum_subtrees(root, sums)\n        max_product = max(s * (total - s) for s in sums)\n        return max_product % 1000000007", "import threading\n\nclass DiningPhilosophers:\n    def __init__(self):\n        self.forks = [threading.Lock() for _ in range(5)]\n        self.not_busy = [threading.Condition(self.forks[i]) for i in range(5)]\n\n    def wantsToEat(self, philosopher: int, pickLeftFork: 'Callable[[], None]', pickRightFork: 'Callable[[], None]', eat: 'Callable[[], None]', putLeftFork: 'Callable[[], None]', putRightFork: 'Callable[[], None]') -> None:\n        left_fork = philosopher\n        right_fork = (philosopher + 1) % 5\n\n        with self.forks[left_fork]:\n            with self.not_busy[left_fork]:\n                while not self.forks[right_fork].acquire(blocking=False):\n                    self.not_busy[left_fork].wait()\n            pickLeftFork()\n\n            with self.forks[right_fork]:\n                pickRightFork()\n                eat()\n                putRightFork()\n                self.forks[right_fork].release()\n                with self.not_busy[right_fork]:\n                    self.not_busy[right_fork].notify_all()\n\n            putLeftFork()\n            self.not_busy[left_fork].notify_all()", "def queensAttacktheKing(queens, king):\n    result = []\n    for x in range(-1, 2):\n        for y in range(-1, 2):\n            if x == 0 and y == 0:\n                continue\n            posX, posY = king[0] + x, king[1] + y\n            while 0 <= posX < 8 and 0 <= posY < 8:\n                for queen in queens:\n                    if posX == queen[0] and posY == queen[1]:\n                        result.append([queen[0], queen[1]])\n                        break\n                posX += x\n                posY += y\n    return result", "def dieSimulator(n, rollMax):\n    MOD = 10**9 + 7\n    dp = [[0] * (n + 1) for _ in range(6)]\n    sum_dp = [0] * (n + 1)\n\n    for i in range(6):\n        dp[i][1] = 1\n    sum_dp[1] = 6\n\n    for j in range(2, n + 1):\n        cur_sum = 0\n        for i in range(6):\n            dp[i][j] = sum_dp[j - 1]\n            if j - rollMax[i] - 1 >= 0:\n                dp[i][j] = (dp[i][j] - sum_dp[j - rollMax[i] - 1] + MOD) % MOD\n                if j - rollMax[i] - 1 >= 1:\n                    dp[i][j] = (dp[i][j] + dp[i][j - rollMax[i] - 1]) % MOD\n            cur_sum = (cur_sum + dp[i][j]) % MOD\n        sum_dp[j] = cur_sum\n\n    return sum_dp[n]", "def maxEqualFreq(nums):\n    count, freq = {}, {}\n    max_len, max_freq = 0, 0\n    for i, num in enumerate(nums):\n        count[num] = count.get(num, 0) + 1\n        freq[count[num] - 1] = freq.get(count[num] - 1, 0) - 1\n        freq[count[num]] = freq.get(count[num], 0) + 1\n\n        max_freq = max(max_freq, count[num])\n        if max_freq * (i + 1) == i or max_freq * (freq.get(max_freq - 1, 0) + 1) + (max_freq - 1) * freq.get(max_freq - 1, 0) == i:\n            max_len = i + 1\n    return max_len", "from collections import defaultdict\n\ndef minJumps(arr):\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    value_indices = defaultdict(list)\n    \n    for i, value in enumerate(arr):\n        value_indices[value].append(i)\n\n    q = [0]\n    visited = [False] * n\n    visited[0] = True\n    steps = 0\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            index = q.pop(0)\n            \n            if index == n - 1:\n                return steps\n            \n            if index > 0 and not visited[index - 1]:\n                q.append(index - 1)\n                visited[index - 1] = True\n                \n            if index < n - 1 and not visited[index + 1]:\n                q.append(index + 1)\n                visited[index + 1] = True\n\n            for neighbor in value_indices[arr[index]]:\n                if not visited[neighbor]:\n                    q.append(neighbor)\n                    visited[neighbor] = True\n            \n            value_indices[arr[index]] = []\n\n        steps += 1\n\n    return -1", "def maxValueInStack(nums, k):\n    n = len(nums)\n    if k >= n:\n        return -1\n\n    max_val = float('-inf')\n    for i in range(k+1):\n        max_val = max(max_val, nums[i])\n    return max_val", "def minSteps(s, t):\n    s_Count = [0] * 26\n    t_Count = [0] * 26\n    for c in s: s_Count[ord(c) - ord('a')] += 1\n    for c in t: t_Count[ord(c) - ord('a')] += 1\n    res = 0\n    for i in range(26):\n        res += abs(s_Count[i] - t_Count[i])\n    return res // 2", "from collections import defaultdict\nfrom typing import List\n\nclass TweetCounts:\n\n    def __init__(self):\n        self.data = defaultdict(dict)\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if time not in self.data[tweetName]:\n            self.data[tweetName][time] = 1\n        else:\n            self.data[tweetName][time] += 1\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        step = 60 if freq == \"minute\" else 3600 if freq == \"hour\" else 86400\n        chunks = [0] * ((endTime - startTime) // step + 1)\n\n        if tweetName in self.data:\n            for time, count in self.data[tweetName].items():\n                chunk_index = (time - startTime) // step\n                if 0 <= chunk_index < len(chunks):\n                    chunks[chunk_index] += count\n\n        return chunks", "from typing import List\n\ndef checkStraightLine(coordinates: List[List[int]]) -> bool:\n    dx = coordinates[1][0] - coordinates[0][0]\n    dy = coordinates[1][1] - coordinates[0][1]\n\n    for x, y in coordinates[2:]:\n        if dx * (y - coordinates[0][1]) != dy * (x - coordinates[0][0]):\n            return False\n\n    return True", "def balanced_string(s):\n    n = len(s)\n    freq_map = {}\n    for c in s:\n        freq_map[c] = freq_map.get(c, 0) + 1\n    \n    i = 0\n    result = n\n    for j in range(n):\n        freq_map[s[j]] -= 1\n        while i < n and all(freq_map.get(c, 0) <= n // 4 for c in \"QWER\"):\n            result = min(result, j - i + 1)\n            freq_map[s[i]] += 1\n            i += 1\n    \n    return result", "from functools import lru_cache\n\nclass Job:\n    def __init__(self, start, end, profit):\n        self.start = start\n        self.end = end\n        self.profit = profit\n\ndef find_next_job(jobs, i):\n    for j in range(i + 1, len(jobs)):\n        if jobs[j].start >= jobs[i].end:\n            return j\n    return -1\n\n@lru_cache(None)\ndef max_profit_helper(jobs, i):\n    if i == -1:\n        return 0\n\n    next_job = find_next_job(jobs, i)\n    incl_curr_job = jobs[i].profit + max_profit_helper(jobs, next_job)\n    excl_curr_job = max_profit_helper(jobs, i - 1)\n    \n    return max(incl_curr_job, excl_curr_job)\n\ndef max_profit(startTime, endTime, profit):\n    n = len(startTime)\n    jobs = [Job(startTime[i], endTime[i], profit[i]) for i in range(n)]\n\n    jobs.sort(key=lambda job: job.end)\n    \n    return max_profit_helper(tuple(jobs), n - 1)", "import heapq\n\ndef maxEvents(events: List[List[int]]) -> int:\n    events.sort(key=lambda x: x[0])\n    min_heap = []\n    event_count, day = 0, 0\n\n    for event in events:\n        while min_heap and min_heap[0] < event[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, event[1])\n        event_count += 1\n        day += 1\n\n    return event_count", "from sortedcontainers import SortedSet\n\ndef winners_and_losers(matches):\n    winners, losers = SortedSet(), SortedSet()\n\n    for winner, loser in matches:\n        winners.add(winner)\n        losers.add(loser)\n\n    return [list(winners), list(losers)]", "def min_moves_to_palindrome(s: str) -> int:\n    moves = 0\n    s = list(s)\n    left, right = 0, len(s) - 1\n\n    while left < right:\n        if s[left] != s[right]:\n            temp_right = right\n\n            while s[left] != s[temp_right]:\n                temp_right -= 1\n            s.insert(right, s.pop(temp_right))\n            moves += right - temp_right\n        left += 1\n        right -= 1\n\n    return moves", "class Cashier:\n\n    def __init__(self, n: int, discount: int, products: List[int], prices: List[int]):\n        self.n = n\n        self.discount = discount\n        self.customer_count = 0\n        self.prices_map = {products[i]: prices[i] for i in range(len(products))}\n\n    def getBill(self, product: List[int], amount: List[int]) -> float:\n        self.customer_count += 1\n        total = sum(self.prices_map[product[i]] * amount[i] for i in range(len(product)))\n        if self.customer_count % self.n == 0:\n            total *= (100 - self.discount) / 100\n        return total", "def find_pairs(z):\n    pairs = []\n    \n    def f(x, y):\n        return x + y\n    \n    for x in range(1, z+1):\n        for y in range(1, z+1):\n            if f(x, y) == z:\n                pairs.append((x, y))\n    return pairs", "def circular_permutation(n, start):\n    result = [start ^ (i ^ (i >> 1)) for i in range(1 << n)]\n    return result", "def maxLength(arr):\n    dp = ['']\n    maxLen = 0\n\n    for s in arr:\n        if len(set(s)) < len(s): continue\n        for i in range(len(dp) - 1, -1, -1):\n            tmp = dp[i] + s\n            if len(set(tmp)) == len(tmp):\n                dp.append(tmp)\n                maxLen = max(maxLen, len(tmp))\n                \n    return maxLen", "def tilingRectangle(n, m):\n    if n > m:\n        n, m = m, n\n    if n == 1:\n        return m\n    if n == m:\n        return 1\n\n    res = float('inf')\n    for a in range(1, n // 2 + 1):\n        res = min(res, tilingRectangle(a, m) + tilingRectangle(n - a, m))\n\n    for b in range(1, m // 2 + 1):\n        res = min(res, tilingRectangle(n, b) + tilingRectangle(n, m - b))\n\n    return res", "def findClosestDivisors(num):\n    for i in range(int((num + 2) ** 0.5), 0, -1):\n        if (num + 1) % i == 0:\n            return [i, (num + 1) // i]\n        if (num + 2) % i == 0:\n            return [i, (num + 2) // i]\n    return []", "from collections import defaultdict\n\ndef largest_multiple_of_three(digits):\n    digits.sort(reverse=True)\n    sum_digits = sum(digits)\n\n    if sum_digits % 3 == 0:\n        return '0' if digits[-1] == 0 else ''.join(map(str, digits))\n\n    mod = defaultdict(list)\n    for digit in digits:\n        mod[digit % 3].append(digit)\n\n    if sum_digits % 3 == 1:\n        if mod[1]:\n            mod[1].pop()\n        else:\n            mod[2].pop(), mod[2].pop()\n    else:\n        if mod[2]:\n            mod[2].pop()\n        else:\n            mod[1].pop(), mod[1].pop()\n\n    result = \"\".join(str(digit) for value in mod.values() for digit in value)\n    result = \"\".join(sorted(result, reverse=True))\n\n    return '0' if not result or result[0] == '0' else result", "def smallerNumbersThanCurrent(nums):\n    result = []\n    for i in range(len(nums)):\n        count = 0\n        for j in range(len(nums)):\n            if i != j and nums[j] < nums[i]:\n                count += 1\n        result.append(count)\n    return result", "def rankTeams(votes):\n    n, m = len(votes), len(votes[0])\n    count = [[0] * m for _ in range(26)]\n    res = votes[0]\n\n    for vote in votes:\n        for j, team in enumerate(vote):\n            count[ord(team) - ord('A')][j] += 1\n\n    return ''.join(sorted(res, key=lambda x: (-count[ord(x) - ord('A')][:m], x)))", "def maxHeight(cuboids):\n    cuboids = [sorted(cuboid) for cuboid in cuboids]\n    cuboids.sort()\n\n    n = len(cuboids)\n    dp = [0] * n\n    ans = 0\n\n    for i, cuboid in enumerate(cuboids):\n        dp[i] = cuboid[2]\n        for j in range(i):\n            if all(cuboids[j][k] <= cuboid[k] for k in range(3)):\n                dp[i] = max(dp[i], dp[j] + cuboid[2])\n\n        ans = max(ans, dp[i])\n\n    return ans", "from collections import deque\n\ndef minCost(grid):\n    m, n = len(grid), len(grid[0])\n    cost = 0\n\n    visited = [[1000000] * n for _ in range(m)]\n    q = deque([(0, 0)])\n    visited[0][0] = 0\n\n    while q:\n        y, x = q.popleft()\n        if y == m - 1 and x == n - 1:\n            cost = visited[y][x]\n            break\n\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n\n        for dir in range(4):\n            newY, newX = y + dy[dir], x + dx[dir]\n            if 0 <= newY < m and 0 <= newX < n:\n                newCost = visited[y][x] + (1 if dir + 1 != grid[y][x] else 0)\n                if newCost < visited[newY][newX]:\n                    visited[newY][newX] = newCost\n                    q.append((newY, newX))\n\n    return cost", "def numberOfSubarrays(nums, k):\n    n = len(nums)\n    result = count = 0\n    odd_count = [0] * (n + 1)\n\n    odd_count[0] = 1\n    for num in nums:\n        count += num % 2\n        if count >= k:\n            result += odd_count[count - k]\n        odd_count[count] += 1\n\n    return result", "def min_remove_to_make_valid(s: str) -> str:\n    stk = []\n    result = list(s)\n\n    for i, ch in enumerate(s):\n        if ch == '(':\n            stk.append(i)\n        elif ch == ')':\n            if stk:\n                stk.pop()\n            else:\n                result[i] = ''\n\n    for i in stk:\n        result[i] = ''\n\n    return ''.join(result)", "from math import gcd\nfrom functools import reduce\n\ndef is_good_array(nums):\n    gcd_value = reduce(gcd, nums)\n    return gcd_value == 1", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def maxSumBST(self, root: TreeNode) -> int:\n        max_sum = [0]\n\n        def dfs(node):\n            if not node:\n                return 1, 0, float(\"inf\"), float(\"-inf\")\n\n            l = dfs(node.left)\n            r = dfs(node.right)\n\n            if not l[0] or not r[0] or node.val <= l[3] or node.val >= r[2]:\n                return 0, 0, 0, 0\n\n            curr_sum = node.val + l[1] + r[1]\n            max_sum[0] = max(max_sum[0], curr_sum)\n\n            return 1, curr_sum, min(node.val, l[2]), max(node.val, r[3])\n\n        dfs(root)\n        return max_sum[0]", "def generateTheString(n: int) -> str:\n    result = 'a' * n\n    if n % 2 == 0:\n        result = result[:-1] + 'b'\n    return result", "def find_kth_palindrome(k, int_length):\n    mid = (int_length + 1) // 2\n    limit = 10 ** mid - 1\n\n    i = 0\n    while i <= limit:\n        num = str(i)\n        rev = num[::-1]\n        if int_length % 2 != 0:\n            rev = rev[1:]\n        palindrome = int(num + rev)\n        if palindrome > 0:\n            k -= 1\n        if k == 0:\n            return palindrome\n        i += 1\n    return -1\n\ndef palindrome_queries(queries, int_length):\n    return [find_kth_palindrome(query, int_length) for query in queries]", "def numOfMinutes(n, headID, manager, informTime):\n    subordinates = [[] for _ in range(n)]\n    for i in range(n):\n        if manager[i] != -1:\n            subordinates[manager[i]].append(i)\n    return dfs(headID, subordinates, informTime)\n\ndef dfs(employee, subordinates, informTime):\n    if informTime[employee] == 0:\n        return 0\n    max_time = 0\n    for i in subordinates[employee]:\n        max_time = max(max_time, dfs(i, subordinates, informTime))\n    return max_time + informTime[employee]", "from collections import defaultdict\n\ndef dfs(node, parent, t, target, graph, prob, ans):\n    if t == 0:\n        if node == target:\n            ans[0] += prob\n        return\n\n    has_child = False\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            has_child = True\n            dfs(neighbor, node, t - 1, target, graph, prob / (len(graph[node]) - (1 if node != 1 else 0)), ans)\n\n    if not has_child and node == target:\n        ans[0] += prob\n\ndef frogPosition(n, edges, t, target):\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    ans = [0.0]\n    dfs(1, -1, t, target, graph, 1.0, ans)\n    return ans[0]", "def reconstructMatrix(upper, lower, colsum):\n    result = [[0] * len(colsum) for _ in range(2)]\n    \n    for i in range(len(colsum)):\n        if colsum[i] == 2:\n            result[0][i] = 1\n            result[1][i] = 1\n            upper -= 1\n            lower -= 1\n        elif colsum[i] == 1:\n            if upper > lower:\n                result[0][i] = 1\n                upper -= 1\n            else:\n                result[1][i] = 1\n                lower -= 1\n        \n        if upper < 0 or lower < 0:\n            return []\n    \n    if upper > 0 or lower > 0:\n        return []\n    \n    return result", "dx = [-1, 1, 0, 0]\ndy = [0, 0, -1, 1]\n\ndef dfs(grid, x, y):\n    n, m = len(grid), len(grid[0])\n    grid[x][y] = 1\n    for i in range(4):\n        nx, ny = x + dx[i], y + dy[i]\n        if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0:\n            dfs(grid, nx, ny)\n\ndef closedIsland(grid):\n    n, m = len(grid), len(grid[0])\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or i == n - 1 or j == 0 or j == m - 1:\n                if grid[i][j] == 0:\n                    dfs(grid, i, j)\n    res = 0\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            if grid[i][j] == 0:\n                dfs(grid, i, j)\n                res += 1\n    return res", "def get_max_score(word, score):\n    return sum(score[ord(c) - ord('a')] for c in word)\n\ndef get_max_score_helper(words, score, letters, i):\n    if i == len(words):\n        return 0\n    letters_copy = letters.copy()\n    for c in words[i]:\n        if letters_copy[c] == 0:\n            return get_max_score_helper(words, score, letters, i + 1)\n        letters_copy[c] -= 1\n    return max(get_max_score(words[i], score) + get_max_score_helper(words, score, letters_copy, i + 1),\n               get_max_score_helper(words, score, letters, i + 1))\n\ndef max_score_words(words, letters, score):\n    letters_count = {}\n    for letter in letters:\n        letters_count[letter] = letters_count.get(letter, 0) + 1\n    return get_max_score_helper(words, score, letters_count, 0)", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def balanceBST(self, root: TreeNode) -> TreeNode:\n        sortedNodes = []\n        self.inorderTraversal(root, sortedNodes)\n        return self.sortedArrayToBST(sortedNodes, 0, len(sortedNodes) - 1)\n\n    def inorderTraversal(self, node: TreeNode, sortedNodes: list):\n        if node is None: return\n        self.inorderTraversal(node.left, sortedNodes)\n        sortedNodes.append(node)\n        self.inorderTraversal(node.right, sortedNodes)\n\n    def sortedArrayToBST(self, sortedNodes: list, start: int, end: int) -> TreeNode:\n        if start > end: return None\n        mid = start + (end - start) // 2\n        newNode = sortedNodes[mid]\n        newNode.left = self.sortedArrayToBST(sortedNodes, start, mid - 1)\n        newNode.right = self.sortedArrayToBST(sortedNodes, mid + 1, end)\n        return newNode", "import heapq\nfrom typing import List\n\ndef max_performance(n: int, k: int, speed: List[int], efficiency: List[int]) -> int:\n    engineers = sorted(zip(efficiency, speed), reverse=True)\n    min_heap = []\n    speed_sum = 0\n    max_performance = 0\n\n    for e, s in engineers:\n        speed_sum += s\n        heapq.heappush(min_heap, s)\n\n        if len(min_heap) > k:\n            speed_sum -= heapq.heappop(min_heap)\n\n        max_performance = max(max_performance, speed_sum * e)\n\n    return max_performance % (10**9 + 7)", "def findTheDistanceValue(arr1, arr2, d):\n    distance = 0\n    for a in arr1:\n        found = True\n        for b in arr2:\n            if abs(a - b) <= d:\n                found = False\n                break\n        if found:\n            distance += 1\n    return distance", "def shiftGrid(grid, k):\n    m, n = len(grid), len(grid[0])\n    k %= (m * n)\n    res = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            idx = (i * n + j + k) % (m * n)\n            res[idx // n][idx % n] = grid[i][j]\n    return res", "def maxSumDivThree(nums):\n    dp = [0, 0, 0]\n    for num in nums:\n        temp = dp[:]\n        for s in temp:\n            dp[(s + num) % 3] = max(dp[(s + num) % 3], s + num)\n    return dp[0]", "def sum_of_four_divisors(nums):\n    total_sum = 0\n    for num in nums:\n        count = 0\n        div_sum = 0\n        i = 1\n        while i * i <= num:\n            if num % i == 0:\n                count += 1 if i * i == num else 2\n                div_sum += i + (num // i)\n                if count > 4:\n                    break\n            i += 1\n        if count == 4:\n            total_sum += div_sum\n    return total_sum", "def hasValidPath(grid):\n    m, n = len(grid), len(grid[0])\n\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    allowed = [[], [0, 2], [1, 3], [0, 1], [0, 3], [1, 2], [1, 0]]\n\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(i, j):\n        if i == m - 1 and j == n - 1:\n            return True\n\n        visited[i][j] = True\n        for dir in allowed[grid[i][j]]:\n            x, y = i + directions[dir][0], j + directions[dir][1]\n            if 0 <= x < m and 0 <= y < n and not visited[x][y] and (dir + 2) % 4 in allowed[grid[x][y]]:\n                if dfs(x, y):\n                    return True\n        return False\n\n    return dfs(0, 0)", "def find_lucky(arr):\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    max_lucky = -1\n    for num, count in freq.items():\n        if num == count:\n            max_lucky = max(max_lucky, num)\n    return max_lucky", "def minTimeToVisitAllPoints(points: List[List[int]]) -> int:\n    time = 0\n    for i in range(1, len(points)):\n        dx = abs(points[i][0] - points[i-1][0])\n        dy = abs(points[i][1] - points[i-1][1])\n        time += max(dx, dy)\n    return time", "class UndergroundSystem:\n\n    def __init__(self):\n        self.check_in_info = dict()\n        self.journey_data = dict()\n\n    def check_in(self, id: int, station_name: str, t: int) -> None:\n        self.check_in_info[id] = (station_name, t)\n\n    def check_out(self, id: int, station_name: str, t: int) -> None:\n        start_station, start_time = self.check_in_info[id]\n        route = (start_station, station_name)\n        duration = t - start_time\n        if route not in self.journey_data:\n            self.journey_data[route] = (0, 0)\n        prev_duration, count = self.journey_data[route]\n        self.journey_data[route] = (prev_duration + duration, count + 1)\n\n    def get_average_time(self, start_station: str, end_station: str) -> float:\n        route = (start_station, end_station)\n        duration, count = self.journey_data[route]\n        return duration / count", "from bisect import bisect_left\n\ndef suggestedProducts(products, searchWord):\n    products.sort()\n    result = []\n    current_prefix = \"\"\n    \n    for letter in searchWord:\n        current_prefix += letter\n        index = bisect_left(products, current_prefix)\n        suggestions = []\n        \n        for i in range(3):\n            if index < len(products) and products[index].startswith(current_prefix):\n                suggestions.append(products[index])\n                index += 1\n            else:\n                break\n        \n        result.append(suggestions)\n    \n    return result", "def countLargestGroup(n: int) -> int:\n    groups = [0] * 37\n    largest_group_size = 0\n    count_largest_groups = 0\n\n    for i in range(1, n + 1):\n        sum_of_digits = sum(map(int, str(i)))\n        groups[sum_of_digits] += 1\n        if groups[sum_of_digits] > largest_group_size:\n            largest_group_size = groups[sum_of_digits]\n            count_largest_groups = 1\n        elif groups[sum_of_digits] == largest_group_size:\n            count_largest_groups += 1\n\n    return count_largest_groups", "def tictactoe(moves):\n    grid = [[0] * 3 for _ in range(3)]\n    player = 1\n    for move in moves:\n        r, c = move\n        grid[r][c] = player\n        if (all(grid[i][c] == player for i in range(3)) or\n            all(grid[r][i] == player for i in range(3)) or\n            (r == c and all(grid[i][i] == player for i in range(3))) or\n            (r + c == 2 and all(grid[i][2 - i] == player for i in range(3)))):\n            return 'A' if player == 1 else 'B'\n        player = 3 - player\n    \n    return 'Draw' if len(moves) == 9 else 'Pending'", "def checkOverlap(radius, xCenter, yCenter, x1, y1, x2, y2):\n    xClosest = max(x1, min(xCenter, x2))\n    yClosest = max(y1, min(yCenter, y2))\n    return (xCenter - xClosest) ** 2 + (yCenter - yClosest) ** 2 <= radius ** 2", "def countSquares(matrix: List[List[int]]) -> int:\n    m, n, ans = len(matrix), len(matrix[0]), 0\n    dp = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if i == 0 or j == 0:\n                dp[i][j] = matrix[i][j]\n            elif matrix[i][j]:\n                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n            ans += dp[i][j]\n    return ans", "def min_changes_to_divide_string(s, k):\n    n = len(s)\n    if n % k != 0:\n        return -1\n    chunk_count = n // k\n    res = 0\n    for i in range(k):\n        counts = [0] * 26\n        for j in range(i, n, k):\n            counts[ord(s[j]) - ord('a')] += 1\n        max_count = max(counts)\n        res += chunk_count - max_count\n    return res", "def num_steps(s: str) -> int:\n    steps = 0\n    carry = 0\n    \n    for c in reversed(s[1:]):\n        bit = int(c)\n        if bit and carry:\n            carry = 1\n            steps += 2\n        elif bit or carry:\n            carry ^= 1\n            steps += 2\n        else:\n            steps += 1\n            \n    return steps + carry", "import heapq\n\ndef longest_diverse_string(a: int, b: int, c: int) -> str:\n    result = \"\"\n    pq = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(pq)\n    \n    while pq:\n        first = heapq.heappop(pq)\n        if not result or result[-1] != first[1]:\n            result += first[1]\n            first = (first[0] + 1, first[1])\n            if first[0] < 0:\n                heapq.heappush(pq, first)\n        elif pq:\n            second = heapq.heappop(pq)\n            result += second[1]\n            second = (second[0] + 1, second[1])\n            if second[0] < 0:\n                heapq.heappush(pq, second)\n            if first[0] < 0:\n                heapq.heappush(pq, first)\n        else:\n            break\n            \n    return result", "def stoneGameIII(stoneValue):\n    n = len(stoneValue)\n    dp = [float(\"-inf\")] * (n + 1)\n    dp[n] = 0\n    \n    for i in range(n - 1, -1, -1):\n        curr = 0\n        for j in range(3):\n            if i + j < n:\n                curr += stoneValue[i + j]\n                dp[i] = max(dp[i], curr - dp[i + j + 1])\n                \n    return \"Tie \" if dp[0] == 0 else \"Alice \" if dp[0] > 0 else \"Bob \"", "import math\n\ndef smallest_divisor(nums, threshold):\n    left, right = 1, 10**6\n    while left < right:\n        mid = (left + right) // 2\n        total = sum(math.ceil(n / mid) for n in nums)\n        if total > threshold:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "from collections import deque\n\ndef minNumberOfFlips(mat):\n    m, n = len(mat), len(mat[0])\n    steps = 0\n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 0)]\n\n    def encode(i, j):\n        return i * n + j\n\n    while True:\n        flipped = 0\n        que = deque()\n\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1:\n                    que.append(encode(i, j))\n\n        while que:\n            cur = que.popleft()\n            cur_i, cur_j = divmod(cur, n)\n\n            for dx, dy in dirs:\n                ni, nj = cur_i + dx, cur_j + dy\n                if 0 <= ni < m and 0 <= nj < n:\n                    mat[ni][nj] ^= 1\n                    flipped += 1\n\n        if flipped == 0:\n            break\n        steps += flipped\n\n    for row in mat:\n        if any(cell == 1 for cell in row):\n            return -1\n\n    return steps", "def entity_parser(text: str) -> str:\n    entities = {\n        \"&quot;\": \"\\\"\",\n        \"&apos;\": \"'\",\n        \"&amp;\": \"&\",\n        \"&gt;\": \">\",\n        \"&lt;\": \"<\",\n        \"&frasl;\": \"/\",\n    }\n    \n    result = []\n    current_entity = []\n    in_entity = False\n    \n    for c in text:\n        if in_entity:\n            current_entity.append(c)\n            if c == ';':\n                entity = ''.join(current_entity)\n                if entity in entities:\n                    result.append(entities[entity])\n                else:\n                    result.extend(current_entity)\n                in_entity = False\n                current_entity.clear()\n        else:\n            if c == '&':\n                in_entity = True\n                current_entity.append(c)\n            else:\n                result.append(c)\n\n    return ''.join(result)", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef getDecimalValue(head: ListNode) -> int:\n    num = 0\n    while head:\n        num = (num << 1) | head.val\n        head = head.next\n    return num", "def maxSideLength(mat, threshold):\n    m, n = len(mat), len(mat[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    ans = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = mat[i - 1][j - 1] + dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1]\n            k = ans + 1\n            if i >= k and j >= k and dp[i][j] - dp[i][j - k] - dp[i - k][j] + dp[i - k][j - k] <= threshold:\n                ans += 1\n\n    return ans", "from collections import deque\n\ndef shortestPath(grid, k):\n    m, n = len(grid), len(grid[0])\n    queue = deque([(0, 0, 0, k)])\n    visited = [[[False] * (k + 1) for _ in range(n)] for _ in range(m)]\n\n    while queue:\n        x, y, step, remaining_k = queue.popleft()\n\n        if x == m - 1 and y == n - 1:\n            return step\n        if visited[x][y][remaining_k]:\n            continue\n        visited[x][y][remaining_k] = True\n\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n\n            if 0 <= nx < m and 0 <= ny < n:\n                if grid[nx][ny] == 1 and remaining_k > 0:\n                    queue.append((nx, ny, step + 1, remaining_k - 1))\n                elif grid[nx][ny] == 0:\n                    queue.append((nx, ny, step + 1, remaining_k))\n\n    return -1", "class Solution:\n    def generate_strings(self, n: int, current: str, strings: list) -> None:\n        if n == 0:\n            strings.append(current)\n            return\n        for c in \"abc\":\n            if not current or current[-1] != c:\n                self.generate_strings(n - 1, current + c, strings)\n\n    def getHappyString(self, n: int, k: int) -> str:\n        strings = []\n        self.generate_strings(n, \"\", strings)\n        return strings[k - 1] if k <= len(strings) else \"\"", "def numDecodings(s: str, k: int) -> int:\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    MOD = 1000000007\n\n    for i in range(n - 1, -1, -1):\n        num = 0\n        for j in range(i, n):\n            num = num * 10 + int(s[j])\n            if num >= 1 and num <= k:\n                dp[i] = (dp[i] + dp[j + 1]) % MOD\n            if num > k:\n                break\n\n    return dp[0]", "from collections import deque\n\ndef reformat(s: str) -> str:\n    letters, digits = deque(), deque()\n\n    for c in s:\n        if c.isalpha():\n            letters.append(c)\n        else:\n            digits.append(c)\n\n    if abs(len(letters) - len(digits)) > 1:\n        return \"\"\n\n    result = []\n    use_letter = len(letters) > len(digits)\n\n    while letters or digits:\n        if use_letter:\n            result.append(letters.popleft())\n        else:\n            result.append(digits.popleft())\n        use_letter = not use_letter\n\n    return ''.join(result)", "from collections import defaultdict\nfrom typing import List\n\ndef displayTable(orders: List[List[str]]) -> List[List[str]]:\n    tables = defaultdict(lambda: defaultdict(int))\n    foodSet = set()\n\n    for order in orders:\n        tableNumber = int(order[1])\n        foodItem = order[2]\n        tables[tableNumber][foodItem] += 1\n        foodSet.add(foodItem)\n\n    foodList = sorted(foodSet)\n    result = [[\"Table\"] + foodList]\n\n    for tableNumber, table in sorted(tables.items()):\n        row = [str(tableNumber)]\n        row.extend(str(table[foodItem]) for foodItem in foodList)\n        result.append(row)\n\n    return result", "def minNumberOfFrogs(croakOfFrogs: str) -> int:\n    counter = [0] * 5\n    frogs = max_frogs = 0\n    for ch in croakOfFrogs:\n        idx = 'croak'.index(ch)\n        counter[idx] += 1\n        if idx == 0:\n            max_frogs = max(max_frogs, frogs + 1)\n            frogs += 1\n        else:\n            counter[idx - 1] -= 1\n            if counter[idx - 1] < 0:\n                return -1\n            if idx == 4:\n                frogs -= 1\n    return max_frogs if all(count == counter[0] for count in counter) else -1", "def waysToBuildArray(n, m, k):\n    mod = 10**9 + 7\n    dp = [[0] * (k+1) for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(1, n+1):\n        for j in range(k+1):\n            for x in range(1, m+1):\n                if j < i * (x-1):\n                    dp[i][j] = (dp[i][j] + dp[i-1][j-(i-1)*(x-1)]) % mod\n    return dp[n][k]", "from collections import Counter\n\ndef is_possible_divide(nums: List[int], k: int) -> bool:\n    counts = Counter(nums)\n    \n    for key in sorted(counts):\n        if counts[key] > 0:\n            for i in range(k-1, -1, -1):\n                if counts[key+i] < counts[key]:\n                    return False\n                counts[key+i] -= counts[key]\n    \n    return True", "def max_substring_occurrences(s: str, k: int) -> int:\n    freq = {}\n    res = 0\n    for c in s:\n        freq[c] = freq.get(c, 0) + 1\n        if len(freq) <= k:\n            res = max(res, freq[c])\n    return 0 if len(freq) > k else res", "from collections import deque\n\ndef maxCandies(status, candies, keys, containedBoxes, initialBoxes):\n    max_candies = 0\n    visited = set()\n    to_process = deque(initialBoxes)\n\n    while to_process:\n        box = to_process.popleft()\n\n        if box in visited:\n            continue\n\n        visited.add(box)\n\n        if status[box]:\n            max_candies += candies[box]\n            for key in keys[box]:\n                status[key] = 1\n                if key in visited:\n                    to_process.append(key)\n            for contained in containedBoxes[box]:\n                to_process.append(contained)\n        else:\n            to_process.append(box)\n\n    return max_candies", "def maxSum(nums, k):\n    n = len(nums)\n    dp = [0] * (n + 1)\n    pq = []\n    sum_ = 0\n\n    for i in range(n):\n        if i >= k:\n            pq.remove(-(dp[i] - nums[i]))  # Remove element from pq\n        heapq.heappush(pq, -(dp[i] - nums[i]))  # Push in the negative for max heap\n        dp[i + 1] = max(dp[i], nums[i] - pq[0])\n        sum_ = max(sum_, dp[i + 1])\n\n    return sum_", "def sum_zero(n):\n    res = []\n    for i in range(1, (n // 2) + 1):\n        res.append(i)\n        res.append(-i)\n    if n % 2 != 0:\n        res.append(0)\n    return res", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef inorder(root):\n    output = []\n    stack = []\n    current = root\n\n    while current or stack:\n        while current:\n            stack.append(current)\n            current = current.left\n        current = stack.pop()\n        output.append(current.val)\n        current = current.right\n\n    return output\n\ndef getAllElements(root1, root2):\n    tree1 = inorder(root1)\n    tree2 = inorder(root2)\n    result = []\n    i, j = 0, 0\n\n    while i < len(tree1) or j < len(tree2):\n        if i < len(tree1) and (j >= len(tree2) or tree1[i] <= tree2[j]):\n            result.append(tree1[i])\n            i += 1\n        else:\n            result.append(tree2[j])\n            j += 1\n\n    return result", "def canReach(arr: List[int], start: int) -> bool:\n    if 0 <= start < len(arr) and arr[start] >= 0:\n        if arr[start] == 0:\n            return True\n        \n        jump = arr[start]\n        arr[start] = -arr[start]\n        return canReach(arr, start + jump) or canReach(arr, start - jump)\n    return False", "def is_solvable(words, result):\n    return sum(words.values()) % 10 == result % 10", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isValidSequence(root, arr, index=0):\n    if not root or index >= len(arr) or arr[index] != root.val:\n        return False\n    if not root.left and not root.right:\n        return index == len(arr) - 1\n    return isValidSequence(root.left, arr, index + 1) or isValidSequence(root.right, arr, index + 1)", "from collections import defaultdict\n\ndef find_ancestors(node, adj_list, visited, ans):\n    if visited[node]:\n        return\n    visited[node] = True\n    for ancestor in adj_list[node]:\n        ans.append(ancestor)\n        find_ancestors(ancestor, adj_list, visited, ans)\n\ndef find_ancestors_in_dag(n, edges):\n    adj_list = defaultdict(list)\n    for edge in edges:\n        adj_list[edge[1]].append(edge[0])\n    ans = []\n    for i in range(n):\n        visited = [False] * n\n        ancestors = []\n        find_ancestors(i, adj_list, visited, ancestors)\n        ans.append(sorted(ancestors))\n    return ans", "def max_diff(num):\n    a, b = -1, -1\n    num_str = str(num)\n    for c in num_str:\n        if a == -1 and c != '9':\n            a = int(c)\n        if b == -1 and c > '1':\n            b = int(c)\n        if a != -1 and b != -1:\n            break\n            \n    result = 0\n    for c in num_str:\n        if int(c) == a:\n            result = result * 10 + 9\n        elif int(c) == b:\n            result = result * 10 + (1 if c == num_str[0] else 0)\n        else:\n            result = result * 10 + int(c)\n    return result - num", "class Encrypter:\n    def __init__(self, keys, values, dictionary):\n        self.encrypt_map = dict(zip(keys, values))\n        self.decrypt_map = dict(zip(values, keys))\n        self.dictionary = set(dictionary)\n    \n    def encrypt(self, original):\n        result = []\n        for c in original:\n            if c not in self.encrypt_map:\n                return \"\"\n            result.append(self.encrypt_map[c])\n        return \"\".join(result)\n\n    def decrypt(self, encrypted):\n        result = []\n        for i in range(0, len(encrypted), 2):\n            temp = encrypted[i:i+2]\n            if temp not in self.decrypt_map:\n                return \"\"\n            result.append(self.decrypt_map[temp])\n        \n        decrypted = \"\".join(result)\n        if decrypted not in self.dictionary:\n            return \"\"\n        return decrypted", "def freqAlphabets(s):\n    result = []\n    i = 0\n    while i < len(s):\n        if i + 2 < len(s) and s[i + 2] == '#':\n            result.append(chr(ord('a') + int(s[i:i + 2]) - 1))\n            i += 3\n        else:\n            result.append(chr(ord('a') + int(s[i]) - 1))\n            i += 1\n    return ''.join(result)", "from collections import deque\nfrom collections import defaultdict\n\ndef watched_videos_by_friends(watched_videos, friends, id, level):\n    visited = set()\n    q = deque([(id, 0)])\n    video_freq = defaultdict(int)\n\n    while q:\n        current_id, current_level = q.popleft()\n\n        if current_level == level:\n            for video in watched_videos[current_id]:\n                video_freq[video] += 1\n        elif current_level < level:\n            for friend_id in friends[current_id]:\n                if friend_id not in visited:\n                    visited.add(friend_id)\n                    q.append((friend_id, current_level + 1))\n\n    result = sorted(video_freq.keys(), key=lambda x: (video_freq[x], x))\n\n    return result", "def min_steps_to_make_palindrome(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n - 2, -1, -1):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]", "from collections import deque\ndef longestSubarray(nums, limit):\n    max_deque = deque()\n    min_deque = deque()\n    left, right, longest = 0, 0, 0\n    \n    while right < len(nums):\n        while max_deque and nums[right] > max_deque[-1]: max_deque.pop()\n        while min_deque and nums[right] < min_deque[-1]: min_deque.pop()\n        \n        max_deque.append(nums[right])\n        min_deque.append(nums[right])\n        \n        while max_deque[0] - min_deque[0] > limit:\n            if max_deque[0] == nums[left]: max_deque.popleft()\n            if min_deque[0] == nums[left]: min_deque.popleft()\n            left += 1\n        \n        longest = max(longest, right - left + 1)\n        right += 1\n    \n    return longest", "import heapq\n\ndef kthSmallest(mat, k):\n    m, n = len(mat), len(mat[0])\n    minHeap = [(mat[0][0], 0, 0)]\n\n    visited = set([(0, 0)])\n    count = 0\n\n    while minHeap:\n        cur = heapq.heappop(minHeap)\n        sum, row, col = cur\n\n        count += 1\n        if count == k:\n            return sum\n\n        if row + 1 < m and (row + 1, col) not in visited:\n            visited.add((row + 1, col))\n            heapq.heappush(minHeap, (sum - mat[row][col] + mat[row + 1][col], row + 1, col))\n        \n        if col + 1 < n and (row, col + 1) not in visited:\n            visited.add((row, col + 1))\n            heapq.heappush(minHeap, (sum - mat[row][col] + mat[row][col + 1], row, col + 1))\n\n    return -1", "def build_array(target, n):\n    result = []\n    current = 1\n    for num in target:\n        while current < num:\n            result.append(\"Push \")\n            result.append(\"Pop \")\n            current += 1\n        result.append(\"Push \")\n        current += 1\n    return result", "def make_connected(n, connections):\n    adj_list = [[] for _ in range(n)]\n    visited = [False] * n\n    components = 0\n    extra_edges = 0\n\n    for a, b in connections:\n        adj_list[a].append(b)\n        adj_list[b].append(a)\n\n    for i in range(n):\n        if not visited[i]:\n            components += 1\n            stack = [i]\n\n            while stack:\n                current = stack.pop()\n\n                if not visited[current]:\n                    visited[current] = True\n\n                    for neighbor in adj_list[current]:\n                        if not visited[neighbor]:\n                            stack.append(neighbor)\n                        else:\n                            extra_edges += 1\n\n    extra_needed = components - 1\n\n    if extra_edges >= extra_needed:\n        return extra_needed\n\n    return -1", "def minimum_distance(word: str) -> int:\n    def dp(first: int, second: int, pos: int) -> int:\n        if pos == len(word): return 0\n        \n        ans = float('inf')\n        for i in [first, second]:\n            if i != -1:\n                dx = abs(ord(word[pos]) - ord(word[i])) % 6\n                dy = abs(ord(word[pos]) - ord(word[i])) // 6\n                ans = min(ans, min(dx, dy) * 2 + max(dx, dy))\n        ans += dp(first, second, pos + 1)\n\n        if first == -1 or second == -1:\n            ans = min(ans, dp(pos if first == -1 else first, ord(word[pos]), pos + 1))\n\n        return ans\n    \n    return dp(-1, -1, 0)", "def number_of_steps(num):\n    steps = 0\n    while num:\n        steps += 1 if num % 2 == 0 else 2\n        num >>= 1\n    return steps - 1", "def angleClock(hour: int, minutes: int) -> float:\n    minute_angle = 6 * minutes\n    hour_angle = 30 * hour + 0.5 * minutes\n    angle = abs(hour_angle - minute_angle)\n    return min(angle, 360 - angle)", "def minJumps(arr):\n    n = len(arr)\n    maxReach = arr[0]\n    step = arr[0]\n    jumps = 1\n\n    if n == 1:\n        return 0\n\n    for i in range(1, n):\n        if i == n - 1:\n            return jumps\n\n        maxReach = max(maxReach, i + arr[i])\n\n        step -= 1\n\n        if step == 0:\n            jumps += 1\n            step = maxReach - i\n\n    return -1", "def maximum69Number(num: int) -> int:\n    num_str = list(str(num))\n    for i, c in enumerate(num_str):\n        if c == '6':\n            num_str[i] = '9'\n            break\n    return int(''.join(num_str))", "def largestNumber(cost, target):\n    dp = [\"\" for _ in range(target + 1)]\n    dp[0] = \"\"\n\n    for i in range(9):\n        for j in range(cost[i], target + 1):\n            if dp[j - cost[i]] != None and len(dp[j - cost[i]]) < j - cost[i] \\\n               and (dp[j] == None or len(dp[j - cost[i]]) + 1 > len(dp[j])):\n                dp[j] = dp[j - cost[i]] + str(i + 1)\n\n    return dp[target] if dp[target] else \"0\"", "def removeLeafNodes(root, target):\n    if not root:\n        return None\n    root.left = removeLeafNodes(root.left, target)\n    root.right = removeLeafNodes(root.right, target)\n    if not root.left and not root.right and root.val == target:\n        return None\n    return root", "def min_taps(n, ranges):\n    intervals = [0] * (n + 1)\n    for i in range(n + 1):\n        left = max(0, i - ranges[i])\n        right = min(n, i + ranges[i])\n        intervals[left] = max(intervals[left], right - left)\n\n    position, total_taps, max_reach = 0, 0, 0\n    while position < n:\n        max_reach = max(max_reach, position + intervals[position])\n        if max_reach == position:\n            return -1\n        position = max_reach\n        total_taps += 1\n\n    return total_taps", "from typing import List\n\ndef peopleIndexes(favoriteCompanies: List[List[str]]) -> List[int]:\n    result = []\n    companySets = [set(companies) for companies in favoriteCompanies]\n\n    for i, companies in enumerate(companySets):\n        isSubset = False\n        for j, otherCompanies in enumerate(companySets):\n            if i != j and companies.issubset(otherCompanies):\n                isSubset = True\n                break\n        if not isSubset:\n            result.append(i)\n\n    return result", "def numPoints(darts, r):\n    n = len(darts)\n    result = 1\n    \n    for i in range(n):\n        for j in range(n):\n            cnt = 0\n            for k in range(n):\n                dx = darts[i][0] - darts[k][0]\n                dy = darts[i][1] - darts[k][1]\n                if (dx * dx + dy * dy) ** 0.5 <= r:\n                    cnt += 1\n                    \n            if cnt > result:\n                result = cnt\n                \n    return result", "def filter_restaurants(restaurants, vegan_friendly, max_price, max_distance):\n    def custom_compare(a, b):\n        if a[1] == b[1]:\n            return b[0] - a[0]\n        return b[1] - a[1]\n\n    filtered_restaurants = [\n        r for r in restaurants\n        if (vegan_friendly == 0 or r[2] == vegan_friendly) and r[3] <= max_price and r[4] <= max_distance\n    ]\n\n    filtered_restaurants.sort(key=lambda r: (r[1], r[0]), reverse=True)\n\n    return [r[0] for r in filtered_restaurants]", "def findTheCity(n, edges, distanceThreshold):\n    INF = float(\"inf\")\n    dist = [[INF] * n for _ in range(n)]\n\n    for i in range(n):\n        dist[i][i] = 0\n\n    for fr, to, w in edges:\n        dist[fr][to] = dist[to][fr] = w\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    res, minReachable = -1, n + 1\n    for i in range(n):\n        cnt = sum(1 for d in dist[i] if d <= distanceThreshold)\n        if cnt <= minReachable:\n            minReachable = cnt\n            res = i\n\n    return res", "def minDifficulty(jobDifficulty, d):\n    n = len(jobDifficulty)\n    if n < d: return -1\n    dp = [[float(\"inf\")] * n for _ in range(d)]\n\n    dp[0][0] = jobDifficulty[0]\n    for i in range(1, n):\n        dp[0][i] = max(dp[0][i-1], jobDifficulty[i])\n\n    for i in range(1, d):\n        for j in range(i, n):\n            maxD = jobDifficulty[j]\n            for k in range(j, i - 1, -1):\n                maxD = max(maxD, jobDifficulty[k])\n                dp[i][j] = min(dp[i][j], dp[i-1][k-1] + maxD)\n\n    return dp[d-1][n-1]", "def sortByBits(arr):\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))", "def numberOfSubstrings(s: str) -> int:\n    res, i, count = 0, 0, [0, 0, 0]\n    \n    for j, ch in enumerate(s):\n        count[ord(ch) - ord('a')] += 1\n        \n        while count[0] > 0 and count[1] > 0 and count[2] > 0:\n            count[ord(s[i]) - ord('a')] -= 1\n            i += 1\n            \n        res += i\n    \n    return res", "def countOrders(n: int) -> int:\n    MOD = 10**9 + 7\n    ans = 1\n    for i in range(1, n + 1):\n        ans = ans * (2 * i - 1) * i % MOD\n    return ans", "def checkIfPrerequisite(numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n    adj_matrix = [[False] * numCourses for _ in range(numCourses)]\n    for pre in prerequisites:\n        adj_matrix[pre[0]][pre[1]] = True\n\n    for k in range(numCourses):\n        for i in range(numCourses):\n            for j in range(numCourses):\n                adj_matrix[i][j] = adj_matrix[i][j] or (adj_matrix[i][k] and adj_matrix[k][j])\n\n    return [adj_matrix[query[0]][query[1]] for query in queries]", "from typing import List\nimport heapq\n\ndef kWeakestRows(mat: List[List[int]], k: int) -> List[int]:\n    soldier_rows = [(row.count(1), i) for i, row in enumerate(mat)]\n    heapq.heapify(soldier_rows)\n    return [heapq.heappop(soldier_rows)[1] for _ in range(k)]", "from collections import Counter\n\ndef minSetSize(arr):\n    count = Counter(arr)\n    freq = list(count.values())\n    freq.sort(reverse=True)\n\n    removed, setSize = 0, 0\n    for f in freq:\n        removed += f\n        setSize += 1\n        if removed * 2 >= len(arr):\n            return setSize\n\n    return 0", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def maxProduct(self, root: TreeNode) -> int:\n        def dfs(node):\n            if not node:\n                return 0\n            return node.val + dfs(node.left) + dfs(node.right)\n\n        def dfs2(node, half):\n            nonlocal result\n\n            if not node:\n                return 0\n            cur_sum = node.val + dfs2(node.left, half) + dfs2(node.right, half)\n            result = max(result, (total - cur_sum) * cur_sum)\n            return cur_sum\n\n        total = dfs(root)\n        result = 0\n        dfs2(root, total / 2)\n        return result % (10**9 + 7)", "def maxJumps(arr, d):\n    n = len(arr)\n    dp = [1] * n\n\n    def helper(idx):\n        if dp[idx] > 1:\n            return dp[idx]\n        maximum = 1\n        for i in range(1, d + 1):\n            if idx + i < n and arr[idx] <= arr[idx + i]:\n                break\n            if idx + i < n:\n                maximum = max(maximum, 1 + helper(idx + i))\n\n            if idx - i >= 0 and arr[idx] <= arr[idx - i]:\n                break\n            if idx - i >= 0:\n                maximum = max(maximum, 1 + helper(idx - i))\n        \n        dp[idx] = maximum\n        return maximum\n\n    for i in range(n):\n        helper(i)\n\n    return max(dp)", "from math import factorial\n\ndef count_combinations(balls, combinations, curr_ball):\n    total_combinations = 1\n    for i in range(curr_ball):\n        total_combinations *= factorial(balls[i] + combinations[i]) / (factorial(balls[i]) * factorial(combinations[i]))\n\n    return total_combinations\n\ndef dfs(balls, combinations, curr_ball):\n    if curr_ball == len(balls):\n        if combinations[-1] == combinations[0]:\n            return count_combinations(balls, combinations, curr_ball)\n        else:\n            return 0\n\n    result = 0\n    for i in range(balls[curr_ball] + 1):\n        combinations.append(i)\n        result += dfs(balls, combinations, curr_ball + 1)\n        combinations.pop()\n\n    return result\n\ndef get_probability(balls):\n    sum_balls = sum(balls)\n\n    total_combinations = 1\n    for ball in balls:\n        total_combinations *= factorial(ball)\n\n    combinations = []\n    return dfs(balls, combinations, 0) / total_combinations", "def min_steps(s, t):\n    count_s = [0] * 26\n    count_t = [0] * 26\n    steps = 0\n    \n    for c in s:\n        count_s[ord(c) - ord('a')] += 1\n    for c in t:\n        count_t[ord(c) - ord('a')] += 1\n    \n    for i in range(26):\n        steps += abs(count_s[i] - count_t[i])\n    \n    return steps // 2", "from collections import defaultdict\nfrom typing import List\n\nclass TweetCounts:\n\n    def __init__(self):\n        self.tweet_records = defaultdict(lambda: defaultdict(int))\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.tweet_records[tweetName][time] += 1\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        if freq == \"minute\":\n            interval = 60\n        elif freq == \"hour\":\n            interval = 3600\n        else:\n            interval = 86400\n\n        result = [0] * ((endTime - startTime) // interval + 1)\n        for time, count in self.tweet_records[tweetName].items():\n            if startTime <= time <= endTime:\n                result[(time - startTime) // interval] += count\n\n        return result", "def maxStudents(seats):\n    m, n = len(seats), len(seats[0])\n    valid_rows = [0] * m\n    max_valid = (1 << n) - 1\n    for i in range(m):\n        state = 0\n        for j in range(n):\n            state |= (seats[i][j] == '.') << j\n        valid_rows[i] = state\n\n    memo = [[-1] * (1 << n) for _ in range(m)]\n    return dfs(0, 0, valid_rows, m, n, max_valid, memo)\n\ndef dfs(row_index, prev_state, valid_rows, m, n, max_valid, memo):\n    if row_index == m:\n        return 0\n\n    if memo[row_index][prev_state] != -1:\n        return memo[row_index][prev_state]\n\n    max_students = 0\n    for cur_state in range(max_valid + 1):\n        if (cur_state & valid_rows[row_index]) != cur_state:\n            continue\n        if cur_state & (cur_state << 1):\n            continue\n        if cur_state & (prev_state << 1) or prev_state & (cur_state << 1):\n            continue\n\n        max_students = max(max_students, dfs(row_index + 1, cur_state, valid_rows, m, n, max_valid, memo) + bin(cur_state).count('1'))\n\n    memo[row_index][prev_state] = max_students\n    return max_students", "from collections import OrderedDict\n\ndef sortString(s: str) -> str:\n    freq_map = OrderedDict(sorted({c: s.count(c) for c in set(s)}.items()))\n    result = []\n\n    while freq_map:\n        for key in list(freq_map.keys()):\n            result.append(key)\n            freq_map[key] -= 1\n\n            if freq_map[key] == 0:\n                del freq_map[key]\n\n        for key in list(reversed(freq_map.keys())):\n            result.append(key)\n            freq_map[key] -= 1\n\n            if freq_map[key] == 0:\n                del freq_map[key]\n\n    return \"\".join(result)", "def findTheLongestSubstring(s: str) -> int:\n    pos = {-1: 0}\n    ans = cur = 0\n    for i, c in enumerate(s):\n        cur ^= 1 << (\"aeiou\".find(c) + 1) >> 1\n        if cur not in pos:\n            pos[cur] = i + 1\n        ans = max(ans, i + 1 - pos[cur])\n    return ans", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef longestZigZag(root: TreeNode) -> int:\n    maxLen = [0]\n    \n    def longestZigZagUtil(root, left):\n        if not root:\n            return -1\n\n        leftZig = longestZigZagUtil(root.left, True)\n        rightZig = longestZigZagUtil(root.right, False)\n\n        maxLen[0] = max(maxLen[0], max(leftZig, rightZig) + 1)\n        return rightZig + 1 if left else leftZig + 1\n\n    longestZigZagUtil(root, True)\n    longestZigZagUtil(root, False)\n    return maxLen[0]", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef maxSumBST(root):\n    def helper(node):\n        if not node:\n            return float('inf'), float('-inf'), 0, True\n\n        left_min, left_max, left_sum, is_left_bst = helper(node.left)\n        right_min, right_max, right_sum, is_right_bst = helper(node.right)\n\n        if is_left_bst and is_right_bst and node.val > left_max and node.val < right_min:\n            sum_ = node.val + left_sum + right_sum\n            max_sum[0] = max(max_sum[0], sum_)\n            return min(node.val, left_min), max(node.val, right_max), sum_, True\n\n        return 0, 0, 0, False\n\n    max_sum = [0]\n    helper(root)\n    return max_sum[0]", "def countNegatives(grid):\n    m, n, count, i, j = len(grid), len(grid[0]), 0, 0, len(grid[0]) - 1\n    while i < m and j >= 0:\n        if grid[i][j] < 0:\n            count += j + 1\n            i += 1\n        else:\n            j -= 1\n    return count", "class ProductOfNumbers:\n    def __init__(self):\n        self.products = [1]\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.products = [1]\n        else:\n            self.products.append(self.products[-1] * num)\n\n    def getProduct(self, k: int) -> int:\n        if k >= len(self.products):\n            return 0\n        else:\n            return self.products[-1] // self.products[-k - 1]", "def max_events(events):\n    events.sort(key=lambda x: x[1])\n\n    count = 0\n    last_day = -1\n\n    for event in events:\n        if event[0] > last_day:\n            count += 1\n            last_day = event[1]\n\n    return count", "def runningSum(nums):\n    for i in range(1, len(nums)):\n        nums[i] += nums[i - 1]\n    return nums", "from collections import Counter\nimport heapq\n\ndef findLeastNumOfUniqueInts(arr, k):\n    count = Counter(arr)\n    pq = list(count.values())\n    heapq.heapify(pq)\n    while k > 0:\n        k -= heapq.heappop(pq)\n    return len(pq) if k == 0 else len(pq) + 1", "def smallerNumbersThanCurrent(nums):\n    result = [0] * len(nums)\n    for i in range(len(nums)):\n        for j in range(len(nums)):\n            if nums[j] < nums[i]:\n                result[i] += 1\n    return result", "def rank_teams(votes):\n    teams = len(votes[0])\n    ranks = [[0] * teams for _ in range(26)]\n\n    for vote in votes:\n        for i in range(teams):\n            ranks[ord(vote[i]) - ord('A')][i] += 1\n\n    result = list(votes[0])\n    result.sort(key=lambda ch: tuple([-ranks[ord(ch) - ord('A')][i] for i in range(teams)] + [ch]))\n    return ''.join(result)", "from collections import deque\n\ndef minCost(grid):\n    def dfs(r, c, d):\n        if 0 <= r < m and 0 <= c < n and d < cost[r][c]:\n            cost[r][c] = d\n            q.append((r, c))\n\n    m, n = len(grid), len(grid[0])\n    cost = [[1e6] * n for _ in range(m)]\n\n    q = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    dfs(0, 0, 0)\n\n    while q:\n        r, c = q.popleft()\n        for i, (dr, dc) in enumerate(directions):\n            dfs(r + dr, c + dc, cost[r][c] + (grid[r][c] != i + 1))\n\n    return cost[-1][-1]", "def findTheDistanceValue(arr1, arr2, d):\n    count = 0\n    for i in arr1:\n        valid = True\n        for j in arr2:\n            if abs(i - j) <= d:\n                valid = False\n                break\n        if valid:\n            count += 1\n    return count", "def maxNumberOfFamilies(n, reservedSeats):\n    rows = {}\n    for seat in reservedSeats:\n        rows[seat[0]] = rows.get(seat[0], 0) | (1 << (seat[1] - 1))\n    \n    max_groups = (n - len(rows)) * 2\n    for row_mask in rows.values():\n        seats = ~(row_mask | (row_mask >> 1) | (row_mask >> 2) | (row_mask >> 3)) & 0x3FF\n        max_groups += (seats & (seats >> 1) & (seats >> 2) & (seats >> 3)) != 0\n        \n    return max_groups", "def get_power(x):\n    steps = 0\n    while x != 1:\n        if x % 2 == 0:\n            x //= 2\n        else:\n            x = 3 * x + 1\n        steps += 1\n    return steps\n\ndef sort_by_power(lo, hi, k):\n    nums = [(get_power(i), i) for i in range(lo, hi + 1)]\n    nums.sort()\n    return nums[k - 1][1]", "def max_size_slices(slices):\n    def max_sum(slices, start, end, n, memo):\n        if n == 0:\n            return 0\n        if end - start + 1 < n * 2:\n            return float('-inf')\n        if memo[start][n] != -1:\n            return memo[start][n]\n\n        pick = max_sum(slices, start + 2, end, n - 1, memo) + slices[start]\n        not_pick = max_sum(slices, start + 1, end, n, memo)\n\n        memo[start][n] = max(pick, not_pick)\n        return memo[start][n]\n\n    n = len(slices) // 3\n    memo1 = [[-1] * (n + 1) for _ in range(len(slices))]\n    memo2 = [[-1] * (n + 1) for _ in range(len(slices))]\n\n    return max(max_sum(slices, 0, len(slices) - 1, n, memo1),\n               max_sum(slices, 1, len(slices), n, memo2))", "def generate_the_string(n: int) -> str:\n    if n % 2 == 0:\n        return 'a' * (n - 1) + 'b'\n    else:\n        return 'a' * n", "def count_prefix_aligned(flips):\n    count = 0\n    for i in range(len(flips)):\n        if flips[i] == i + 1:\n            count += 1\n    return count", "from collections import deque\n\ndef numOfMinutes(n, headID, manager, informTime):\n    subordinates = {i: [] for i in range(n)}\n    for i in range(n):\n        if manager[i] != -1:\n            subordinates[manager[i]].append(i)\n\n    queue = deque([(headID, 0)])\n    totalTime = 0\n\n    while queue:\n        current, time = queue.popleft()\n        totalTime = max(totalTime, time)\n        for sub in subordinates[current]:\n            queue.append((sub, time + informTime[current]))\n\n    return totalTime", "from collections import defaultdict\n\ndef frogPosition(n, edges, t, target):\n    graph = defaultdict(list)\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n    return dfs(1, -1, t, target, graph)\n\ndef dfs(node, parent, t, target, graph):\n    if t == 0:\n        return 1.0 if node == target else 0.0\n    probability = 0.0\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            probability += dfs(neighbor, node, t - 1, target, graph)\n    return probability / (len(graph[node]) - (0 if parent == -1 else 1))", "from collections import deque\n\ndef minNumberOfSemesters(n, relations, k):\n    indegree = [0] * (n + 1)\n    graph = [[] for _ in range(n + 1)]\n\n    for prev_course, next_course in relations:\n        graph[prev_course].append(next_course)\n        indegree[next_course] += 1\n\n    semesters = 0\n    while n > 0:\n        zero_indegree = deque()\n        for i in range(1, len(indegree)):\n            if indegree[i] == 0:\n                zero_indegree.append(i)\n                indegree[i] = -1\n\n        courses = 0\n        while zero_indegree and courses < k:\n            curr_course = zero_indegree.popleft()\n            n -= 1\n\n            for next_course in graph[curr_course]:\n                indegree[next_course] -= 1\n            courses += 1\n        semesters += 1\n    return semesters", "def lucky_numbers(matrix):\n    m, n = len(matrix), len(matrix[0])\n    lucky_numbers = []\n\n    for i in range(m):\n        min_row = min(matrix[i])\n        min_row_idx = matrix[i].index(min_row)\n        is_lucky = all(matrix[k][min_row_idx] <= min_row for k in range(m))\n\n        if is_lucky:\n            lucky_numbers.append(min_row)\n\n    return lucky_numbers", "def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\n    if original is None:\n        return None\n    if original is target:\n        return cloned\n\n    left = self.getTargetCopy(original.left, cloned.left, target)\n    return left if left else self.getTargetCopy(original.right, cloned.right, target)", "import heapq\n\ndef max_performance(n, k, speed, efficiency):\n    engineers = sorted(zip(efficiency, speed), reverse=True)\n\n    result = 0\n    sum_speed = 0\n    min_heap = []\n    for e, s in engineers:\n        if len(min_heap) >= k:\n            sum_speed -= heapq.heappop(min_heap)\n\n        heapq.heappush(min_heap, s)\n        sum_speed += s\n        result = max(result, e * sum_speed)\n\n    return result % (10**9 + 7)", "def countLargestGroup(n: int) -> int:\n    freq = [0] * 37\n    max_group_size = 0\n    max_group_count = 0\n    \n    for i in range(1, n + 1):\n        _sum = sum(map(int, str(i)))\n        freq[_sum] += 1\n        max_group_size = max(max_group_size, freq[_sum])\n    \n    for count in freq:\n        if count == max_group_size:\n            max_group_count += 1\n\n    return max_group_count", "def can_construct(s, k):\n    char_counts = [0] * 26\n\n    for c in s:\n        char_counts[ord(c) - ord('a')] += 1\n\n    odd_count = sum(count % 2 for count in char_counts)\n\n    return odd_count <= k <= len(s)", "def max_satisfaction(satisfaction):\n    satisfaction.sort(reverse=True)\n    ans = total = sum = 0\n    for i in satisfaction:\n        total += i\n        if total > 0:\n            sum += total\n            ans = max(ans, sum)\n    return ans", "def numSubmat(mat: List[List[int]]) -> int:\n    m, n = len(mat), len(mat[0])\n    dp = [[0] * n for _ in range(m)]\n    ans = 0\n    \n    for i in range(m):\n        for j in range(n):\n            if mat[i][j]:\n                dp[i][j] = 1 if j == 0 else dp[i][j-1] + 1\n                width = dp[i][j]\n                for k in range(i, -1, -1):\n                    width = min(width, dp[k][j])\n                    ans += width\n    \n    return ans", "def createTargetArray(nums, index):\n    target = []\n    for i in range(len(nums)):\n        target.insert(index[i], nums[i])\n    return target", "class Solution:\n    def findRoot(self, nodes: List['Node']) -> 'Node':\n        value_sum = 0\n        \n        for node in nodes:\n            value_sum += node.val\n            \n            for child in node.children:\n                value_sum -= child.val\n        \n        for node in nodes:\n            if node.val == value_sum:\n                return node\n                \n        return None", "def hasValidPath(grid):\n    m, n = len(grid), len(grid[0])\n    visited = [[False for _ in range(n)] for _ in range(m)]\n\n    return dfs(grid, 0, 0, m, n, visited)\n\ndef dfs(grid, x, y, m, n, visited):\n    if x < 0 or y < 0 or x >= m or y >= n or visited[x][y]:\n        return False\n    if x == m - 1 and y == n - 1:\n        return True\n    \n    visited[x][y] = True\n\n    next_x = [-1, 0, 1, 0]\n    next_y = [0, 1, 0, -1]\n\n    for i in range(4):\n        dx = x + next_x[i]\n        dy = y + next_y[i]\n\n        if dfs(grid, dx, dy, m, n, visited):\n            return True\n\n    return False", "def longestHappyPrefix(s):\n    n = len(s)\n    lps = [0] * n\n    length = 0\n    i = 1\n    while i < n:\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        elif length != 0:\n            length = lps[length - 1]\n        else:\n            lps[i] = 0\n            i += 1\n    return s[:lps[-1]]", "def minDifference(nums):\n    n = len(nums)\n    if n <= 4: return 0\n    nums.sort()\n    res = float('inf')\n    for i in range(4):\n        res = min(res, nums[n - 4 + i] - nums[i])\n    return res", "def find_lucky(arr):\n    freq = {}\n\n    for n in arr:\n        if n in freq:\n            freq[n] += 1\n        else:\n            freq[n] = 1\n\n    lucky = -1\n    for key, value in freq.items():\n        if key == value:\n            lucky = max(lucky, key)\n\n    return lucky", "class UndergroundSystem:\n    def __init__(self):\n        self.check_in_data = {}\n        self.travel_data = {}\n\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\n        self.check_in_data[id] = (stationName, t)\n\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\n        start_station, start_time = self.check_in_data[id]\n        route = (start_station, stationName)\n        if route not in self.travel_data:\n            self.travel_data[route] = [0, 0]\n        self.travel_data[route][0] += t - start_time\n        self.travel_data[route][1] += 1\n\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\n        route = (startStation, endStation)\n        total_time, num_trips = self.travel_data[route]\n        return total_time / num_trips", "MOD = 10**9 + 7\n\ndef countGoodStrings(s1, s2, evil):\n    n = len(s1)\n    m = len(evil)\n    dp = [[0] * m for _ in range(n + 1)]\n\n    # Preprocess the KMP prefix function for the evil string\n    lps = [0] * m\n    len_ = 0\n    i = 1\n    while i < m:\n        if evil[i] == evil[len_]:\n            len_ += 1\n            lps[i] = len_\n            i += 1\n        elif len_:\n            len_ = lps[len_ - 1]\n        else:\n            i += 1\n\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(m):\n            for k in range(2):\n                for c in range(ord('a'), ord(s2[i] if k else 'z') + 1):\n                    e = j\n                    while e and (chr(c) != evil[e]):\n                        e = lps[e - 1]\n\n                    if chr(c) != evil[e]:\n                        e += 1\n\n                    if e != m:\n                        dp[i + 1][k | (c < ord(s2[i]))] += dp[i][k]\n                        dp[i + 1][k | (c < ord(s2[i]))] %= MOD\n\n    return (dp[n][1] - dp[n][0] + MOD) % MOD", "def min_start_value(nums):\n    min_sum, sum = 0, 0\n    for num in nums:\n        sum += num\n        min_sum = min(min_sum, sum)\n    return 1 - min_sum", "def find_min_fibonacci_numbers(k):\n    if k == 0:\n        return 0\n    a, b = 0, 1\n    while b <= k:\n        a, b = b, a + b\n    return 1 + find_min_fibonacci_numbers(k - a)", "def get_happy_string(n, k):\n    def dfs(s, prev):\n        if len(s) == n:\n            happy_strings.append(s)\n            return\n        for c in 'abc':\n            if c != prev:\n                dfs(s + c, c)\n\n    happy_strings = []\n    dfs(\"\", ' ')\n    return happy_strings[k - 1] if k <= len(happy_strings) else \"\"", "def numWaterBottles(numBottles: int, numExchange: int) -> int:\n    totalBottles = numBottles\n    while numBottles >= numExchange:\n        newBottles = numBottles // numExchange\n        totalBottles += newBottles\n        numBottles = newBottles + numBottles % numExchange\n    return totalBottles", "def min_subsequence(nums):\n    nums.sort(reverse=True)\n    total_sum, current_sum = sum(nums), 0\n    result = []\n    for num in nums:\n        current_sum += num\n        result.append(num)\n        if current_sum > total_sum - current_sum:\n            break\n    return result", "def num_steps(s: str) -> int:\n    steps = 0\n    carry = 0\n\n    for i in range(len(s) - 1, 0, -1):\n        current = int(s[i]) + carry\n        if current == 1:\n            steps += 2\n            carry = 1\n        else:\n            steps += carry\n            carry = current\n\n    return steps + carry", "def closestToTarget(arr: List[int], target: int) -> int:\n    min_diff = float('inf')\n    prefix = set()\n\n    for n in arr:\n        next_prefix = set()\n        for p in prefix:\n            next_prefix.add(p & n)\n        next_prefix.add(n)\n\n        for p in next_prefix:\n            min_diff = min(min_diff, abs(p - target))\n        prefix = next_prefix\n    return min_diff", "def stoneGameIII(stoneValue):\n    n = len(stoneValue)\n    dp = [0] * (n + 1)\n    dp[n - 1] = stoneValue[n - 1]\n    for i in range(n - 2, -1, -1):\n        dp[i] = stoneValue[i] - dp[i + 1]\n        for j in range(1, 3):\n            if i + j < n:\n                dp[i] = max(dp[i], stoneValue[i + j] - dp[i + j + 1])\n    if dp[0] > 0: return \"Alice\"\n    if dp[0] < 0: return \"Bob\"\n    return \"Tie\"", "def count_odds(low, high):\n    return (high - low) // 2 + (1 if low % 2 == 1 or high % 2 == 1 else 0)", "def stringMatching(words):\n    result = []\n    for word1 in words:\n        for word2 in words:\n            if word1 != word2 and word1 in word2:\n                result.append(word1)\n                break\n    return result", "def process_queries(queries, m):\n    nums = list(range(1, m+1))\n    result = []\n    for q in queries:\n        pos = nums.index(q)\n        result.append(pos)\n        del nums[pos]\n        nums.insert(0, q)\n    return result", "def entityParser(text: str) -> str:\n    entities = {\n        \"&quot;\": '\\\"',\n        \"&apos;\": '\\'',\n        \"&amp;\": '&',\n        \"&gt;\": '>',\n        \"&lt;\": '<',\n        \"&frasl;\": '/'\n    }\n\n    result, i = [], 0\n    while i < len(text):\n        if text[i] == '&':\n            temp = ''\n            for j in range(i, min(i+7, len(text))):\n                temp += text[j]\n                if temp in entities:\n                    result.append(entities[temp])\n                    i = j\n                    break\n            else:\n                result.append(text[i])\n        else:\n            result.append(text[i])\n        i += 1\n    return ''.join(result)", "from typing import List\n\ndef kids_with_candies(candies: List[int], extra_candies: int) -> List[bool]:\n    max_candies = max(candies)\n    result = [candy + extra_candies >= max_candies for candy in candies]\n    return result", "def max_difference(num):\n    a = num + 9 - (num % 10)\n    b = num - (num // 1000 % 10) * 111\n\n    return a - b", "def check_if_can_break(s1, s2):\n    s1 = sorted(s1)\n    s2 = sorted(s2)\n\n    can_break_1 = can_break_2 = True\n    for c1, c2 in zip(s1, s2):\n        if c1 < c2:\n            can_break_1 = False\n        if c2 < c1:\n            can_break_2 = False\n\n    return can_break_1 or can_break_2", "def number_ways(hats):\n    kMod = 1000000007\n    kMaxHats = 40\n\n    num_people = len(hats)\n    people_with_hat = [[] for _ in range(kMaxHats)]\n\n    for i in range(num_people):\n        for hat in hats[i]:\n            people_with_hat[hat - 1].append(i)\n\n    dp = [[0] * (kMaxHats + 1) for _ in range(1 << num_people)]\n    dp[0][0] = 1\n\n    for hat in range(kMaxHats):\n        for mask in reversed(range(1 << num_people)):\n            dp[mask][hat + 1] = (dp[mask][hat + 1] + dp[mask][hat]) % kMod\n            for person in people_with_hat[hat]:\n                if mask & (1 << person) == 0:\n                    dp[mask | (1 << person)][hat + 1] = (dp[mask | (1 << person)][hat + 1] + dp[mask][hat]) % kMod\n\n    return dp[(1 << num_people) - 1][kMaxHats]", "from collections import defaultdict\nfrom typing import List\n\ndef displayTable(orders: List[List[str]]) -> List[List[str]]:\n    foodItems = set()\n    tableOrders = defaultdict(lambda: defaultdict(int))\n\n    for order in orders:\n        foodItems.add(order[2])\n        tableOrders[int(order[1])][order[2]] += 1\n\n    foodItems = sorted(foodItems)\n    header = [\"Table\"] + foodItems\n    result = [header]\n\n    for tableNumber, foodOrder in sorted(tableOrders.items()):\n        row = [str(tableNumber)] + [str(foodOrder[food]) for food in foodItems]\n        result.append(row)\n\n    return result", "def minNumberOfFrogs(croakOfFrogs: str) -> int:\n    counts = [0] * 5\n    max_frogs = 0\n\n    for c in croakOfFrogs:\n        index = \"croak\".find(c)\n        if index == 0:\n            counts[0] += 1\n            max_frogs = max(max_frogs, counts[0])\n        elif counts[index - 1] > 0:\n            counts[index - 1] -= 1\n            counts[index] += 1\n        else:\n            return -1\n\n    if counts[0] == counts[4]:\n        return max_frogs\n    else:\n        return -1", "def number_of_ways(n, m, k, mod=1_000_000_007):\n    if k > 1:\n        result = 1\n        for _ in range(n):\n            result = (result * m) % mod\n        return result\n    return 1 if n % 2 == 0 else m", "def minSwaps(grid):\n    n = len(grid)\n    steps = 0\n\n    for i in range(n):\n        row = -1\n        for j in range(i, n):\n            if grid[j][i] == 0:\n                row = j\n                break\n        if row == -1:\n            return -1\n\n        while row > i:\n            grid[row], grid[row - 1] = grid[row - 1], grid[row]\n            steps += 1\n            row -= 1\n\n    return steps", "def maxScore(s):\n    left_zeros, right_ones, max_score = 0, s.count('1'), 0\n    for i in range(len(s) - 1):\n        if s[i] == '0': left_zeros += 1\n        else: right_ones -= 1\n        max_score = max(max_score, left_zeros + right_ones)\n    return max_score", "def maxScore(cardPoints, k):\n    n = len(cardPoints)\n    total = sum(cardPoints[:k])\n\n    max_score = total\n    for i in range(k - 1, -1, -1):\n        j = n - k + i\n        total += cardPoints[j] - cardPoints[i]\n        max_score = max(max_score, total)\n\n    return max_score", "def find_diagonal_order(nums):\n    diagonals = {}\n    for i in range(len(nums)):\n        for j in range(len(nums[i])):\n            if i + j not in diagonals:\n                diagonals[i + j] = []\n            diagonals[i + j].append(nums[i][j])\n\n    res = []\n    for key in diagonals:\n        res.extend(reversed(diagonals[key]))\n\n    return res", "def canConvertString(s: str, t: str, k: int) -> bool:\n    if len(s) != len(t):\n        return False\n    count = [0] * 26\n    for i in range(len(s)):\n        diff = (ord(t[i]) - ord(s[i]) + 26) % 26\n        if diff > 0:\n            count[diff] += 1\n    for i in range(1, 26):\n        if count[i] > 0:\n            if count[i] * 26 - 26 + i > k:\n                return False\n    return True", "def minInsertions(s: str) -> int:\n    left = 0\n    res = 0\n    n = len(s)\n    i = 0\n    while i < n:\n        if s[i] == '(':\n            left += 1\n        else:\n            if left == 0: \n                res += 1\n            else: \n                left -= 1\n            if i == n - 1 or s[i + 1] != ')':\n                res += 1\n                i += 1\n        i += 1\n    return res + left * 2", "def max_power(s: str) -> int:\n    max_power = current_power = 1\n\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            current_power += 1\n        else:\n            max_power = max(max_power, current_power)\n            current_power = 1\n\n    return max(max_power, current_power)", "def goodNodes(root, maxVal=float('-inf')):\n    if not root:\n        return 0\n    result = 0\n    if root.val >= maxVal:\n        result = 1\n        maxVal = root.val\n    return result + goodNodes(root.left, maxVal) + goodNodes(root.right, maxVal)", "def largestNumber(cost, target):\n    dp = [\"\" for _ in range(target + 1)]\n    dp[0] = \"\"\n    \n    for t in range(1, target + 1):\n        for i in range(1, 10):\n            if t >= cost[i - 1] and dp[t - cost[i - 1]]:\n                temp = dp[t - cost[i - 1]] + str(i)\n                if len(dp[t]) <= len(temp):\n                    dp[t] = temp\n\n    return dp[target] if dp[target] else \"0\"", "def maxNonOverlapping(nums, target):\n    prefix_sum = {0: 0}\n    sum, count = 0, 0\n    for num in nums:\n        sum += num\n        if sum - target in prefix_sum:\n            count = max(count, 1 + prefix_sum[sum - target])\n        prefix_sum[sum] = count\n    return count", "def destCity(paths):\n    starting_cities = set()\n    \n    for path in paths:\n        starting_cities.add(path[0])\n\n    for path in paths:\n        if path[1] not in starting_cities:\n            return path[1]\n\n    return \"\"", "def kLengthApart(nums, k):\n    last_one = -1\n    for i, num in enumerate(nums):\n        if num == 1:\n            if last_one != -1 and i - last_one <= k:\n                return False\n            last_one = i\n    return True", "import heapq\n\ndef kthSmallest(mat, k):\n    m, n = len(mat), len(mat[0])\n    \n    minHeap = [(mat[0][0], 0, 0)]\n    visited = [[False for _ in range(n)] for _ in range(m)]\n    visited[0][0] = True\n    \n    for _ in range(k):\n        res, i, j = heapq.heappop(minHeap)\n        \n        if i < m - 1 and not visited[i+1][j]:\n            heapq.heappush(minHeap, (res - mat[i][j] + mat[i + 1][j], i + 1, j))\n            visited[i+1][j] = True\n        if j < n - 1 and not visited[i][j+1]:\n            heapq.heappush(minHeap, (res - mat[i][j] + mat[i][j + 1], i, j + 1))\n            visited[i][j+1] = True\n            \n    return res", "def min_operations(n):\n    return n * n // 4", "def build_array(target, n):\n    result = []\n    current = 1\n    for num in target:\n        while current < num:\n            result.append(\"Push\")\n            result.append(\"Pop\")\n            current += 1\n        result.append(\"Push\")\n        current += 1\n    return result", "def countTriplets(arr):\n    n = len(arr)\n    XOR = [0] * (n + 1)\n    \n    for i in range(n):\n        XOR[i+1] = XOR[i] ^ arr[i]\n    \n    count = 0\n    for i in range(n):\n        for k in range(i+1, n):\n            if XOR[i] == XOR[k+1]:\n                count += k-i\n    return count", "def minTime(n, edges, hasApple):\n    graph = {i: {} for i in range(n)}\n\n    for a, b in edges:\n        graph[a][b] = 0\n        graph[b][a] = 0\n\n    def dfs(v, parent):\n        ans = 0\n        for u in graph[v]:\n            if u == parent:\n                continue\n            ans += dfs(u, v) * 2\n        return ans + int(hasApple[v] or ans > 0)\n\n    return dfs(0, -1)", "def can_be_equal(target, arr):\n    target.sort()\n    arr.sort()\n    return target == arr", "def has_all_codes(s, k):\n    need = 1 << k\n    got = set()\n    \n    for i in range(len(s) - k + 1):\n        got.add(s[i:i + k])\n    \n    return len(got) == need", "from collections import defaultdict\n\ndef DFS(src, graph, visited, transitive_closure, dest):\n    if src == dest:\n        transitive_closure[dest] = True\n        return\n    if visited[src]:\n        return\n    visited[src] = True\n    for neighbor in graph[src]:\n        DFS(neighbor, graph, visited, transitive_closure, dest)\n        if transitive_closure[dest]:\n            return\n\ndef checkIfPrerequisite(numCourses, prerequisites, queries):\n    graph = defaultdict(list)\n\n    for pre in prerequisites:\n        graph[pre[0]].append(pre[1])\n\n    result = []\n\n    for i in range(len(queries)):\n        visited = [False] * numCourses\n        transitive_closure = [False] * numCourses\n        DFS(queries[i][0], graph, visited, transitive_closure, queries[i][1])\n        result.append(transitive_closure[queries[i][1]])\n\n    return result", "def cherry_pickup(grid):\n    rows, cols = len(grid), len(grid[0])\n    dp = [[[0] * cols for _ in range(cols)] for _ in range(rows)]\n\n    for row in reversed(range(rows)):\n        for col1 in range(cols):\n            for col2 in range(cols):\n                current_cell = dp[row + 1][col1][col2] if row < rows - 1 else 0\n                current_cell += grid[row][col1] + (grid[row][col2] if col1 != col2 else 0)\n\n                max_val = 0\n                for move1 in range(-1, 2):\n                    for move2 in range(-1, 2):\n                        new_col1, new_col2 = col1 + move1, col2 + move2\n                        if 0 <= new_col1 < cols and 0 <= new_col2 < cols:\n                            max_val = max(max_val, dp[row][new_col1][new_col2])\n\n                dp[row][col1][col2] = current_cell + max_val\n\n    return dp[0][0][cols - 1]", "def busy_student(start_time, end_time, query_time):\n    count = 0\n    for i in range(len(start_time)):\n        if start_time[i] <= query_time <= end_time[i]:\n            count += 1\n    return count", "def arrangeWords(text: str) -> str:\n    words = text.split()\n    words[0] = words[0].lower()\n    words.sort(key=len)\n    words[0] = words[0].capitalize()\n    return ' '.join(words)", "from typing import List\n\ndef peopleIndexes(favoriteCompanies: List[List[str]]) -> List[int]:\n    result = []\n    for i in range(len(favoriteCompanies)):\n        is_subset = False\n        for j in range(len(favoriteCompanies)):\n            if i != j and set(favoriteCompanies[i]).issubset(favoriteCompanies[j]):\n                is_subset = True\n                break\n        if not is_subset:\n            result.append(i)\n    return result", "from math import acos, cos, sin, sqrt\n\ndef max_number_of_darts(darts, r):\n    n = len(darts)\n    max_darts = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = sqrt((darts[j][0] - darts[i][0])**2 + (darts[j][1] - darts[i][1])**2)\n            if dist > 2.0 * r: continue\n\n            angle = acos(dist / (2.0 * r))\n            for k in range(2):\n                loc_angle = angle * (1 if k == 0 else -1)\n                cx = darts[i][0] + r * (darts[j][0] - darts[i][0]) / dist * cos(loc_angle) - r * (darts[j][1] - darts[i][1]) / dist * sin(loc_angle)\n                cy = darts[i][1] + r * (darts[j][0] - darts[i][0]) / dist * sin(loc_angle) + r * (darts[j][1] - darts[i][1]) / dist * cos(loc_angle)\n\n                cnt = 0\n                for l in range(n):\n                    new_dist = sqrt((darts[l][0] - cx)**2 + (darts[l][1] - cy)**2)\n                    if new_dist <= r + 1e-5: cnt += 1\n\n                max_darts = max(max_darts, cnt)\n\n    return max_darts", "def maxBoxesInWarehouse(boxes, warehouse):\n    n = len(warehouse)\n    for i in range(1, n):\n        warehouse[i] = min(warehouse[i], warehouse[i - 1])\n    boxes.sort(reverse=True)\n    boxIndex = 0\n    boxesCount = 0\n    for i in range(n):\n        if boxIndex < len(boxes) and boxes[boxIndex] <= warehouse[i]:\n            boxesCount += 1\n            boxIndex += 1\n    return boxesCount", "def is_prefix_of_word(sentence: str, search_word: str) -> int:\n    words = sentence.split(' ')\n    for index, word in enumerate(words, start=1):\n        if word.startswith(search_word):\n            return index\n    return -1", "def max_vowels(s, k):\n    max_count = count = 0\n    for i, c in enumerate(s):\n        count += int(c in 'aeiou')\n        if i >= k:\n            count -= int(s[i - k] in 'aeiou')\n        max_count = max(max_count, count)\n    return max_count", "def pseudoPalindromicPaths(root, cnt = 0):\n    if not root:\n        return 0\n    cnt ^= 1 << (root.val - 1)\n    if not root.left and not root.right:\n        return (cnt & (cnt - 1)) == 0\n    return pseudoPalindromicPaths(root.left, cnt) + pseudoPalindromicPaths(root.right, cnt)", "def maxDotProduct(nums1, nums2):\n    n, m = len(nums1), len(nums2)\n    dp = [[float('-inf') for _ in range(m + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1], nums1[i - 1] * nums2[j - 1])\n    return dp[n][m]", "def final_prices(prices):\n    for i in range(len(prices)):\n        for j in range(i + 1, len(prices)):\n            if prices[j] <= prices[i]:\n                prices[i] -= prices[j]\n                break\n    return prices", "class SubrectangleQueries:\n    def __init__(self, rectangle: List[List[int]]):\n        self.rectangle = rectangle\n\n    def updateSubrectangle(self, row1: int, col1: int, row2: int, col2: int, newValue: int) -> None:\n        for i in range(row1, row2 + 1):\n            for j in range(col1, col2 + 1):\n                self.rectangle[i][j] = newValue\n\n    def getValue(self, row: int, col: int) -> int:\n        return self.rectangle[row][col]", "def min_sum_of_lengths(arr, target):\n    n = len(arr)\n    sum_, min_len, result = 0, float('inf'), float('inf')\n    mp = {0: -1}\n\n    for i in range(n):\n        sum_ += arr[i]\n        if sum_ >= target and (sum_ - target) in mp:\n            if mp[sum_ - target] > -1 and min_len != float('inf'):\n                result = min(result, i - mp[sum_ - target] + min_len)\n            min_len = min(min_len, i - mp[sum_ - target])\n        mp[sum_] = i\n\n    return result if result != float('inf') else -1", "def findLengthOfShortestSubarray(arr):\n    n = len(arr)\n    left, right = 0, n - 1\n    while left < n - 1 and arr[left] <= arr[left + 1]:\n        left += 1\n    if left == n - 1:\n        return 0\n    while right > 0 and arr[right] >= arr[right - 1]:\n        right -= 1\n    result = min(n - left - 1, right)\n    i, j = 0, right\n    while i <= left and j < n:\n        if arr[i] <= arr[j]:\n            result = min(result, j - i - 1)\n            i += 1\n        else:\n            j += 1\n    return result", "def maxArea(h, w, horizontalCuts, verticalCuts):\n    horizontalCuts.sort()\n    verticalCuts.sort()\n\n    maxH = max(horizontalCuts[0], h - horizontalCuts[-1])\n    maxV = max(verticalCuts[0], w - verticalCuts[-1])\n\n    for i in range(1, len(horizontalCuts)):\n        maxH = max(maxH, horizontalCuts[i] - horizontalCuts[i - 1])\n\n    for i in range(1, len(verticalCuts)):\n        maxV = max(maxV, verticalCuts[i] - verticalCuts[i - 1])\n\n    return (maxH * maxV) % (10**9 + 7)", "from collections import defaultdict\n\ndef dfs(node, parent, graph, count):\n    if node != 0 and parent == 0:\n        count[0] += 1\n\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, graph, count)\n\ndef minReorder(n, connections):\n    graph = defaultdict(list)\n    for a, b in connections:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    count = [0]\n    dfs(0, -1, graph, count)\n    return count[0]", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        pre_sum = [0]\n        dp = [[[0]*62 for _ in range(10)] for _ in range(35)]\n        k = len(balls)\n\n        for b in balls:\n            pre_sum.append(pre_sum[-1] + b)\n\n        dp[0][0][0] = 1\n        for i in range(k):\n            for j in reversed(range(i + 1)):\n                for x in reversed(range(pre_sum[i+1] + 1)):\n                    for y in reversed(range(0, pre_sum[i+1] - x + 1)):\n                        if x + y <= balls[i]:\n                            for d in range(max(0, balls[i] - 2 * y), x + 1):\n                                tmp = 1\n                                for z in range(1, d + 1):\n                                    tmp *= (x + y + 1 - z) / z\n                                for z in range(1, y + 1):\n                                    tmp *= (x + y + d + 1 - z) / z\n                                for z in range(1, balls[i] - y - y - d + 1):\n                                    tmp *= (x + y + d + 1 - z) / z\n                                dp[i+1][j+1][x + d] += dp[i][j][x] * tmp\n                                dp[i+1][j][x + d] += dp[i][j][x] * tmp\n\n        sum_ = sum(balls)\n        return (dp[k][k >> 1][sum_ >> 1] - (1e-5 > dp[k][k >> 1][sum_ >> 1])) / (1 if sum_ % 2 else (1 << (sum_ >> 1)))", "def minTime(colors: str, neededTime: List[int]) -> int:\n    res, prev = 0, -1\n    for i in range(len(colors) - 1):\n        if colors[i] == colors[i + 1]:\n            if prev == -1 or neededTime[i] < neededTime[prev]:\n                prev = i\n            if neededTime[i + 1] < neededTime[prev]:\n                prev = i + 1\n            res += neededTime[prev]\n            neededTime[prev] = 1000000\n            prev = -1\n    return res", "class UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.components = size\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def unite(self, x, y):\n        root_x, root_y = self.find(x), self.find(y)\n        if root_x != root_y:\n            self.parent[root_x] = root_y\n            self.components -= 1\n            return True\n        return False\n\ndef max_num_edges_to_remove(n, edges):\n    ufA, ufB = UnionFind(n + 1), UnionFind(n + 1)\n    common_edges = 0\n\n    for t, u, v in edges:\n        if t == 3:\n            if ufA.unite(u, v):\n                ufB.unite(u, v)\n                common_edges += 1\n\n    removed_edges = 0\n    for t, u, v in edges:\n        uf = ufA if t == 1 else ufB if t == 2 else None\n        if uf and not uf.unite(u, v):\n            removed_edges += 1\n\n    return -1 if ufA.components != 2 or ufB.components != 2 else removed_edges - common_edges", "def shuffle(nums, n):\n    shuffled = []\n    for i in range(n):\n        shuffled.append(nums[i])\n        shuffled.append(nums[i+n])\n    return shuffled", "class BrowserHistory:\n\n    def __init__(self, homepage: str):\n        self.history = [homepage]\n        self.current_index = 0\n\n    def visit(self, url: str):\n        self.history = self.history[:self.current_index + 1]\n        self.history.append(url)\n        self.current_index += 1\n\n    def back(self, steps: int) -> str:\n        self.current_index -= min(steps, self.current_index)\n        return self.history[self.current_index]\n\n    def forward(self, steps:int) -> str:\n        self.current_index += min(steps, len(self.history) - 1 - self.current_index)\n        return self.history[self.current_index]", "def minCost(houses, cost, m, n, target):\n    dp = [[[float('inf')] * (target + 1) for _ in range(n)] for _ in range(m)]\n\n    if houses[0] != 0:\n        dp[0][houses[0] - 1][1] = 0\n    else:\n        for j in range(n):\n            dp[0][j][1] = cost[0][j]\n\n    for i in range(1, m):\n        for j in range(n):\n            for k in range(1, target + 1):\n                if houses[i] != 0 and houses[i] != j + 1:\n                    continue\n                paint_cost = 0 if houses[i] != 0 else cost[i][j]\n\n                for l in range(n):\n                    if l == j:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][l][k] + paint_cost)\n                    else:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][l][k - 1] + paint_cost)\n\n    ans = min(dp[m - 1][j][target] for j in range(n))\n    return -1 if ans == float('inf') else ans", "def average(salary):\n    min_salary = min(salary)\n    max_salary = max(salary)\n    sum_salaries = sum(salary)\n    sum_salaries -= (min_salary + max_salary)\n    return sum_salaries / (len(salary) - 2)", "def kth_factor(n: int, k: int) -> int:\n    for i in range(1, n+1):\n        if n % i == 0:\n            k -= 1\n            if k == 0:\n                return i\n    return -1", "def findMaxLength(nums):\n    max_length, zeroes, ones = 0, 0, 0\n    count_map = {0: -1}\n\n    for i, num in enumerate(nums):\n        if num == 0:\n            zeroes += 1\n        else:\n            ones += 1\n\n        if zeroes - ones not in count_map:\n            count_map[zeroes - ones] = i\n        else:\n            max_length = max(max_length, i - count_map[zeroes - ones])\n\n    return max_length", "def sumOddLengthSubarrays(arr):\n    sum = 0\n    n = len(arr)\n    for i in range(n):\n        oddSubarrays = ((i + 1) * (n - i) + 1) // 2\n        sum += arr[i] * oddSubarrays\n    return sum", "def maxSumRangeQuery(nums, requests):\n    n = len(nums)\n    count = [0] * n\n    for request in requests:\n        count[request[0]] += 1\n        if request[1] + 1 < n:\n            count[request[1] + 1] -= 1\n    for i in range(1, n):\n        count[i] += count[i - 1]\n\n    nums.sort()\n    count.sort()\n\n    ans = 0\n    for i in range(n):\n        ans = (ans + nums[i] * count[i]) % 1000000007\n    return ans", "def minSubarray(nums, p):\n    n, res, need, cur = len(nums), len(nums), 0, 0\n    for num in nums:\n        need = (need + num) % p\n    if need == 0:\n        return 0\n    last_seen = {0: -1}\n    for i, num in enumerate(nums):\n        cur = (cur + num) % p\n        last_seen[cur] = i\n        res = min(res, i - last_seen.get((cur - need + p) % p, -n))\n    return res if res < n else -1", "def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n    color_bounds = {}\n    m, n = len(targetGrid), len(targetGrid[0])\n\n    for i in range(m):\n        for j in range(n):\n            color = targetGrid[i][j]\n            if color not in color_bounds:\n                color_bounds[color] = [i, j, i, j]\n            else:\n                color_bounds[color][0] = min(color_bounds[color][0], i)\n                color_bounds[color][1] = min(color_bounds[color][1], j)\n                color_bounds[color][2] = max(color_bounds[color][2], i)\n                color_bounds[color][3] = max(color_bounds[color][3], j)\n\n    remaining_colors = set(color_bounds.keys())\n    while remaining_colors:\n        progress = False\n        to_remove = set()\n        for color in remaining_colors:\n            bounds = color_bounds[color]\n            contained = all(targetGrid[i][j] == color or targetGrid[i][j] == -1\n                        for i in range(bounds[0], bounds[2] + 1)\n                        for j in range(bounds[1], bounds[3] + 1))\n            if contained:\n                for i in range(bounds[0], bounds[2] + 1):\n                    for j in range(bounds[1], bounds[3] + 1):\n                        targetGrid[i][j] = -1\n                to_remove.add(color)\n                progress = True\n\n        remaining_colors -= to_remove\n        if not progress:\n            return False\n\n    return True", "def reorderSpaces(text):\n    spaces = text.count(' ')\n    words = text.split()\n    num_words = len(words)\n    \n    if num_words == 1:\n        spaces_between_words = 0\n    else:\n        spaces_between_words = spaces // (num_words - 1)\n    \n    extra_spaces = spaces - spaces_between_words * (num_words - 1)\n\n    return (' ' * spaces_between_words).join(words) + ' ' * extra_spaces", "def maxUniqueSplit(s, start=0, seen=None):\n    if seen is None:\n        seen = set()\n    if start == len(s):\n        return 0\n    maxUnique = -1\n    for i in range(start + 1, len(s) + 1):\n        sub = s[start:i]\n        if sub not in seen:\n            seen.add(sub)\n            unique = maxUniqueSplit(s, i, seen)\n            if unique != -1:\n                maxUnique = max(maxUnique, unique + 1)\n            seen.remove(sub)\n    return maxUnique", "def maxProductPath(self, grid: List[List[int]]) -> int:\n    m, n, mod = len(grid), len(grid[0]), 10**9 + 7\n    dp = [[[0, 0] for _ in range(n)] for _ in range(m)]\n    dp[0][0] = [grid[0][0], grid[0][0]]\n    for i in range(1, m):\n        dp[i][0] = [grid[i][0] * dp[i - 1][0][0], grid[i][0] * dp[i - 1][0][0]]\n    for j in range(1, n):\n        dp[0][j] = [grid[0][j] * dp[0][j - 1][0], grid[0][j] * dp[0][j - 1][0]]\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] < 0:\n                dp[i][j][0] = min(grid[i][j] * dp[i - 1][j][1], grid[i][j] * dp[i][j - 1][1])\n                dp[i][j][1] = max(grid[i][j] * dp[i - 1][j][0], grid[i][j] * dp[i][j - 1][0])\n            else:\n                dp[i][j][0] = min(grid[i][j] * dp[i - 1][j][0], grid[i][j] * dp[i][j - 1][0])\n                dp[i][j][1] = max(grid[i][j] * dp[i - 1][j][1], grid[i][j] * dp[i][j - 1][1])\n    return -1 if dp[-1][-1][1] < 0 else dp[-1][-1][1] % mod", "def connectTwoGroups(cost):\n    size1, size2 = len(cost), len(cost[0])\n    min_cost = [float('inf')] * size2\n\n    for i in range(size1):\n        for j in range(size2):\n            min_cost[j] = min(min_cost[j], cost[i][j])\n\n    total_cost = 0\n    for i in range(size1):\n        total_cost += min(cost[i])\n\n    for j in range(size2):\n        total_cost += min_cost[j]\n\n    return total_cost", "class Solution:\n    def expTree(self, s: str) -> 'Node':\n        def precedence(a, b):\n            if a == '(':\n                return False\n            if b == '(' or b == ')':\n                return True\n            if (a in {'*', '/'}) and (b in {'+', '-'}):\n                return True\n            return False\n        \n        def process(nodes, ops):\n            right = nodes.pop()\n            left = nodes.pop()\n            oper = Node(ops.pop())\n            oper.left = left\n            oper.right = right\n            nodes.append(oper)\n            \n        nodes = []\n        ops = []\n        for i in s:\n            if i.isdigit():\n                nodes.append(Node(i))\n            elif i == '(':\n                ops.append(i)\n            elif i == ')':\n                while ops[-1] != '(':\n                    process(nodes, ops)\n                ops.pop()\n            else:\n                while ops and precedence(ops[-1], i):\n                    process(nodes, ops)\n                ops.append(i)\n        while ops:\n            process(nodes, ops)\n        return nodes[0]", "def minOperations(logs):\n    depth = 0\n    for log in logs:\n        if log == \"../\":\n            depth = max(0, depth - 1)\n        elif log != \"./\":\n            depth += 1\n    return depth", "def minOperationsMaxProfit(customers, boardingCost, runningCost):\n    waiting = 0\n    profit = 0\n    max_profit = 0\n    rotations = 0\n    result = -1\n\n    for i in range(len(customers) + sum(customers)):\n        if i < len(customers):\n            waiting += customers[i]\n        boarding = min(waiting, 4)\n        waiting -= boarding\n        profit += boarding * boardingCost - runningCost\n\n        if profit > max_profit:\n            max_profit = profit\n            result = rotations + 1\n        rotations += 1\n    \n    return result", "class ThroneInheritance:\n\n    def __init__(self, kingName: str):\n        self.king = kingName\n        self.family = {}\n        self.dead = set()\n\n    def birth(self, parentName: str, childName: str) -> None:\n        if parentName not in self.family:\n            self.family[parentName] = []\n        self.family[parentName].append(childName)\n\n    def death(self, name: str) -> None:\n        self.dead.add(name)\n\n    def getInheritanceOrder(self) -> List[str]:\n        order = []\n        self.dfs(self.king, order)\n        return order\n\n    def dfs(self, name: str, order: List[str]) -> None:\n        if name not in self.dead:\n            order.append(name)\n        if name in self.family:\n            for child in self.family[name]:\n                self.dfs(child, order)", "def maximumRequests(n, requests):\n    req_size = len(requests)\n    max_requests = 0\n\n    for i in range(1 << req_size):\n        net_transfers = [0] * n\n        count = 0\n        \n        for j in range(req_size):\n            if i & (1 << j):\n                net_transfers[requests[j][0]] -= 1\n                net_transfers[requests[j][1]] += 1\n                count += 1\n\n        valid = all(val == 0 for val in net_transfers)\n\n        if valid:\n            max_requests = max(max_requests, count)\n\n    return max_requests", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef find_nearest_right_node(root, u):\n    if not root:\n        return None\n    \n    q = [root]\n    \n    while q:\n        n = len(q)\n        \n        for i in range(n):\n            current = q.pop(0)\n            \n            if current == u:\n                return q[0] if i < n - 1 else None\n            \n            if current.left:\n                q.append(current.left)\n            if current.right:\n                q.append(current.right)\n    \n    return None", "def runningSum(nums):\n    for i in range(1, len(nums)):\n        nums[i] += nums[i - 1]\n    return nums", "import heapq\nfrom collections import Counter\n\ndef find_least_num_of_unique_ints(arr, k):\n    freq_map = Counter(arr)\n    min_heap = list(freq_map.values())\n    heapq.heapify(min_heap)\n\n    while k > 0:\n        k -= heapq.heappop(min_heap)\n\n    return len(min_heap) if k == 0 else len(min_heap) + 1", "def minDays(bloomDay, m, k):\n    left, right = min(bloomDay), max(bloomDay)\n\n    while left < right:\n        mid = left + (right - left) // 2\n        bouquets = flowers = 0\n        for day in bloomDay:\n            if day > mid:\n                flowers = 0\n            else:\n                flowers += 1\n                if flowers == k:\n                    bouquets += 1\n                    flowers = 0\n\n        if bouquets >= m:\n            right = mid\n        else:\n            left = mid + 1\n\n    return -1 if m == 0 else left", "def busiestServers(k, arrival, load):\n    server_status = [-1] * k\n    server_request_count = [0] * k\n\n    for i in range(len(arrival)):\n        index = i % k\n        for _ in range(k):\n            if server_status[index] <= arrival[i]:\n                server_status[index] = arrival[i] + load[i]\n                server_request_count[index] += 1\n                break\n            index = (index + 1) % k\n\n    max_requests = max(server_request_count)\n    return [i for i in range(k) if server_request_count[i] == max_requests]", "def specialArray(nums):\n    max_val = max(nums)\n    for x in range(1, max_val + 1):\n        count = sum([1 for num in nums if num >= x])\n        if count == x:\n            return x\n    return -1", "from collections import deque\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef is_even_odd_tree(root):\n    if not root:\n        return False\n    \n    q = deque([root])\n    level = 0\n    \n    while q:\n        size = len(q)\n        prev_val = 0 if level % 2 == 0 else 10**6 + 1\n        \n        for _ in range(size):\n            curr = q.popleft()\n            \n            if ((level % 2 == 0 and (curr.val % 2 == 0 or curr.val <= prev_val)) or \n                (level % 2 != 0 and (curr.val % 2 != 0 or curr.val >= prev_val))):\n                return False\n            \n            prev_val = curr.val\n            \n            if curr.left:\n                q.append(curr.left)\n            if curr.right:\n                q.append(curr.right)\n        \n        level += 1\n    \n    return True", "def xor_operation(n, start):\n    xor_result = 0\n    for i in range(n):\n        xor_result ^= (start + 2 * i)\n    return xor_result", "def get_folder_names(names):\n    name_count = {}\n    ans = []\n\n    for name in names:\n        if name not in name_count:\n            ans.append(name)\n            name_count[name] = 1\n        else:\n            k = name_count[name]\n            new_name = f\"{name}({k})\"\n            while new_name in name_count:\n                k += 1\n                new_name = f\"{name}({k})\"\n            ans.append(new_name)\n            name_count[new_name] = 1\n            name_count[name] = k + 1\n\n    return ans", "from sortedcontainers import SortedSet\n\ndef avoidFlood(rains: List[int]) -> List[int]:\n    res = [-1] * len(rains)\n    filled_lakes = {}\n    dry_days = SortedSet()\n\n    for i, lake in enumerate(rains):\n        if lake == 0:\n            dry_days.add(i)\n        else:\n            if lake in filled_lakes:\n                day = dry_days.ceiling(filled_lakes[lake])\n                if day is None:\n                    return []\n                res[day] = lake\n                dry_days.remove(day)\n            filled_lakes[lake] = i\n\n    for day in dry_days:\n        res[day] = 1\n\n    return res", "def maxDepth(s: str) -> int:\n    depth = 0\n    max_depth = 0\n\n    for c in s:\n        if c == '(':\n            depth += 1\n            max_depth = max(depth, max_depth)\n        elif c == ')':\n            depth -= 1\n\n    return max_depth", "def range_sum(nums, n, left, right):\n    MOD = 10**9 + 7\n    sums = []\n    for i in range(n):\n        sum = 0\n        for j in range(i, n):\n            sum += nums[j]\n            sums.append(sum)\n    sums.sort()\n    result = 0\n    for i in range(left-1, right):\n        result = (result + sums[i]) % MOD\n    return result", "def min_difference(nums):\n    size = len(nums)\n    if size < 5:\n        return 0\n\n    nums.sort()\n\n    return min(nums[-1] - nums[3], nums[-2] - nums[2], nums[-3] - nums[1], nums[-4] - nums[0])", "def winnerSquareGame(n: int) -> bool:\n    dp = [False] * (n + 1)\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            if not dp[i - j * j]:\n                dp[i] = True\n                break\n            j += 1\n    return dp[n]", "def max_font_size(text: str, w: int, h: int, fonts: List[int], font_info) -> int:\n    left, right, ans = 0, len(fonts) - 1, -1\n    while left <= right:\n        mid = left + (right - left) // 2\n        font_size = fonts[mid]\n        width, height = sum(font_info.getWidth(font_size, ch) for ch in text), font_info.getHeight(font_size)\n        if width <= w and height <= h:\n            ans = font_size\n            left = mid + 1\n        else:\n            right = mid - 1\n    return ans", "def is_path_crossing(path: str) -> bool:\n    visited = {(0, 0)}\n    x, y = 0, 0\n    for dir in path:\n        if dir == 'N': y += 1\n        elif dir == 'S': y -= 1\n        elif dir == 'E': x += 1\n        elif dir == 'W': x -= 1\n        if (x, y) in visited: return True\n        visited.add((x, y))\n    return False", "def canArrange(arr, k):\n    counts = [0] * k\n    for num in arr:\n        counts[(num % k + k) % k] += 1\n    if counts[0] % 2 != 0:\n        return False\n    for i in range(1, k // 2 + 1):\n        if counts[i] != counts[k - i]:\n            return False\n    return True", "def numSubseq(nums, target):\n    nums.sort()\n    n = len(nums)\n    mod = 10**9 + 7\n\n    power = [1] * n\n    for i in range(1, n):\n        power[i] = (power[i - 1] * 2) % mod\n\n    ans = 0\n    r = n\n    for l in range(n):\n        while r > l and nums[l] + nums[r - 1] > target:\n            r -= 1\n\n        ans = (ans + power[r - l]) % mod\n\n    return ans", "from collections import deque\n\ndef findMaxValueOfEquation(points, k):\n    res = -float(\"inf\")\n    q = deque()\n   \n    for p in points:\n        while q and p[0] - q[0][1] > k:\n            q.popleft()\n        \n        if q:\n            res = max(res, p[1] + p[0] + q[0][0])\n        \n        while q and p[1] - p[0] >= q[-1][0]:\n            q.pop()\n        \n        q.append((p[1] - p[0], p[0]))\n    \n    return res", "def maxLengthBetweenEqualCharacters(s: str) -> int:\n    result = -1\n    char_map = {}\n\n    for i, c in enumerate(s):\n        if c not in char_map:\n            char_map[c] = i\n        else:\n            result = max(result, i - char_map[c] - 1)\n\n    return result", "def findLexSmallestString(s: str, a: int, b: int) -> str:\n    def add_odd(s: str, a: int) -> str:\n        return ''.join([str((int(ch) + a) % 10) if idx % 2 else ch for idx, ch in enumerate(s)])\n\n    def rotate(s: str, k: int) -> str:\n        k %= len(s)\n        return s[-k:] + s[:-k]\n\n    smallest = s\n    for _ in range(len(s)):\n        for _ in range(10):\n            rotated = rotate(s, b)\n            temp = add_odd(rotated, a)\n            smallest = min(smallest, temp)\n            s = rotated\n        s = add_odd(s, a)\n    return smallest", "def can_make_arithmetic_progression(arr):\n    arr.sort()\n    difference = arr[1] - arr[0]\n    for i in range(2, len(arr)):\n        if arr[i] - arr[i - 1] != difference:\n            return False\n    return True", "def lastMoment(n, left, right):\n    max_left = max(left, default=0)\n    min_right = min(right, default=n)\n\n    return max(max_left, n - min_right)", "def numSubmat(mat):\n    m, n = len(mat), len(mat[0])\n    dp = [[0] * n for _ in range(m)]\n    count = 0\n\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 1:\n                dp[i][j] = (1 if j == 0 else dp[i][j - 1] + 1)\n                minWidth = dp[i][j]\n                for k in range(i, -1, -1):\n                    minWidth = min(minWidth, dp[k][j])\n                    count += minWidth\n\n    return count", "def minInteger(num: str, k: int) -> str:\n    if k == 0:\n        return num\n    num = list(num)\n    n = len(num)\n    for i in range(n):\n        idx = i\n        for j in range(i + 1, n):\n            if j - i > k:\n                break\n            if num[j] < num[idx]:\n                idx = j\n        min_digit = num[idx]\n        for j in range(idx, i, -1):\n            num[j] = num[j - 1]\n        num[i] = min_digit\n        k -= idx - i\n    return ''.join(num)", "def count_odds(low, high):\n    return (high + 1) // 2 - low // 2", "def numOfSubarrays(arr):\n    odd, even, sum_, result = 0, 1, 0, 0\n    mod = 10**9 + 7\n    for x in arr:\n        sum_ = (sum_ + x) % 2\n        if sum_ % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n        result = (result + odd) % mod\n    return result", "def numSplits(s: str) -> int:\n    left_set, right_set = set(), set()\n    left, right = [0] * len(s), [0] * len(s)\n    count = 0\n\n    for i, char in enumerate(s):\n        left_set.add(char)\n        left[i] = len(left_set)\n\n    for i in range(len(s) - 1, 0, -1):\n        right_set.add(s[i])\n        right[i] = len(right_set)\n\n    for i in range(len(s) - 1):\n        if left[i] == right[i + 1]:\n            count += 1\n\n    return count", "class PolyNode:\n    def __init__(self, c: int, p: int, next: 'PolyNode' = None):\n        self.coefficient = c\n        self.power = p\n        self.next = next\n\ndef addPoly(poly1: PolyNode, poly2: PolyNode) -> PolyNode:\n    dummy = PolyNode(0, 0)\n    current = dummy\n\n    while poly1 and poly2:\n        if poly1.power > poly2.power:\n            current.next = poly1\n            poly1 = poly1.next\n        elif poly1.power < poly2.power:\n            current.next = poly2\n            poly2 = poly2.next\n        else:\n            sum = poly1.coefficient + poly2.coefficient\n            if sum != 0:\n                current.next = PolyNode(sum, poly1.power)\n                current = current.next\n            poly1 = poly1.next\n            poly2 = poly2.next\n        current = current.next\n\n    current.next = poly1 if poly1 else poly2\n    return dummy.next", "def num_sub(s: str) -> int:\n    mod = 1000000007\n    result = 0\n    count = 0\n    for c in s:\n        count = count + 1 if c == '1' else 0\n        result = (result + count) % mod\n    return result", "def min_length_encoded(s: str, k: int) -> int:\n    n = len(s)\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            cnt = 1\n            dp[i][j] = i - j\n            l = i - 2\n            while l >= 0 and i - 2 - l <= j:\n                if s[l] == s[i - 1]:\n                    cnt += 1\n                else:\n                    cnt = 1\n                used = i - 2 - l\n                new_aposition = i - 1 - cnt - used + 1\n                if cnt >= 100:\n                    new_aposition += 4\n                elif cnt >= 10:\n                    new_aposition += 3\n                elif cnt >= 2:\n                    new_aposition += 2\n                else:\n                    new_aposition += 1\n                dp[i][j] = min(dp[i][j], new_aposition + dp[l][j - used])\n                l -= 1\n\n    return dp[n][k]", "def get_min_dist_sum(positions: List[List[int]]) -> float:\n    x, y = 0, 0\n    n = len(positions)\n    for pos in positions:\n        x += pos[0]\n        y += pos[1]\n    x /= n\n    y /= n\n    return x", "def numWays(words, target):\n    n = len(words)\n    m = len(target)\n    count = [[0] * 26 for _ in range(n)]\n    dp = [[0] * n for _ in range(m)]\n    mod = 1000000007\n\n    for i, word in enumerate(words):\n        for c in word:\n            count[i][ord(c) - ord('a')] += 1\n\n    for i in range(n):\n        dp[0][i] = count[i][ord(target[0]) - ord('a')]\n\n    for i in range(1, m):\n        for j in range(n):\n            for k in range(n):\n                dp[i][j] = (dp[i][j] + dp[i-1][k] * count[j][ord(target[i]) - ord('a')]) % mod\n\n    return sum(dp[m-1]) % mod", "def canFormArray(arr, pieces):\n    map = {piece[0]: piece for piece in pieces}\n\n    i = 0\n    while i < len(arr):\n        if arr[i] not in map:\n            return False\n        piece = map[arr[i]]\n        for num in piece:\n            if num != arr[i]:\n                return False\n            i += 1\n    return True", "def countVowelStrings(n: int) -> int:\n    dp = [1, 1, 1, 1, 1]\n    for i in range(2, n + 1):\n        for j in range(3, -1, -1):\n            dp[j] = dp[j] + dp[j + 1]\n    return sum(dp)", "def maxWaterBottles(numBottles: int, numExchange: int) -> int:\n    total = numBottles\n    while numBottles >= numExchange:\n        newBottles = numBottles // numExchange\n        total += newBottles\n        numBottles = newBottles + numBottles % numExchange\n    return total", "from collections import defaultdict\n\ndef dfs(node, tree, labels, ans, count):\n    prev_count = count[labels[node]]\n    count[labels[node]] += 1\n    ans[node] = count[labels[node]] - prev_count\n\n    for child in tree[node]:\n        dfs(child, tree, labels, ans, count)\n\n    count[labels[node]] = prev_count\n\ndef countSubTrees(n, edges, labels):\n    tree = defaultdict(list)\n    for edge in edges:\n        tree[edge[1]].append(edge[0])\n\n    ans = [0] * n\n    count = defaultdict(int)\n    dfs(0, tree, labels, ans, count)\n\n    return ans", "def max_num_of_substrings(s: str) -> List[str]:\n    last = [-1] * 26\n    for i, ch in enumerate(s):\n        last[ord(ch) - ord('a')] = i\n    \n    res = []\n    pre, max_right = -1, -1\n    for i, ch in enumerate(s):\n        max_right = max(max_right, last[ord(ch) - ord('a')])\n        if max_right == i:\n            res.append(s[pre + 1:max_right + 1])\n            pre = i\n    \n    return res", "def findKthPositive(arr, k):\n    i, num = 0, 1\n    while k > 0:\n        if i < len(arr) and arr[i] == num:\n            i += 1\n        else:\n            k -= 1\n        num += 1\n    return num - 1", "def can_convert(s, t, k):\n    diff = 0\n    for i in range(len(s)):\n        curr_diff = (ord(t[i]) - ord(s[i]) + 26) % 26\n        if curr_diff > 0:\n            diff += curr_diff\n            k -= curr_diff\n    return k >= 0 and k >= diff - len(s) and k % 26 == 0", "def minInsertions(s: str) -> int:\n    ans, depth = 0, 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            depth += 2\n        else:\n            if s[i - 1] == '(':\n                depth -= 1\n            else:\n                depth -= 2\n            if depth < 0:\n                ans -= depth\n                depth = 0\n    return ans + depth", "def maxNonOverlapping(nums, target):\n    prefix_sum = {0: 1}\n    sum_so_far = count = 0\n    for num in nums:\n        sum_so_far += num\n        if sum_so_far - target in prefix_sum:\n            count += 1\n            prefix_sum.clear()\n            prefix_sum[0] = 1\n            sum_so_far = 0\n        else:\n            prefix_sum[sum_so_far] = prefix_sum.get(sum_so_far, 0) + 1\n    return count", "class Node:\n    def __init__(self, val=0, left=None, right=None, parent=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.parent = parent\n\ndef lowest_common_ancestor(p, q):\n    a, b = p, q\n    while a != b:\n        a = a.parent if a.parent else q\n        b = b.parent if b.parent else p\n    return a", "def minOperations(target: str) -> int:\n    operations = 0\n    current_bit = '0'\n    for bit in target:\n        if bit != current_bit:\n            operations += 1\n            current_bit = bit\n    return operations", "def dfs(root, distance, depths):\n    if not root:\n        return 0\n    if not root.left and not root.right:\n        depths.append(0)\n        return 1\n    left, right = [], []\n    count = dfs(root.left, distance, left) + dfs(root.right, distance, right)\n    for l in left:\n        for r in right:\n            if l + r + 2 <= distance:\n                count += 1\n    depths.extend(l + 1 for l in left)\n    depths.extend(r + 1 for r in right)\n    return count\n\ndef countPairs(root, distance):\n    depths = []\n    return dfs(root, distance, depths)", "from collections import deque\n\ndef minimumJumps(forbidden, a, b, x):\n    forbidden_positions = set(forbidden)\n    q = deque([(0, 0, 0)])\n    visited = {(0, 0)}\n    while q:\n        pos, steps, backward = q.popleft()\n        if pos == x:\n            return steps\n        forward_pos = pos + a\n        backward_pos = pos - b\n        if forward_pos <= 6000 and forward_pos not in forbidden_positions and (forward_pos, 0) not in visited:\n            visited.add((forward_pos, 0))\n            q.append((forward_pos, steps + 1, 0))\n        if backward == 0 and backward_pos > 0 and backward_pos not in forbidden_positions and (backward_pos, 1) not in visited:\n            visited.add((backward_pos, 1))\n            q.append((backward_pos, steps + 1, 1))\n    return -1", "from collections import Counter\n\ndef canDistribute(nums, quantity):\n    counts = Counter(nums)\n    values = list(counts.values())\n    quantity.sort(reverse=True)\n\n    def dfs(index, values):\n        if index == len(quantity):\n            return True\n        for i in range(len(values)):\n            if values[i] >= quantity[index]:\n                values[i] -= quantity[index]\n                if dfs(index + 1, values):\n                    return True\n                values[i] += quantity[index]\n        return False\n\n    return dfs(0, values)", "def count_good_triplets(arr, a, b, c):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if abs(arr[i] - arr[j]) <= a:\n                for k in range(j+1, len(arr)):\n                    if abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\n                        count += 1\n    return count", "def get_winner(arr, k):\n    winner = arr[0]\n    consecutive_wins = 0\n\n    for i in range(1, len(arr)):\n        if arr[i] > winner:\n            winner = arr[i];\n            consecutive_wins = 0\n\n        consecutive_wins += 1\n        if consecutive_wins == k:\n            break\n\n    return winner", "def min_swaps(grid):\n    n = len(grid)\n    row_zeros = [0] * n\n    \n    for i in range(n):\n        for j in range(n - 1, -1, -1):\n            if grid[i][j] == 0:\n                row_zeros[i] += 1\n            else:\n                break\n    \n    steps = 0\n    for i in range(n):\n        target = n - i - 1\n        current_row = i\n        while current_row < n and row_zeros[current_row] < target:\n            current_row += 1\n        if current_row == n:\n            return -1\n        steps += current_row - i\n        row_zeros.pop(current_row)\n        row_zeros.insert(i, target)\n    \n    return steps", "def maxSum(nums1, nums2):\n    mod = 10**9 + 7\n    m, n = len(nums1), len(nums2)\n    dp1, dp2 = [0] * (m + 1), [0] * (n + 1)\n    i, j = m - 1, n - 1\n    while i >= 0 or j >= 0:\n        a = dp1[i] + nums1[i] if i >= 0 else float('-inf')\n        b = dp2[j] + nums2[j] if j >= 0 else float('-inf')\n        seen = set()\n        if a > b:\n            dp1[i] = a % mod\n            i -= 1\n            seen.add(nums1[i + 1])\n        else:\n            dp2[j] = b % mod\n            j -= 1\n            seen.add(nums2[j + 1])\n    return max(dp1[0], dp2[0]) % mod", "def thousand_separator(n: int) -> str:\n    result = str(n)\n    count = 0\n    for i in range(len(result) - 1, 0, -1):\n        count += 1\n        if count % 3 == 0:\n            result = result[:i] + '.' + result[i:]\n    return result", "def min_num_operations(nums):\n    result = 0\n    highest_bit = [0] * 32\n    for num in nums:\n        for j in range(32):\n            if num & (1 << j):\n                highest_bit[j] += 1\n    for count in highest_bit:\n        result = max(result, count)\n    return result + 31", "def contains_cycle(grid):\n    def dfs(x, y, start_x, start_y, depth):\n        if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] != grid[start_x][start_y]:\n            return False\n        \n        grid[x][y] = '*'\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for dx, dy in directions:\n            new_x, new_y = x + dx, y + dy\n\n            if new_x == start_x and new_y == start_y and depth >= 4:\n                return True\n\n            if dfs(new_x, new_y, start_x, start_y, depth + 1):\n                return True\n        \n        grid[x][y] = grid[start_x][start_y]\n\n        return False\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dfs(i, j, i, j, 0):\n                return True\n\n    return False", "def numberOfFairs(nums):\n    even_sum = sum(nums[0::2])\n    odd_sum = sum(nums[1::2])\n    l_even = l_odd = count = 0\n    for i, num in enumerate(nums):\n        if i % 2 == 0:\n            even_sum -= num\n            if l_even + odd_sum == l_odd + even_sum:\n                count += 1\n            l_even += num\n        else:\n            odd_sum -= num\n            if l_even + odd_sum == l_odd + even_sum:\n                count += 1\n            l_odd += num\n    return count", "def minimumEffort(tasks):\n    tasks.sort(key=lambda task: task[1] - task[0], reverse=True)\n    ans, sum_energy = 0, 0\n    for task in tasks:\n        ans = max(ans, sum_energy + task[1])\n        sum_energy += task[0]\n    return ans", "def make_good(s: str) -> str:\n    result = []\n    for c in s:\n        if result and abs(ord(result[-1]) - ord(c)) == 32:\n            result.pop()\n        else:\n            result.append(c)\n    return \"\".join(result)", "def longestAwesomeSubstring(s):\n    n = len(s)\n    maxLen = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substr = s[i:j]\n            if isAwesome(substr):\n                maxLen = max(maxLen, j - i)\n    return maxLen\n\ndef isAwesome(s):\n    odd_count = 0\n    freq = [0] * 26\n    for c in s:\n        freq[ord(c) - ord('a')] += 1\n    for i in range(26):\n        if freq[i] % 2 == 1:\n            odd_count += 1\n    return odd_count <= 1", "def minCost(n, cuts):\n    cuts = [0] + cuts + [n]\n    cuts.sort()\n    size = len(cuts)\n    dp = [[0] * size for _ in range(size)]\n\n    for len in range(2, size):\n        for i in range(size - len):\n            j = i + len\n            dp[i][j] = float('inf')\n            for k in range(i + 1, j):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cuts[j] - cuts[i])\n\n    return dp[0][size - 1]", "from collections import deque\n\nclass FrontMiddleBackQueue:\n\n    def __init__(self):\n        self.first = deque()\n        self.second = deque()\n\n    def pushFront(self, val: int) -> None:\n        self.first.appendleft(val)\n        if len(self.first) > len(self.second) + 1:\n            self.second.appendleft(self.first.pop())\n\n    def pushMiddle(self, val: int) -> None:\n        if len(self.first) < len(self.second):\n            self.first.append(val)\n        else:\n            self.second.appendleft(val)\n\n    def pushBack(self, val: int) -> None:\n        self.second.append(val)\n        if len(self.second) > len(self.first):\n            self.first.append(self.second.popleft())\n\n    def popFront(self) -> int:\n        if not self.first and not self.second:\n            return -1\n        val = self.first.popleft()\n        if len(self.first) + 1 < len(self.second):\n            self.first.append(self.second.popleft())\n        return val\n\n    def popMiddle(self) -> int:\n        if not self.first and not self.second:\n            return -1\n        if len(self.first) < len(self.second):\n            val = self.second.popleft()\n        else:\n            val = self.first.pop()\n        if len(self.second) > len(self.first):\n            self.first.append(self.second.popleft())\n        return val\n\n    def popBack(self) -> int:\n        if not self.first and not self.second:\n            return -1\n        val = self.second.pop()\n        if len(self.first) > len(self.second) + 1:\n            self.second.appendleft(self.first.pop())\n        return val", "def minimumMountainRemovals(nums):\n    n = len(nums)\n    left, right = [0] * n, [0] * n\n    for i in range(1, n):\n        left[i] = left[i - 1] + int(nums[i] > nums[i - 1])\n        right[n - i - 1] = right[n - i] + int(nums[n - i - 1] > nums[n - i])\n    ans = n - 3\n    for i in range(1, n - 1):\n        ans = min(ans, n - 1 - left[i] - right[i])\n    return ans", "def maximumWealth(accounts):\n    max_wealth = 0\n    for customer in accounts:\n        wealth = sum(customer)\n        max_wealth = max(max_wealth, wealth)\n    return max_wealth", "from collections import deque\n\ndef mostCompetitive(nums, k):\n    stack = deque()\n    n = len(nums)\n    for i in range(n):\n        while stack and stack[-1] > nums[i] and len(stack) + n - i > k:\n            stack.pop()\n        if len(stack) < k:\n            stack.append(nums[i])\n    return list(stack)", "def min_operations(n):\n    return n * (n - 1) // 2", "from typing import List\n\ndef can_place_balls(force: int, position: List[int], m: int) -> bool:\n    last_position = position[0]\n    placed_balls = 1\n\n    for i in range(1, len(position)):\n        if position[i] - last_position >= force:\n            placed_balls += 1\n            last_position = position[i]\n\n            if placed_balls == m:\n                return True\n\n    return False\n\ndef max_distance(position: List[int], m: int) -> int:\n    position.sort()\n\n    left = 1\n    right = position[-1] - position[0]\n    ans = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_place_balls(mid, position, m):\n            ans = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return ans", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef lowestCommonAncestor(root, nodes):\n    if root is None or root in nodes:\n        return root\n    left = lowestCommonAncestor(root.left, nodes)\n    right = lowestCommonAncestor(root.right, nodes)\n    if left is not None and right is not None:\n        return root\n    return left if left is not None else right", "def num_ways(s: str) -> int:\n    number_of_ones = s.count('1')\n    if number_of_ones % 3 != 0:\n        return 0\n\n    target = number_of_ones // 3\n    if target == 0:\n        n = len(s)\n        return ((n - 1) * (n - 2) // 2) % 1000000007\n\n    ones_so_far1, ones_so_far2 = 0, 0\n    way1, way2 = 0, 0\n    for c in s:\n        if c == '1':\n            ones_so_far1 += 1\n            if ones_so_far1 == target:\n                way1 += 1\n                ones_so_far1 = 0\n\n            ones_so_far2 += 1\n            if ones_so_far2 == target * 2:\n                way2 += 1\n                ones_so_far2 = 0\n\n    return (way1 * way2) % 1000000007", "def findLengthOfShortestSubarray(arr):\n    n = len(arr)\n    left, right = 0, n - 1\n\n    while left < n - 1 and arr[left] <= arr[left + 1]:\n        left += 1\n\n    if left == n - 1:\n        return 0\n\n    while right > 0 and arr[right] >= arr[right - 1]:\n        right -= 1\n\n    result = min(right, n - left - 1)\n\n    i, j = 0, right\n\n    while i <= left and j < n:\n        if arr[i] <= arr[j]:\n            result = min(result, j - i - 1)\n            i += 1\n        else:\n            j += 1\n\n    return result", "def count_routes(locations, start, finish, fuel, curr=None, remaining_fuel=None, memo=None):\n    if memo is None:\n        memo = {}\n     \n    if curr is None:\n        curr = start\n        remaining_fuel = fuel\n\n    if remaining_fuel < 0:\n        return 0\n\n    if (curr, remaining_fuel) in memo:\n        return memo[(curr, remaining_fuel)]\n\n    ans = 1 if curr == finish else 0\n    for next in range(len(locations)):\n        if next != curr:\n            ans += count_routes(locations, start, finish, fuel, next, remaining_fuel - abs(locations[curr] - locations[next]), memo)\n            ans %= 1000000007\n\n    memo[(curr, remaining_fuel)] = ans\n    return ans", "def most_visited(n, rounds):\n    visited = [0] * (n + 1)\n    \n    for i in range(1, len(rounds)):\n        start, end = rounds[i - 1], rounds[i]\n        while start != end:\n            visited[start] += 1\n            start = (start % n) + 1\n    visited[rounds[-1]] += 1\n    \n    max_visits = max(visited);\n    return [i for i in range(1, n + 1) if visited[i] == max_visits]", "def find_latest_step(arr, m):\n    n = len(arr)\n    length_left, length_right = [0] * (n + 2), [0] * (n + 2)\n    count, result = 0, -1\n\n    for i, pos in enumerate(arr):\n        left_length = length_right[pos - 1]\n        right_length = length_left[pos + 1]\n        new_length = left_length + right_length + 1\n\n        if left_length == m or right_length == m:\n            count -= 1\n\n        if new_length == m:\n            count += 1\n\n        if new_length > 0:\n            length_left[pos - left_length] = new_length\n            length_right[pos + right_length] = new_length\n            result = i + 1\n\n    return result if count > 0 else -1", "def stoneGameV(stoneValue):\n    memo = [[-1 for _ in range(len(stoneValue))] for _ in range(len(stoneValue))]\n    return maxScore(stoneValue, 0, len(stoneValue) - 1, memo)\n\ndef maxScore(stoneValue, start, end, memo):\n    if start == end:\n        return 0\n    if memo[start][end] != -1:\n        return memo[start][end]\n\n    left_sum, right_sum = 0, 0\n    for i in range(start, end):\n        left_sum += stoneValue[i]\n        right_sum = sum(stoneValue[i + 1:end + 1])\n\n        if left_sum > right_sum:\n            memo[start][end] = max(memo[start][end], right_sum + maxScore(stoneValue, i + 1, end, memo))\n        elif left_sum < right_sum:\n            memo[start][end] = max(memo[start][end], left_sum + maxScore(stoneValue, start, i, memo))\n        else:\n            memo[start][end] = max(memo[start][end], left_sum + max(maxScore(stoneValue, start, i, memo), maxScore(stoneValue, i + 1, end, memo)))\n\n    return memo[start][end]", "def stoneGameVI(aliceValues, bobValues):\n    n = len(aliceValues)\n    diff = sorted([(aliceValues[i] + bobValues[i], i) for i in range(n)], reverse=True)\n\n    aliceSum, bobSum = 0, 0\n    for i in range(n):\n        if i % 2 == 0:\n            aliceSum += aliceValues[diff[i][1]]\n        else:\n            bobSum += bobValues[diff[i][1]]\n            \n    return 0 if aliceSum == bobSum else (1 if aliceSum > bobSum else -1)", "def min_trips(boxes, portsCount, maxBoxes, maxWeight):\n    trips = 0\n    idx = 0\n    n = len(boxes)\n    while idx < n:\n        curr_limit = maxWeight\n        prev_port = 0\n        count = 0\n        while count < maxBoxes and idx < n:\n            if boxes[idx][1] <= curr_limit:\n                if prev_port != boxes[idx][0]:\n                    prev_port = boxes[idx][0]\n                    trips += 1\n                curr_limit -= boxes[idx][1]\n                count += 1\n                idx += 1\n            else:\n                break\n        trips += 1\n    return trips", "def numberOfMatches(n: int) -> int:\n    matches = 0\n    while n > 1:\n        matches += n // 2\n        n = (n + 1) // 2\n    return matches", "def containsPattern(arr, m, k):\n    n = len(arr)\n    if m * k > n:\n        return False\n\n    for i in range(n - m * k + 1):\n        patternFound = True\n        for j in range(m):\n            for l in range(1, k):\n                if arr[i + j] != arr[i + j + l * m]:\n                    patternFound = False\n                    break\n            if not patternFound:\n                break\n        if patternFound:\n            return True\n    return False", "def getMaxLen(nums):\n    maxLength = currentLen = currentNegLen = 0\n    \n    for num in nums:\n        if num > 0:\n            currentLen += 1\n            if currentNegLen > 0:\n                currentNegLen += 1\n        elif num < 0:\n            currentLen, currentNegLen = currentNegLen, currentLen + 1\n        else:\n            currentLen = currentNegLen = 0\n        maxLength = max(maxLength, currentLen)\n    \n    return maxLength", "def numTrees(n: int) -> int:\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - 1 - j]\n            dp[i] %= (10**9 + 7)\n\n    return dp[n]", "def min_subarray(nums, p):\n    n = len(nums)\n    need, cur, res = 0, 0, n\n    last_seen = {}\n\n    for num in nums:\n        need = (need + num) % p\n\n    if need == 0:\n        return 0\n\n    last_seen[cur] = -1\n    for i, num in enumerate(nums):\n        cur = (cur + num) % p\n        last_seen[cur] = i\n        want = (cur - need + p) % p\n        if want in last_seen:\n            res = min(res, i - last_seen[want])\n\n    return res if res != n else -1", "from typing import List\n\ndef maxSumRangeQuery(nums: List[int], requests: List[List[int]]) -> int:\n    mod = 10**9 + 7\n    n = len(nums)\n    cnt = [0] * n\n    \n    for req in requests:\n        cnt[req[0]] += 1\n        if req[1] + 1 < n:\n            cnt[req[1] + 1] -= 1\n    \n    for i in range(1, n):\n        cnt[i] += cnt[i - 1]\n    \n    nums.sort()\n    cnt.sort()\n    \n    ans = sum(nums[i] * cnt[i] for i in range(n)) % mod\n    \n    return ans", "def isPrintable(targetGrid):\n    m, n = len(targetGrid), len(targetGrid[0])\n    top, bottom, left, right = [m]*61, [-1]*61, [n]*61, [-1]*61\n    vis = [[False]*n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            c = targetGrid[i][j]\n            top[c] = min(top[c], i)\n            bottom[c] = max(bottom[c], i)\n            left[c] = min(left[c], j)\n            right[c] = max(right[c], j)\n\n    def dfs(x):\n        i, j = x // n, x % n\n        if vis[i][j]: return True\n        c = targetGrid[i][j]\n        if i < top[c] or i > bottom[c] or j < left[c] or j > right[c]: return False\n        vis[i][j] = True\n        for k in range(1, 61):\n            if k == c: continue\n            if i >= top[k] and i <= bottom[k] and j >= left[k] and j <= right[k]: return False\n            if not dfs(((i-top[k])*(right[k]-left[k]+1)) + j - left[k]): return False\n        return True\n\n    for color in range(1, 61):\n        for i in range(top[color], bottom[color] + 1):\n            for j in range(left[color], right[color] + 1):\n                if not vis[i][j] and not dfs(i * n + j): return False\n\n    return True", "from collections import defaultdict, deque\n\ndef distanceLimitedPathsExist(n, edgeList, queries):\n    graph = defaultdict(list)\n\n    for u, v, dis in edgeList:\n        graph[u].append((v, dis))\n        graph[v].append((u, dis))\n\n    answer = [False] * len(queries)\n    for i, (pj, qj, limitj) in enumerate(queries):\n        q = deque([(pj, 0)])\n        visited = [False] * n\n        visited[pj] = True\n\n        while q:\n            curr_node, curr_dist = q.popleft()\n\n            for next_node, next_dist in graph[curr_node]:\n                if curr_dist + next_dist < limitj:\n                    if next_node == qj:\n                        answer[i] = True\n                        break\n                    if not visited[next_node]:\n                        visited[next_node] = True\n                        q.append((next_node, curr_dist + next_dist))\n            if answer[i]:\n                break\n\n    return answer", "def modifyString(s: str) -> str:\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] == '?':\n            for c in range(ord('a'), ord('z') + 1):\n                if (i - 1 < 0 or s[i - 1] != chr(c)) and (i + 1 >= len(s) or s[i + 1] != chr(c)):\n                    s[i] = chr(c)\n                    break\n    return ''.join(s)", "def min_time_to_remove_balloons(colors, neededTime):\n    n = len(colors)\n    INF = 10**9\n    dp = [[INF] * 26 for _ in range(n)]\n\n    for color in range(26):\n        if colors[0] != chr(ord('A') + color):\n            dp[0][color] = neededTime[0]\n\n    for i in range(1, n):\n        for color1 in range(26):\n            for color2 in range(26):\n                if color1 != color2 and colors[i] != chr(ord('A') + color1):\n                    dp[i][color1] = min(dp[i][color1], dp[i-1][color2] + neededTime[i])\n\n    ans = INF\n    for color in range(26):\n        ans = min(ans, dp[n-1][color])\n\n    return ans", "def maxNumEdgesToRemove(n, edges):\n    def find(u):\n        if parent[u] == u:\n            return u\n        else:\n            parent[u] = find(parent[u])\n            return parent[u]\n\n    def unite(u, v):\n        u = find(u)\n        v = find(v)\n        if u != v:\n            parent[u] = v\n            return True\n        return False\n\n    parent = list(range(2 * n + 1))\n    ct = [0, 0]\n    both = n - 1\n    edges.sort(reverse=True)\n    for edge in edges:\n        type, u, v = edge\n        if type == 3 and unite(u, v + n):\n            both -= 1\n        if both == 0:\n            break\n\n    for type in range(1, 3):\n        for edge in edges:\n            a, u, v = edge\n            if a == type and unite(u, v + n):\n                ct[type - 1] += 1\n        if both + ct[type - 1] < n - 1:\n            return -1\n\n    return ct[0] + ct[1] - n + 1", "def maximum_binary_string(binary: str) -> str:\n    zero_count = binary.count('0')\n    \n    if zero_count <= 1:\n        return binary\n    \n    one_count = len(binary) - zero_count\n\n    result = \"1\" * one_count + \"0\" * (zero_count - 1) + \"1####1\"\n    return result[:len(binary)]", "def minMoves(nums, k):\n    ones_pos = [i for i, x in enumerate(nums) if x == 1]\n    to_move = [i_b - i_a for i_a, i_b in zip(range(k), ones_pos)]\n    min_moves = sum(to_move[k // 2:])\n    move = min_moves\n    for left, right in zip(\n        to_move[:-k],       # left \"window\" of k-sized sliding window\n        to_move[k // 2 + 1:],  # right \"window\" of k-sized sliding window\n    ):\n        move += left - right\n        min_moves = min(min_moves, move)\n    return min_moves", "def numSpecial(mat):\n    m, n = len(mat), len(mat[0])\n    row, col = [0] * m, [0] * n\n\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 1:\n                row[i] += 1\n                col[j] += 1\n\n    special_positions = 0\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 1 and row[i] == 1 and col[j] == 1:\n                special_positions += 1\n\n    return special_positions", "def unhappyFriends(n, preferences, pairs):\n    pair_mapping = [0] * n\n    for pair in pairs:\n        pair_mapping[pair[0]] = pair[1]\n        pair_mapping[pair[1]] = pair[0]\n\n    unhappy_count = 0\n    for x in range(n):\n        y = pair_mapping[x]\n        pref_x = preferences[x]\n        idx_y = pref_x.index(y)\n\n        for i in range(idx_y):\n            u = pref_x[i]\n            v = pair_mapping[u]\n            pref_u = preferences[u]\n            if x in pref_u[:pref_u.index(v)]:\n                unhappy_count += 1\n                break\n\n    return unhappy_count // 2", "def minCostConnectPoints(points):\n    n = len(points)\n    cost = [float('inf')] * n\n    visited = [False] * n\n    cost[0] = 0\n\n    ans = 0\n\n    for _ in range(n):\n        min_cost = float('inf')\n        cur_point = -1\n        for j in range(n):\n            if not visited[j] and cost[j] < min_cost:\n                min_cost = cost[j]\n                cur_point = j\n\n        visited[cur_point] = True\n        ans += min_cost\n\n        for j in range(n):\n            if not visited[j]:\n                new_cost = abs(points[cur_point][0] - points[j][0]) + abs(points[cur_point][1] - points[j][1])\n                cost[j] = min(cost[j], new_cost)\n\n    return ans", "def can_transform(s, t):\n    i, j = 0, 0\n    while i < len(s) and j < len(t):\n        if s[i] == t[j]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n    return j == len(t)", "class ParkingSystem:\n\n    def __init__(self, big: int, medium: int, small: int):\n        self.slots = [big, medium, small]\n\n    def addCar(self, carType: int) -> bool:\n        if self.slots[carType - 1] > 0:\n            self.slots[carType - 1] -= 1\n            return True\n        else:\n            return False", "import heapq\n\ndef busiest_servers(k, arrival, load):\n    server_requests = [0] * k\n    pq = []\n    available_servers = list(range(k))\n\n    for i in range(len(arrival)):\n        while pq and pq[0][0] <= arrival[i]:\n            _, server_id = heapq.heappop(pq)\n            available_servers.append(server_id)\n\n        if available_servers:\n            server_id = available_servers.pop(0)\n            server_requests[server_id] += 1\n            heapq.heappush(pq, (arrival[i] + load[i], server_id))\n\n    max_requests = max(server_requests)\n    return [i for i in range(k) if server_requests[i] == max_requests]", "def restoreMatrix(rowSum, colSum):\n    m, n = len(rowSum), len(colSum)\n    result = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            value = min(rowSum[i], colSum[j])\n            result[i][j] = value\n            rowSum[i] -= value\n            colSum[j] -= value\n\n    return result", "def waysToSplit(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    prefixSum = [0] * (n + 1)\n    for i in range(n):\n        prefixSum[i + 1] = prefixSum[i] + nums[i]\n    \n    ans = 0\n    left, right = 0, 0\n    for mid in range(1, n - 1):\n        while left + 1 < mid and prefixSum[left + 1] * 2 <= prefixSum[mid]:\n            left += 1\n        while right < mid or (right + 1 < n and prefixSum[right + 1] - prefixSum[mid] <= prefixSum[n] - prefixSum[right + 1]):\n            right += 1\n        if right >= mid and prefixSum[mid] - prefixSum[left] <= prefixSum[right] - prefixSum[mid]:\n            ans = (ans + right - mid + 1) % MOD\n\n    return ans", "from bisect import bisect_left\n\ndef minOperations(target, arr):\n    pos = {x: i for i, x in enumerate(target)}\n\n    dp = []\n    for a in arr:\n        if a in pos:\n            idx = bisect_left(dp, pos[a])\n            if idx == len(dp):\n                dp.append(pos[a])\n            else:\n                dp[idx] = pos[a]\n    return len(target) - len(dp)", "def reorder_spaces(text: str) -> str:\n    spaces = text.count(' ')\n    words = text.split()\n    \n    if len(words) == 1:\n        return words[0] + ' ' * spaces\n\n    space_between_words = spaces // (len(words) - 1)\n    extra_spaces = spaces % (len(words) - 1)\n    result = ''\n    \n    for i, word in enumerate(words):\n        result += word\n        if i < len(words) - 1:\n            result += ' ' * space_between_words\n    \n    result += ' ' * extra_spaces\n\n    return result", "def maxProductPath(grid):\n    m, n, mod = len(grid), len(grid[0]), int(1e9 + 7)\n    dp = [[[0, 0] for _ in range(n)] for _ in range(m)]\n    \n    dp[0][0] = [grid[0][0], grid[0][0]]\n    \n    for i in range(1, m):\n        dp[i][0] = [dp[i - 1][0][0] * grid[i][0], dp[i - 1][0][0] * grid[i][0]]\n    for j in range(1, n):\n        dp[0][j] = [dp[0][j - 1][0] * grid[0][j], dp[0][j - 1][0] * grid[0][j]]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] < 0:\n                dp[i][j][0] = min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j]\n                dp[i][j][1] = max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j]\n            else:\n                dp[i][j][0] = max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j]\n                dp[i][j][1] = min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j]\n            \n    return dp[m - 1][n - 1][0] % mod if dp[m - 1][n - 1][0] >= 0 else -1", "def min_cost(cost, size1, size2):\n    dp = [float('inf')] * (size2 + 1)\n    dp[0] = 0\n\n    for i in range(size1):\n        for j in range(size2, -1, -1):\n            min_cost = float('inf')\n            for k in range(size2):\n                if (1 << k) & j == 0:\n                    min_cost = min(min_cost, cost[i][k] + dp[j | (1 << k)])\n            dp[j] = min(dp[j], min_cost)\n\n    return dp[(1 << size2) - 1]", "class Solution:\n    def constructDistancedSequence(self, n: int) -> List[int]:\n        res = [0] * (2 * n - 1)\n\n        def backtrack(i, unused):\n            if i == len(res):\n                return True\n            if res[i]:\n                return backtrack(i + 1, unused)\n            for num in range(n, 0, -1):\n                if (unused >> num) & 1:\n                    if num == 1 or (i + num < len(res) and not res[i + num]):\n                        res[i] = num\n                        if num > 1:\n                            res[i + num] = num\n                        if backtrack(i + 1, unused ^ (1 << num)):\n                            return True\n                        res[i] = 0\n                        if num > 1:\n                            res[i + num] = 0\n            return False\n\n        backtrack(0, (1 << (n + 1)) - 2)\n        return res", "def check_ways(pairs):\n    candidates = {}\n    for x, y in pairs:\n        candidates[x] = candidates.get(x, 0) + 1\n        candidates[y] = candidates.get(y, 0) + 1\n\n    root_count = sum(1 for v in candidates.values() if v == 1)\n    return min(root_count, 2)", "def minOperations(logs):\n    depth = 0\n    for log in logs:\n        if log == \"../\":\n            if depth > 0:\n                depth -= 1\n        elif log != \"./\":\n            depth += 1\n    return depth", "def min_operations_max_profit(customers, boarding_cost, running_cost):\n    rotations = waiting = on_board = profit = max_profit = max_rotations = 0\n    while customers or waiting > 0:\n        if customers:\n            waiting += customers.pop(0)\n            \n        on_board = min(waiting, 4)\n        waiting -= on_board\n        profit += on_board * boarding_cost - running_cost\n        rotations += 1\n        \n        if profit > max_profit:\n            max_profit = profit\n            max_rotations = rotations\n            \n    return max_rotations if max_profit > 0 else -1", "class ThroneInheritance:\n    def __init__(self, kingName: str):\n        self.children = {}\n        self.alive = {kingName: True}\n        self.king = kingName\n\n    def birth(self, parentName: str, childName: str):\n        if parentName not in self.children:\n            self.children[parentName] = []\n        self.children[parentName].append(childName)\n        self.alive[childName] = True\n\n    def death(self, name: str):\n        self.alive[name] = False\n\n    def getInheritanceOrder(self):\n        order = []\n        self.getSuccessor(self.king, order)\n        return order\n\n    def getSuccessor(self, name: str, order: list):\n        if self.alive[name]:\n            order.append(name)\n        for child in self.children.get(name, []):\n            self.getSuccessor(child, order)", "def max_achievable_requests(n, requests, idx=0, counts=None):\n    if counts is None:\n        counts = [0] * n\n    if idx == len(requests):\n        if all(count == 0 for count in counts):\n            return 0\n        return 0\n\n    ignored = max_achievable_requests(n, requests, idx+1, counts[:])\n    counts[requests[idx][0]] += 1\n    counts[requests[idx][1]] -= 1\n\n    accepted = 1 + max_achievable_requests(n, requests, idx+1, counts)\n\n    return max(ignored, accepted)", "class DistanceLimitedPathsExist:\n    def __init__(self, n: int, edgeList: List[List[int]]):\n        self.id = list(range(n))\n        edgeList.sort(key=lambda x: x[2])\n        self.mst = []\n        for edge in edgeList:\n            p, q = self.find(edge[0]), self.find(edge[1])\n            if p != q:\n                self.id[p] = self.id[q]\n                self.mst.append(edge)\n\n    def query(self, p: int, q: int, limit: int) -> bool:\n        for edge in self.mst:\n            if edge[2] >= limit:\n                break\n            p, q = self.union_set(edge[0], p), self.union_set(edge[1], q)\n            if p == q:\n                return True\n        return False\n\n    def find(self, x: int) -> int:\n        if self.id[x] != x:\n            self.id[x] = self.find(self.id[x])\n        return self.id[x]\n\n    def union_set(self, x: int, y: int) -> int:\n        px, py = self.find(x), self.find(y)\n        if px != py:\n            self.id[px] = py\n        return py", "def numberOfSets(n, k):\n    mod = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(n)]\n    presum = [1] * n\n    \n    for j in range(1, k + 1):\n        for i in range(n):\n            dp[i][j] = presum[i]\n            if i > 0:\n                dp[i][j] += dp[i - 1][j]\n            dp[i][j] %= mod\n            presum[i] = (presum[i] + dp[i][j - 1]) % mod\n    \n    return dp[n - 1][k]", "from math import sqrt\n\ndef best_coordinate(towers, radius):\n    max_quality = 0\n    best_x, best_y = 0, 0\n\n    for x in range(51):\n        for y in range(51):\n            sum_quality = 0\n            for tower in towers:\n                dist = sqrt((x - tower[0])**2 + (y - tower[1])**2)\n                if dist <= radius:\n                    sum_quality += tower[2] // (1 + dist)\n            if sum_quality > max_quality:\n                max_quality = sum_quality\n                best_x, best_y = x, y\n\n    return [best_x, best_y]", "def canMouseWin(grid: List[List[str]], catJump: int, mouseJump: int) -> bool:\n    rows, cols = len(grid), len(grid[0])\n    cat_r = cat_c = mouse_r = mouse_c = 0\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 'C':\n                cat_r, cat_c = r, c\n            elif grid[r][c] == 'M':\n                mouse_r, mouse_c = r, c\n\n    dirs = [-1, 0, 1, 0, -1]\n\n    def dfs(r_m, c_m, r_c, c_c, cnt, dst_m_c):\n        if cnt >= 100:\n            return False\n        if r_m < 0 or r_m >= rows or c_m < 0 or c_m >= cols:\n            return False\n        if r_c < 0 or r_c >= rows or c_c < 0 or c_c >= cols:\n            return True\n        if grid[r_m][c_m] == 'F' or cnt != dst_m_c:\n            return True\n        elif grid[r_m][c_m] == '#' or cnt + 1 == dst_m_c:\n            return False\n\n        res = False\n        for i in range(4):\n            jump = catJump if dst_m_c == cnt else mouseJump\n            res |= not dfs(r_m + jump * dirs[i], c_m + jump * dirs[i + 1], r_c + dirs[i] * dirs[(i + 2) % 4], c_c + dirs[i+1] * dirs[(i + 3) % 4], cnt + 1, dst_m_c)\n            if jump == 1:\n                break\n\n        return res\n\n    return dfs(mouse_r, mouse_c, cat_r, cat_c, 0, abs(cat_r - mouse_r) + abs(cat_c - mouse_c))", "class Fancy:\n    def __init__(self):\n        self.sequence = []\n\n    def append(self, val):\n        self.sequence.append(val)\n\n    def addAll(self, inc):\n        self.sequence = [num + inc for num in self.sequence]\n\n    def multAll(self, m):\n        self.sequence = [num * m for num in self.sequence]\n\n    def getIndex(self, idx):\n        if idx >= len(self.sequence):\n            return -1\n        return self.sequence[idx]", "def find_special_integer(nums):\n    for x in range(1, len(nums) + 1):\n        count = sum(1 for num in nums if num >= x)\n        if count == x:\n            return x\n    return -1", "def min_operations(n):\n    operations = 0\n    while n > 0:\n        if n % 2 == 0:\n            n //= 2\n        else:\n            n -= 1\n        operations += 1\n    return operations", "from math import atan2, degrees\n\ndef visiblePoints(points, angle, location):\n    angles = [degrees(atan2(y - location[1], x - location[0])) for x, y in points if [x, y] != location]\n    angles.sort()\n    angles += [a + 360 for a in angles]\n    n = len(angles)\n    max_points, j = 0, 0\n    for i in range(2 * n):\n        while angles[i] - angles[j] > angle:\n            j += 1\n        max_points = max(max_points, i - j + 1)\n    return max_points + points.count(location)", "def decode(encoded):\n    n = len(encoded) + 1\n    total_xor = 0\n    \n    for i in range(1, n + 1):\n        total_xor ^= i\n\n    non_first_xor = 0\n    for i in range(1, n - 1, 2):\n        non_first_xor ^= encoded[i]\n\n    perm = [total_xor ^ non_first_xor]\n    for i in range(1, n):\n        perm.append(perm[-1] ^ encoded[i - 1])\n    \n    return perm", "MOD = 10**9 + 7\n\ndef mul(a, b):\n    return (a * b) % MOD\n\ndef ways(n, k, mem):\n    if n == 1:\n        return k\n    if (n_tuple := (n, k)) in mem:\n        return mem[n_tuple]\n    if k == 1:\n        mem[n_tuple] = 1\n        return 1\n    if n > k:\n        mem[n_tuple] = 0\n        return 0\n    res = mul(ways(n, k - 1, mem), n)\n    res = (res - mul(n - 1, ways(n - 1, k - 1, mem)) + MOD) % MOD\n    mem[n_tuple] = res\n    return res\n\ndef waysToFillArray(queries):\n    mem = {}\n    ans = []\n    for q in queries:\n        ans.append(ways(q[0], q[1], mem))\n    return ans", "def maximumTime(time: str) -> str:\n    time_list = list(time)\n    if time_list[0] == '?':\n        time_list[0] = '2' if time_list[1] <= '3' or time_list[1] == '?' else '1'\n    if time_list[1] == '?':\n        time_list[1] = '3' if time_list[0] == '2' else '9'\n    if time_list[3] == '?':\n        time_list[3] = '5'\n    if time_list[4] == '?':\n        time_list[4] = '9'\n    return \"\".join(time_list)", "def maxDepth(s: str) -> int:\n    depth, max_depth = 0, 0\n    for ch in s:\n        if ch == '(':\n            depth += 1\n        elif ch == ')':\n            depth -= 1\n        max_depth = max(max_depth, depth)\n    return max_depth", "def maximalNetworkRank(n, roads):\n    degree = [0] * n\n    s = set()\n    \n    for road in roads:\n        degree[road[0]] += 1\n        degree[road[1]] += 1\n        s.add(tuple(sorted(road)))\n    \n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans = max(ans, degree[i] + degree[j] - (1 if (i, j) in s else 0))\n    return ans", "def check_palindrome_formation(a: str, b: str) -> bool:\n    def is_palindrome(s: str, left: int, right: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    i, j = 0, len(a) - 1\n    while i < j:\n        if a[i] != b[j]:\n            return is_palindrome(a, i, j) or is_palindrome(b, i, j)\n        i += 1\n        j -= 1\n    return True", "from collections import defaultdict\n\ndef countSubgraphsForEachD(n, edges):\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def dfs(node, parent):\n        depth = 0\n        for child in tree[node]:\n            if child != parent:\n                depth = max(depth, 1 + dfs(child, node))\n        return depth\n\n    ans = [0] * (n - 1)\n    for i in range(1, n + 1):\n        maxD = dfs(i, 0)\n        if maxD > 0:\n            ans[maxD - 1] += 1\n\n    return ans", "def maxWidthOfVerticalArea(points):\n    xs = sorted([point[0] for point in points])\n    max_width = 0\n    for i in range(1, len(xs)):\n        max_width = max(max_width, xs[i] - xs[i - 1])\n    return max_width", "def count_substrings_with_one_difference(s, t):\n    count = 0\n    for i in range(len(s)):\n        for j in range(len(t)):\n            differences = 0\n            k = 0\n            while i + k < len(s) and j + k < len(t):\n                if s[i + k] != t[j + k]:\n                    differences += 1\n                if differences == 2:\n                    break\n                if differences == 1:\n                    count += 1\n                k += 1\n    return count", "def num_ways(words, target):\n    n, m = len(words), len(target)\n    MOD = 10**9 + 7\n    cnt = [0] * 26\n    for word in words:\n        for ch in word:\n            cnt[ord(ch) - ord('a')] += 1\n    dp = [0] * (m + 1)\n    dp[0] = 1\n    for ch in target:\n        for i in range(m - 1, -1, -1):\n            dp[i + 1] += dp[i] * cnt[ord(ch) - ord('a')]\n            dp[i + 1] %= MOD\n    return dp[m]", "def is_palindrome(s, start, end):\n    while start < end:\n        if s[start] != s[end]:\n            return False\n        start += 1\n        end -= 1\n    return True\n\ndef check_partitioning(s):\n    n = len(s)\n    for i in range(0, n - 2):\n        if is_palindrome(s, 0, i):\n            for j in range(i + 1, n - 1):\n                if is_palindrome(s, i + 1, j) and is_palindrome(s, j + 1, n - 1):\n                    return True\n    return False", "def maxLengthBetweenEqualCharacters(s: str) -> int:\n    max_length = -1\n    char_index_map = {}\n\n    for i, char in enumerate(s):\n        if char in char_index_map:\n            max_length = max(max_length, i - char_index_map[char] - 1)\n        else:\n            char_index_map[char] = i\n\n    return max_length", "def bestTeamScore(scores, ages):\n    players = sorted(zip(ages, scores))\n    n = len(players)\n    dp = [0] * n\n    best_score = 0\n    \n    for i in range(n):\n        dp[i] = players[i][1]\n        for j in range(i):\n            if players[i][1] >= players[j][1]:\n                dp[i] = max(dp[i], dp[j] + players[i][1])\n        best_score = max(best_score, dp[i])\n    \n    return best_score", "def maxAbsoluteSum(nums):\n    max_sum = max_end = min_sum = min_end = 0\n    for num in nums:\n        max_end = max(max_end + num, num)\n        min_end = min(min_end + num, num)\n        max_sum = max(max_sum, max_end)\n        min_sum = min(min_sum, min_end)\n    return max(max_sum, -min_sum)", "def minimumLength(s: str) -> int:\n    if not s: return 0\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] != s[j]: break\n        remove_char = s[i]\n        while i < len(s) and s[i] == remove_char: i += 1\n        while j >= 0 and s[j] == remove_char: j -= 1\n    return max(0, j - i + 1)", "def slowestKey(releaseTimes, keysPressed):\n    max_key = keysPressed[0]\n    max_duration = releaseTimes[0]\n    for i in range(1, len(releaseTimes)):\n        duration = releaseTimes[i] - releaseTimes[i - 1]\n        if duration > max_duration or (duration == max_duration and keysPressed[i] > max_key):\n            max_key = keysPressed[i]\n            max_duration = duration\n    return max_key", "def check_arithmetic_subarrays(nums, l, r):\n    results = []\n    for i in range(len(l)):\n        subarray = sorted(nums[l[i]:r[i] + 1])\n        is_arithmetic = True\n        diff = subarray[1] - subarray[0]\n        for j in range(1, len(subarray) - 1):\n            if subarray[j + 1] - subarray[j] != diff:\n                is_arithmetic = False\n                break\n        results.append(is_arithmetic)\n    return results", "import heapq\nfrom typing import List\n\ndef minimumEffortPath(heights: List[List[int]]) -> int:\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    rows = len(heights)\n    cols = len(heights[0])\n    efforts = [[float('inf')] * cols for _ in range(rows)]\n\n    q = [(0, 0, 0)]\n    efforts[0][0] = 0\n    \n    while q:\n        effort, x, y = heapq.heappop(q)\n        \n        if x == rows - 1 and y == cols - 1:\n            return effort\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_effort = max(effort, abs(heights[nx][ny] - heights[x][y]))\n                if new_effort < efforts[nx][ny]:\n                    efforts[nx][ny] = new_effort\n                    heapq.heappush(q, (new_effort, nx, ny))\n    \n    return -1", "def largest_merge(word1: str, word2: str) -> str:\n    merge = []\n    while word1 or word2:\n        if word1 > word2:\n            merge.append(word1[0])\n            word1 = word1[1:]\n        else:\n            merge.append(word2[0])\n            word2 = word2[1:]\n    return ''.join(merge)", "def decrypt(code, k):\n    n = len(code)\n    result = [0] * n\n    if k == 0: return result\n    \n    for i in range(n):\n        sum = 0\n        for j in range(1, abs(k) + 1):\n            sum += code[(i + j) % n] if k > 0 else code[(i - j + n) % n]\n        result[i] = sum\n    return result", "def min_deletions(s: str) -> int:\n    a_count, deletions = 0, 0\n    for c in s:\n        if c == 'a':\n            a_count += 1\n        else:\n            if a_count > 0:\n                a_count -= 1\n            else:\n                deletions += 1\n    return deletions", "from typing import List\n\ndef canDistribute(nums: List[int], quantity: List[int]) -> bool:\n    counts = [0] * 51\n    for num in nums:\n        counts[num] += 1\n\n    quantity.sort(reverse=True)\n\n    def dfs(idx: int) -> bool:\n        if idx == len(quantity):\n            return True\n        for i in range(1, 51):\n            if counts[i] >= quantity[idx]:\n                counts[i] -= quantity[idx]\n                if dfs(idx + 1):\n                    return True\n                counts[i] += quantity[idx]\n        return False\n\n    return dfs(0)", "def count_homogenous(s: str) -> int:\n    MOD = 1000000007\n    count, total = 1, 0\n    for i in range(1, len(s)):\n        count = count + 1 if s[i] == s[i - 1] else 1\n        total = (total + count) % MOD\n    return (total + count) % MOD", "def can_form_array(arr, pieces):\n    piece_map = {piece[0]: piece for piece in pieces}\n    \n    i = 0\n    while i < len(arr):\n        if arr[i] not in piece_map:\n            return False\n        \n        for num in piece_map[arr[i]]:\n            if arr[i] != num:\n                return False\n            i += 1\n            \n    return True", "def count_vowel_strings(n):\n    dp = [1, 1, 1, 1, 1]\n\n    for i in range(1, n):\n        for j in range(3, -1, -1):\n            dp[j] += dp[j + 1]\n\n    return sum(dp)", "import heapq\n\ndef furthest_building(heights, bricks, ladders):\n    min_heap = []\n    for i in range(len(heights) - 1):\n        diff = heights[i + 1] - heights[i]\n        if diff > 0:\n            heapq.heappush(min_heap, diff)\n            if len(min_heap) > ladders:\n                bricks -= heapq.heappop(min_heap)\n                if bricks < 0:\n                    return i\n    return len(heights) - 1", "def longestNiceSubstring(s: str) -> str:\n    n = len(s)\n    result = \"\"\n    for i in range(n):\n        for j in range(i + 1, n):\n            is_nice = True\n            for ch in range(ord('A'), ord('Z') + 1):\n                upper = chr(ch) in s[i:j+1]\n                lower = chr(ch + 32) in s[i:j+1]\n                if (upper and not lower) or (not upper and lower):\n                    is_nice = False\n                    break\n            if is_nice and j - i + 1 > len(result):\n                result = s[i:j+1]\n    return result", "def max_k_repeating(sequence, word):\n    max_k = 0\n    seq_length = len(sequence)\n    word_length = len(word)\n    for i in range(seq_length - word_length + 1):\n        k = 0\n        while sequence[i:i + word_length * (k + 1)] == word * (k + 1):\n            k += 1\n        max_k = max(max_k, k)\n    return max_k", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef mergeInBetween(list1, a, b, list2):\n    prev, curr = None, list1\n    index = 0\n    \n    while curr:\n        if index == a:\n            last = list2\n            while last.next:\n                last = last.next\n            prev.next = list2\n            last.next = curr.next\n            break\n            \n        if index > a and index < b:\n            curr = curr.next\n        else:\n            prev = curr\n            curr = curr.next\n\n        index += 1\n\n    return list1", "from bisect import bisect_left\n\ndef minimum_mountain_removals(nums):\n    n = len(nums)\n    left, right = [0] * n, [0] * n\n    for i in range(n):\n        left[i] = bisect_left(left[:i], nums[i])\n        right[n - 1 - i] = bisect_left(right[n - i:], nums[n - 1 - i])\n\n    return n - max(left[i] + right[i] for i in range(1, n - 1)) - 1", "def mergeAlternately(word1: str, word2: str) -> str:\n    result = []\n    i, j = 0, 0\n    while i < len(word1) and j < len(word2):\n        result.append(word1[i])\n        result.append(word2[j])\n        i += 1\n        j += 1\n    result += word1[i:]\n    result += word2[j:]\n    return \"\".join(result)", "def maximum_generated(n: int) -> int:\n    if n == 0:\n        return 0\n    nums = [0] * (n + 1)\n    nums[1] = 1\n    for i in range(2, n + 1):\n        nums[i] = nums[i // 2] if i % 2 == 0 else nums[i // 2] + nums[i // 2 + 1]\n    return max(nums)", "def min_deletions(s):\n    freq = collections.Counter(s)\n    used = set()\n    deletions = 0\n\n    for count in freq.values():\n        while count in used and count > 0:\n            deletions += 1\n            count -= 1\n        used.add(count)\n\n    return deletions", "def maxProfit(inventory, orders):\n    mod = 10**9 + 7\n    inventory.sort(reverse=True)\n    inventory.append(0)\n    n, ans, count = len(inventory), 0, 1\n    for i in range(n - 1):\n        diff = inventory[i] - inventory[i + 1]\n        if count * diff < orders:\n            orders -= count * diff\n            ans = (ans + (((inventory[i] + inventory[i + 1] + 1) * diff) // 2) % mod * count) % mod\n        else:\n            q, r = divmod(orders, count)\n            ans = (ans + (((inventory[i] + inventory[i] - q + 1) * q) // 2) % mod * count) % mod\n            ans = (ans + r * (inventory[i] - q)) % mod\n            break\n        count += 1\n    return ans", "from sortedcontainers import SortedList\n\nMOD = int(1e9) + 7\n\ndef create_sorted_array(instructions):\n    s = SortedList()\n    cost = 0\n\n    for i in instructions:\n        less_than = s.bisect_left(i)\n        greater_than = len(s) - s.bisect_right(i)\n        cost = (cost + min(less_than, greater_than)) % MOD\n        s.add(i)\n\n    return cost", "def countMatches(items, ruleKey, ruleValue):\n    count = 0\n    index = {\"type\": 0, \"color\": 1, \"name\": 2}[ruleKey]\n    for item in items:\n        if item[index] == ruleValue:\n            count += 1\n    return count", "from itertools import product\n\ndef closest_cost(base_costs, topping_costs, target):\n    closest = float('inf')\n    topping_combinations = list(product([0, 1, 2], repeat=len(topping_costs)))\n    \n    for base in base_costs:\n        for combination in topping_combinations:\n            combination_cost = sum(x * y for x, y in zip(topping_costs, combination))\n            diff = abs(target - (base + combination_cost))\n            if diff < closest:\n                closest = diff\n            if diff == 0:\n                return target\n\n    return target - closest", "class OrderedStream:\n    def __init__(self, n: int):\n        self.ptr = 1\n        self.data = {}\n\n    def insert(self, idKey: int, value: str):\n        self.data[idKey] = value\n        result = []\n        while self.ptr in self.data:\n            result.append(self.data[self.ptr])\n            self.ptr += 1\n        return result", "def minOperations(nums, x):\n    total = sum(nums)\n    target = total - x\n    if target < 0:\n        return -1\n\n    maxLength = -1\n    left = 0\n    current_sum = 0\n\n    for right in range(len(nums)):\n        current_sum += nums[right]\n\n        while current_sum > target:\n            current_sum -= nums[left]\n            left += 1\n\n        if current_sum == target:\n            maxLength = max(maxLength, right - left + 1)\n\n    return -1 if maxLength == -1 else len(nums) - maxLength", "from functools import lru_cache\n\ndef getMaxGridHappiness(m, n, introvertsCount, extrovertsCount):\n    @lru_cache(None)\n    def maxHappy(y, mask):\n        if y == n:\n            return 0\n\n        ans = 0\n        for x in range(m + 1):\n            happiness = 0\n            if mask >> x & 1:\n                happiness -= 30\n                if x > 0 and mask & 1:\n                    happiness -= 30\n                else:\n                    happiness += 20\n            ans = max(ans, happiness + maxHappy(y + 1, (mask | (1 << x)) >> 1))\n\n        return ans\n\n    return maxHappy(0, 0)", "def nearestValidPoint(x: int, y: int, points: List[List[int]]) -> int:\n    min_distance = float(\"inf\")\n    index = -1\n    for i, point in enumerate(points):\n        if x == point[0] or y == point[1]:\n            distance = abs(x - point[0]) + abs(y - point[1])\n            if distance < min_distance:\n                min_distance = distance\n                index = i\n    return index", "def check_powers_of_three(n: int) -> bool:\n    while n > 0:\n        if n % 3 == 2:\n            return False\n        n //= 3\n    return True", "def arrayStringsAreEqual(word1, word2):\n    return \"\".join(word1) == \"\".join(word2)", "def get_smallest_string(n: int, k: int) -> str:\n    result = ['a'] * n\n    k -= n\n    idx = n - 1\n    while k > 0:\n        value = min(k, 25)\n        result[idx] = chr(ord(result[idx]) + value)\n        k -= value\n        idx -= 1\n    return ''.join(result)", "def minimum_energy(tasks):\n    tasks.sort(key=lambda task: task[1] - task[0], reverse=True)\n\n    energy = 0\n    for task in tasks:\n        energy = max(energy + task[0], task[1])\n    return energy", "def minElements(nums, limit, goal):\n    sum_nums = sum(nums)\n    diff = abs(goal - sum_nums)\n    \n    return (diff + limit - 1) // limit", "def count_consistent_strings(allowed, words):\n    allowed_set = set(allowed)\n    count = 0\n    for word in words:\n        is_valid = True\n        for c in word:\n            if c not in allowed_set:\n                is_valid = False\n                break\n        if is_valid:\n            count += 1\n    return count", "def calculate_summation_of_absolute_differences(nums):\n    n = len(nums)\n    result = [0] * n\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                result[i] += abs(nums[i] - nums[j])\n\n    return result", "def stoneGameVI(aliceValues, bobValues):\n    n = len(aliceValues)\n    sums = sorted([(aliceValues[i] + bobValues[i], i) for i in range(n)], reverse=True)\n    \n    aliceScore = sum(aliceValues[i] for _, i in sums[::2])\n    bobScore = sum(bobValues[i] for _, i in sums[1::2])\n    \n    return 0 if aliceScore == bobScore else 1 if aliceScore > bobScore else -1", "def are_almost_equal(s1, s2):\n    if s1 == s2:\n        return True\n    diff = [i for i in range(len(s1)) if s1[i] != s2[i]]\n    return len(diff) == 2 and s1[diff[0]] == s2[diff[1]] and s1[diff[1]] == s2[diff[0]]", "def maximum_wealth(accounts):\n    return max(sum(customer) for customer in accounts)", "def most_competitive(nums, k):\n    stack = []\n    n = len(nums)\n\n    for i in range(n):\n        while stack and nums[i] < stack[-1] and len(stack) + n - i > k:\n            stack.pop()\n        if len(stack) < k:\n            stack.append(nums[i])\n\n    return stack", "def min_moves(nums, limit):\n    n = len(nums)\n    delta = [0] * (2 * limit + 2)\n\n    for i in range(n // 2):\n        lo = min(nums[i], nums[n - 1 - i]) + 1\n        hi = max(nums[i], nums[n - 1 - i]) + limit\n        delta[lo] -= 1\n        delta[nums[i] + nums[n - 1 - i]] -= 1\n        delta[hi + 1] += 1\n\n    moves, current = n, n\n    for i in range(2, 2 * limit + 1):\n        current += delta[i]\n        moves = min(moves, current)\n\n    return moves", "import heapq\n\ndef minimum_deviation(nums):\n    pq = []\n    min_val = float(\"inf\")\n\n    for num in nums:\n        if num % 2 == 0:\n            heapq.heappush(pq, -num)\n        else:\n            heapq.heappush(pq, -(num * 2))\n        min_val = min(min_val, num)\n\n    result = float(\"inf\")\n    while True:\n        top = -heapq.heappop(pq)\n        result = min(result, top - min_val)\n\n        if top % 2 == 1:\n            break\n        heapq.heappush(pq, -(top // 2))\n        min_val = min(min_val, top // 2)\n\n    return result", "def second_highest(s: str) -> int:\n    largest = -1\n    second_largest = -1\n    for c in s:\n        if c.isdigit():\n            d = int(c)\n            if d > largest:\n                second_largest = largest\n                largest = d\n            elif d < largest and d > second_largest:\n                second_largest = d\n    return second_largest", "def interpret(command: str) -> str:\n    result = []\n    i = 0\n    while i < len(command):\n        if command[i] == \"G\":\n            result.append(\"G\")\n            i += 1\n        elif command[i:i+2] == \"()\":\n            result.append(\"o\")\n            i += 2\n        else:\n            result.append(\"al\")\n            i += 4\n    return \"\".join(result)", "def maxOperations(nums, k):\n    count = {}\n    operations = 0\n\n    for num in nums:\n        if count.get(k - num, 0) > 0:\n            count[k - num] -= 1\n            operations += 1\n        else:\n            count[num] = count.get(num, 0) + 1\n\n    return operations", "from typing import List\n\ndef minimumIncompatibility(nums: List[int], k: int) -> int:\n    n = len(nums)\n    if n % k != 0:\n        return -1\n    \n    nums.sort()\n    diffs = [nums[(i + 1) * (n // k) - 1] - nums[i * (n // k)] for i in range(k)]\n    \n    return sum(diffs)", "def concatenated_binary(n: int) -> int:\n    result = 0\n    mod = 1000000007\n    for i in range(1, n + 1):\n        length = len(bin(i)) - 2\n        result = ((result << length) % mod + i) % mod\n    return result", "from heapq import *\n\ndef getNumberOfBacklogOrders(orders):\n    buy_orders, sell_orders = [], []\n    num_orders, mod = 0, int(1e9) + 7\n\n    for price, amount, order_type in orders:\n        if order_type == 0: # buy order\n            while amount and sell_orders and sell_orders[0][0] <= price:\n                x = min(amount, sell_orders[0][1])\n                amount, sell_orders[0][1] = amount - x, sell_orders[0][1] - x\n                if sell_orders[0][1] == 0:\n                    heappop(sell_orders)\n            if amount:\n                heappush(buy_orders, (-price, amount))\n        else: # sell order\n            while amount and buy_orders and -buy_orders[0][0] >= price:\n                x = min(amount, buy_orders[0][1])\n                amount, buy_orders[0][1] = amount - x, buy_orders[0][1] - x\n                if buy_orders[0][1] == 0:\n                    heappop(buy_orders)\n            if amount:\n                heappush(sell_orders, (price, amount))\n    \n    while buy_orders:\n        num_orders = (num_orders + heappop(buy_orders)[1]) % mod\n\n    while sell_orders:\n        num_orders = (num_orders + heappop(sell_orders)[1]) % mod\n\n    return num_orders", "from collections import deque\n\ndef countStudents(students, sandwiches):\n    queue = deque(students)\n    index, attempts = 0, 0\n\n    while queue:\n        student = queue[0]\n        if student == sandwiches[index]:\n            queue.popleft()\n            index += 1\n            attempts = 0\n        else:\n            queue.rotate(-1)\n            attempts += 1\n\n        if attempts == len(queue):\n            break\n\n    return len(queue)", "def average_waiting_time(customers):\n    wait_time = 0\n    curr_time = 0\n    \n    for arrival, time in customers:\n        curr_time = max(curr_time, arrival) + time\n        wait_time += curr_time - arrival\n    \n    return wait_time / len(customers)", "def min_moves(nums, k):\n    n = len(nums)\n    ones = [i - j for i, j in enumerate(nums) if j == 1]\n    \n    moves = sum(ones[i] - ones[k // 2] for i in range(k))\n    min_moves = moves\n    \n    for i in range(k, len(ones)):\n        moves += ones[i] - ones[i - k] - k\n        min_moves = min(min_moves, moves)\n    \n    return min_moves", "def numberOfMatches(n):\n    return n - 1", "def minPartitions(n: str) -> int:\n    max_digit = 0\n    for c in n:\n        max_digit = max(max_digit, int(c))\n        if max_digit == 9:\n            break\n    return max_digit", "def stoneGame(stones):\n    n = len(stones)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            dp[i][j] = max(stones[j] - dp[i][j - 1], stones[i] - dp[i + 1][j])\n    \n    return dp[0][n - 1]", "class Solution:\n    def findShortestPath(self, master: 'GridMaster') -> int:\n        def dfs(master, x, y):\n            nonlocal target\n            if master.isTarget():\n                target = (x, y)\n            for i in range(4):\n                nx, ny = x + dirs[i], y + dirs[i + 1]\n                if (nx, ny) in grid:\n                    continue\n                if master.canMove(DIR_CHAR[i]):\n                    cost = master.move(DIR_CHAR[i])\n                    grid[(nx, ny)] = cost\n                    dfs(master, nx, ny)\n                    master.move(OPPOSITE_DIR_CHAR[i])\n                    \n        def bfs():\n            q = deque([(0, 0)])\n            grid[(0, 0)] = 0\n            while q:\n                x, y = q.popleft()\n                for i in range(4):\n                    nx, ny = x + dirs[i], y + dirs[i + 1]\n                    cost = grid[(x, y)] + grid.get((nx, ny), 0)\n                    if (nx, ny) in grid and grid[(nx, ny)] > cost:\n                        grid[(nx, ny)] = cost\n                        if (nx, ny) != target:\n                            q.append((nx, ny))\n            return grid.get(target, -1)\n        \n        dirs = [-1, 0, 1, 0, -1]\n        DIR_CHAR = \"URDL\"\n        OPPOSITE_DIR_CHAR = \"DLUR\"\n        grid = {}\n        target = None\n        \n        dfs(master, 0, 0)\n        if target is None:\n            return -1\n        \n        return bfs()", "def reformat_number(number):\n    cleaned_number = ''.join(c for c in number if c.isdigit())\n\n    blocks = []\n    n = len(cleaned_number)\n    i = 0\n    while i < n:\n        if n - i == 2 or n - i == 4:\n            blocks.append(cleaned_number[i:i + 2])\n            i += 2\n        else:\n            blocks.append(cleaned_number[i:i + 3])\n            i += 3\n\n    return '-'.join(blocks)", "def maximum_unique_subarray(nums):\n    max_sum, current_sum, left = 0, 0, 0\n    elements = set()\n    \n    for right in range(len(nums)):\n        while nums[right] in elements:\n            elements.remove(nums[left])\n            current_sum -= nums[left]\n            left += 1\n        \n        elements.add(nums[right])\n        current_sum += nums[right]\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "from collections import deque\n\ndef maxResult(nums, k):\n    n = len(nums)\n    dq = deque()\n    dp = [0] * n\n    \n    dp[0] = nums[0]\n    dq.append(0)\n    \n    for i in range(1, n):\n        while dq and dq[0] < i - k:\n            dq.popleft()\n        \n        dp[i] = nums[i] + dp[dq[0]]\n        \n        while dq and dp[i] >= dp[dq[-1]]:\n            dq.pop()\n        \n        dq.append(i)\n    \n    return dp[-1]", "from typing import List\n\ndef distanceLimitedPathsExist(n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\n    edgeList.sort(key=lambda x: x[2])\n    queries = sorted(enumerate(queries), key=lambda x: x[1][2])\n\n    def find(x: int, parent: List[int]) -> int:\n        if x != parent[x]:\n            parent[x] = find(parent[x], parent)\n        return parent[x]\n\n    parent = list(range(n))\n    res = [False] * len(queries)\n    idx = 0\n\n    for query_id, query in queries:\n        p, q, limit = query\n        while idx < len(edgeList) and edgeList[idx][2] < limit:\n            u, v = edgeList[idx][:2]\n            ru, rv = find(u, parent), find(v, parent)\n            if ru != rv:\n                parent[ru] = rv\n            idx += 1\n        res[query_id] = find(p, parent) == find(q, parent)\n\n    return res", "def truncateSentence(s: str, k: int) -> str:\n    words = s.split()\n    return \" \".join(words[:k])", "def total_money(n):\n    weeks = n // 7\n    days_remaining = n % 7\n    return 28 * weeks + 7 * weeks * (weeks - 1) // 2 + (weeks + 1) * days_remaining + days_remaining * (days_remaining - 1) // 2", "def max_points(s, x, y):\n    points = 0\n    s = list(s)\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            points += max(x, y)\n            s[i] = '#'\n    return points", "def largest_lex_sequence(n: int) -> list[int]:\n    res = [0] * n\n    for i in range(n):\n        res[i] = i % 2\n    return res", "def count_trees(pairs):\n    nodes = len(pairs) + 1\n    in_degrees = [0] * nodes\n    for x, y in pairs:\n        in_degrees[y] += 1\n    \n    res = 1\n    for in_degree in in_degrees[1:]:\n        res *= in_degree\n    \n    return res", "def signFunc(x):\n    if x > 0:\n        return 1\n    elif x < 0:\n        return -1\n    else:\n        return 0\n\ndef arraySign(nums):\n    product = 1\n    for num in nums:\n        product *= signFunc(num)\n    return product", "def halves_are_alike(s: str) -> bool:\n    half_length = len(s) // 2\n    count_a, count_b = 0, 0\n\n    for i in range(half_length):\n        if s[i] in \"aeiouAEIOU\": count_a += 1\n\n    for i in range(half_length, len(s)):\n        if s[i] in \"aeiouAEIOU\": count_b += 1\n\n    return count_a == count_b", "import heapq\n\ndef eatenApples(apples, days):\n    n = len(apples)\n    pq = []\n    ans = 0\n\n    for i in range(n + 1):\n        if i < n and apples[i] > 0:\n            heapq.heappush(pq, (i + days[i], apples[i]))\n\n        while pq and pq[0][0] <= i:\n            heapq.heappop(pq)\n\n        if pq:\n            ans += 1\n            curr_apple = heapq.heappop(pq)\n            if curr_apple[1] > 1:\n                heapq.heappush(pq, (curr_apple[0], curr_apple[1] - 1))\n\n    return ans", "def minimum_working_time(jobs, k):\n    max_job = max(jobs)\n    sum_jobs = sum(jobs)\n    \n    left, right = max_job, sum_jobs\n    while left < right:\n        mid = left + (right - left) // 2\n        count, current_sum = 1, 0\n\n        for job in jobs:\n            if current_sum + job > mid:\n                count += 1\n                current_sum = 0\n            current_sum += job\n\n        if count <= k:\n            right = mid\n        else:\n            left = mid + 1\n\n    return left", "def maximizeXor(nums, queries):\n    trie = {}\n    nums.sort()\n\n    new_queries = sorted([(x, m, i) for i, (x, m) in enumerate(queries)], key=lambda x: x[1])\n\n    ans = [0] * len(queries)\n\n    idx = 0\n    for x, m, i in new_queries:\n        while idx < len(nums) and nums[idx] <= m:\n            t = nums[idx]\n            idx += 1\n            cur = trie\n            for j in range(31, -1, -1):\n                bit = (t >> j) & 1\n                cur = cur.setdefault(bit, {})\n        cur = trie\n        xor_value = 0\n        for j in range(31, -1, -1):\n            bit = (x >> j) & 1\n            if 1 ^ bit in cur:\n                cur = cur[1 ^ bit]\n                xor_value |= 1 << j\n            else:\n                cur = cur[bit]\n        ans[i] = xor_value if cur else -1\n\n    return ans", "def min_operations(nums):\n    operations = 0\n    for i in range(1, len(nums)):\n        if nums[i] <= nums[i - 1]:\n            operations += (nums[i - 1] - nums[i]) + 1\n            nums[i] = nums[i - 1] + 1\n    return operations", "def countPoints(points, queries):\n    answer = []\n    for query in queries:\n        inside = 0\n        for point in points:\n            dx = point[0] - query[0]\n            dy = point[1] - query[1]\n            if dx * dx + dy * dy <= query[2] * query[2]:\n                inside += 1\n        answer.append(inside)\n    return answer", "def maximumUnits(boxTypes, truckSize):\n    boxTypes.sort(key=lambda x: x[1], reverse=True)\n    \n    totalUnits = 0\n    for box in boxTypes:\n        boxCount = min(truckSize, box[0])\n        totalUnits += boxCount * box[1]\n        truckSize -= boxCount\n        if truckSize == 0:\n            break\n    \n    return totalUnits", "from collections import defaultdict\n\ndef countPairs(deliciousness):\n    MOD = 10**9 + 7\n    hashMap = defaultdict(int)\n    maxVal = max(deliciousness)\n    maxSum = maxVal * 2\n\n    count = 0\n    for val in deliciousness:\n        for sum in (1 << i for i in range(22)):\n            count = (count + hashMap[sum - val]) % MOD\n        hashMap[val] += 1\n\n    return count", "from bisect import bisect_left\n\ndef min_operations(target, arr):\n    index_map = {num: i for i, num in enumerate(target)}\n\n    lis = []\n    for num in arr:\n        if num in index_map:\n            pos = bisect_left(lis, index_map[num])\n            if pos == len(lis):\n                lis.append(index_map[num])\n            else:\n                lis[pos] = index_map[num]\n\n    return len(target) - len(lis)", "def largestAltitude(gain):\n    max_altitude, current_altitude = 0, 0\n    for i in gain:\n        current_altitude += i\n        max_altitude = max(max_altitude, current_altitude)\n    return max_altitude", "def minimum_teachings(n, languages, friendships):\n    language_users = {}\n    unconnected_users = set()\n\n    for u, v in friendships:\n        can_communicate = any(lang in languages[v-1] for lang in languages[u-1])\n        if not can_communicate:\n            unconnected_users.add(u)\n            unconnected_users.add(v)\n\n    res = len(unconnected_users)\n    for i in range(1, n+1):\n        cnt = sum(i not in languages[user-1] for user in unconnected_users)\n        res = min(res, cnt)\n\n    return res", "def decode(encoded):\n    n = len(encoded) + 1\n    total_xor = 0\n    for i in range(1, n + 1):\n        total_xor ^= i\n    encoded_xor = 0\n    for i in range(1, n - 1, 2):\n        encoded_xor ^= encoded[i]\n    perm = [total_xor ^ encoded_xor]\n    for i in range(1, n):\n        perm.append(perm[-1] ^ encoded[i - 1])\n    return perm", "from collections import defaultdict\nfrom typing import List\n\nMOD = 10**9 + 7\n\ndef product_ways(queries: List[List[int]]) -> List[int]:\n    res = []\n    for n, k in queries:\n        pf = []\n        pm = defaultdict(int)\n\n        i = 2\n        while i * i <= k:\n            cnt = 0\n            while k % i == 0:\n                cnt += 1\n                k //= i\n            if cnt:\n                pf.append(cnt)\n                pm[cnt] += 1\n            i += 1\n\n        if k > 1:\n            pm[k] += 1\n            pf.append(1)\n\n        ans = 1\n        for p in pf:\n            ans = (ans * (p * (n - 1) + 1)) % MOD\n\n        res.append(ans)\n    return res", "def sum_base(n: int, k: int) -> int:\n    s = 0\n    while n:\n        s += n % k\n        n //= k\n    return s", "def maxFrequency(nums: List[int], k: int) -> int:\n    nums.sort()\n    n, i, s, max_freq = len(nums), 0, 0, 0\n\n    for j in range(n):\n        s += nums[j]\n        while s + k < nums[j] * (j - i + 1):\n            s -= nums[i]\n            i += 1\n        max_freq = max(max_freq, j - i + 1)\n\n    return max_freq", "def decode(encoded, first):\n    arr = [first]\n    for num in encoded:\n        arr.append(arr[-1] ^ num)\n    return arr", "from collections import defaultdict\n\ndef dfs(node, visited, graph, group):\n    if visited[node]:\n        return\n    visited[node] = 1\n    group.append(node)\n    for neighbor in graph[node]:\n        dfs(neighbor, visited, graph, group)\n\ndef minimumHammingDistance(source, target, allowedSwaps):\n    n = len(source)\n    graph = defaultdict(list)\n    for a, b in allowedSwaps:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    res = 0\n    visited = [0] * n\n    for i in range(n):\n        if not visited[i]:\n            group = []\n            dfs(i, visited, graph, group)\n            count = defaultdict(int)\n\n            for node in group:\n                count[source[node]] += 1\n            for node in group:\n                if count[target[node]] > 0:\n                    res += 1\n                    count[target[node]] -= 1\n\n    return n - res", "from itertools import permutations\n\ndef nextPalindrome(num: str) -> str:\n    n = len(num)\n    first_half = num[:(n + 1) // 2]\n    candidates = sorted(set(int(\"\".join(p)) for p in permutations(first_half)))\n\n    for c in candidates:\n        c_str = str(c)\n        second_half = c_str[::-1]\n        if n % 2 == 1: second_half = second_half[1:]\n        candidate_str = c_str + second_half\n\n        if candidate_str > num:\n            return candidate_str\n\n    return \"\"", "def count_balls(low_limit: int, high_limit: int) -> int:\n    box_counts = [0] * 46\n    for i in range(low_limit, high_limit + 1):\n        box_number = sum(map(int, str(i)))\n        box_counts[box_number] += 1\n    return max(box_counts)", "def largestSubmatrix(matrix):\n    m, n = len(matrix), len(matrix[0])\n    height = [0] * n\n    max_area = 0\n\n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 1:\n                height[j] += 1\n            else:\n                height[j] = 0\n        sorted_height = sorted(height)\n        for j in range(n):\n            max_area = max(max_area, sorted_height[j] * (n - j))\n\n    return max_area", "def maximumElementAfterDecrementingAndRearranging(arr: List[int]) -> int:\n    arr.sort()\n    arr[0] = 1\n    for i in range(1, len(arr)):\n        arr[i] = min(arr[i], arr[i - 1] + 1)\n    return arr[-1]", "def sum_of_unique_elements(nums):\n    elem_count = {}\n    for num in nums:\n        elem_count[num] = elem_count.get(num, 0) + 1\n    sum = 0\n    for elem, count in elem_count.items():\n        if count == 1:\n            sum += elem\n    return sum", "def maxAbsoluteSum(nums):\n    max_sum, min_sum, max_so_far, min_so_far = 0, 0, 0, 0\n    for num in nums:\n        max_so_far = max(num, max_so_far + num)\n        max_sum = max(max_sum, max_so_far)\n\n        min_so_far = min(num, min_so_far + num)\n        min_sum = min(min_sum, min_so_far)\n    return max(max_sum, abs(min_sum))", "def min_length_after_operations(s: str) -> int:\n    a_count = s.count('a')\n    b_count = s.count('b')\n    c_count = s.count('c')\n\n    if a_count % 2 == b_count % 2 and b_count % 2 == c_count % 2:\n        return len(s) % 2\n    return (len(s) + 1) % 2", "from bisect import bisect_left\n\ndef maxValue(events, k):\n    events.sort(key=lambda x: x[1])\n    n = len(events)\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        start = -1\n        for j in range(i - 1, 0, -1):\n            if events[j - 1][1] < events[i - 1][0]:\n                start = j\n                break\n\n        for j in range(1, k + 1):\n            if start == -1:\n                dp[i][j] = max(dp[i - 1][j], events[i - 1][2])\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[start][j - 1] + events[i - 1][2])\n\n    return dp[n][k]", "def distinct_numbers_in_subarrays(nums, k):\n    counts = {}\n    ans = []\n    for i, num in enumerate(nums):\n        counts[num] = counts.get(num, 0) + 1\n        if i >= k:\n            counts[nums[i - k]] -= 1\n            if counts[nums[i - k]] == 0:\n                del counts[nums[i - k]]\n        if i >= k - 1:\n            ans.append(len(counts))\n    return ans", "def maxAliveYear(logs):\n    years = [0] * 101\n    for log in logs:\n        years[log[0] - 1950] += 1\n        years[log[1] - 1950] -= 1\n    max_population = years[0]\n    max_year = 1950\n    for i in range(1, 101):\n        years[i] += years[i - 1]\n        if years[i] > max_population:\n            max_population = years[i]\n            max_year = i + 1950\n    return max_year", "def maxDistance(nums1, nums2):\n    i, j, maxDist = 0, 0, 0\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] > nums2[j]:\n            i += 1\n        else:\n            maxDist = max(maxDist, j - i)\n            j += 1\n    return maxDist", "def maxSumMinProduct(nums: list[int]) -> int:\n    MOD = int(1e9 + 7)\n    max_product = 0\n    stk = []\n    prefix_sum = [0] * (len(nums) + 1)\n\n    for i in range(len(nums)):\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n\n    for i in range(len(nums)):\n        while stk and nums[stk[-1]] > nums[i]:\n            min_val = nums[stk.pop()]\n            max_product = max(max_product, min_val * (prefix_sum[i] - prefix_sum[stk[-1] + 1 if stk else 0]))\n        stk.append(i)\n       \n    while stk:\n        min_val = nums[stk.pop()]\n        max_product = max(max_product, min_val * (prefix_sum[len(nums)] - prefix_sum[stk[-1] + 1 if stk else 0]))\n\n    return max_product % MOD", "from collections import deque\n\ndef largestPathValue(colors: str, edges: List[List[int]]) -> int:\n    n = len(colors)\n    adj = [[] for _ in range(n)]\n    \n    in_degrees = [0] * n\n    for e in edges:\n        adj[e[0]].append(e[1])\n        in_degrees[e[1]] += 1\n        \n    color_counts = [[0] * 26 for _ in range(n)]\n    queue = deque()\n    \n    for i in range(n):\n        if in_degrees[i] == 0:\n            queue.append(i)\n            \n    visited_nodes = 0\n    max_color_value = 0\n    \n    while queue:\n        node = queue.pop()\n        color = ord(colors[node]) - ord('a')\n        visited_nodes += 1\n        \n        for neighbor in adj[node]:\n            for c in range(26):\n                count = color_counts[node][c] + (c == color)\n                color_counts[neighbor][c] = max(color_counts[neighbor][c], count)\n                max_color_value = max(max_color_value, count)\n                \n            in_degrees[neighbor] -= 1\n            if in_degrees[neighbor] == 0:\n                queue.append(neighbor)\n                \n    return max_color_value if visited_nodes == n else -1", "def maximum_time(time: str) -> str:\n    time = list(time)\n    if time[0] == \"?\":\n        time[0] = \"2\" if time[1] == \"?\" or int(time[1]) < 4 else \"1\"\n    if time[1] == \"?\":\n        time[1] = \"3\" if time[0] == \"2\" else \"9\"\n    if time[3] == \"?\":\n        time[3] = \"5\"\n    if time[4] == \"?\":\n        time[4] = \"9\"\n    return \"\".join(time)", "def min_operations_to_satisfy_conditions(a: str, b: str) -> int:\n    same, less, greater = 0, 0, 0\n\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            same += 1\n        elif a[i] < b[i]:\n            less += 1\n        else:\n            greater += 1\n\n    return min(same + max(less, greater), less, greater)", "import heapq\n\ndef kthLargestValue(matrix, k):\n    m, n = len(matrix), len(matrix[0])\n    prefix_xor = [[0] * (n + 1) for _ in range(m + 1)]\n    pq = []\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            prefix_xor[i][j] = matrix[i - 1][j - 1] ^ prefix_xor[i - 1][j] ^ prefix_xor[i][j - 1] ^ prefix_xor[i - 1][j - 1]\n            heapq.heappush(pq, prefix_xor[i][j])\n            if len(pq) > k:\n                heapq.heappop(pq)\n    return pq[0]", "def min_boxes_touching_floor(n):\n    return (n + 1) // 2", "def sum_of_floored_pairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    max_element = max(nums)\n    cnt = [0] * (max_element + 1)\n    for num in nums:\n        cnt[num] += 1\n    for i in range(1, max_element + 1):\n        cnt[i] += cnt[i - 1]\n\n    res = 0\n    for num in nums:\n        j, k = 1, 1\n        while k <= max_element:\n            res += j * (cnt[min(k + num - 1, max_element)] - cnt[k - 1])\n            res %= MOD\n            j += 1\n            k += num\n\n    return res", "def subsetXORSum(nums):\n    ans = 0\n    n = len(nums)\n    max_val = 1 << n\n    for i in range(1, max_val):\n        xor_total = 0\n        for j in range(n):\n            if i & (1 << j):\n                xor_total ^= nums[j]\n        ans += xor_total\n    return ans", "def minSwaps(s):\n    zeroCount = s.count('0')\n    oneCount = len(s) - zeroCount\n\n    if abs(zeroCount - oneCount) > 1:\n        return -1\n\n    swaps1 = swaps2 = 0\n    for i, c in enumerate(s):\n        if i % 2 == 0 and c != '0':\n            swaps1 += 1\n        if i % 2 == 1 and c != '1':\n            swaps1 += 1\n    swaps1 = swaps1 // 2\n\n    for i, c in enumerate(s):\n        if i % 2 == 0 and c != '1':\n            swaps2 += 1\n        if i % 2 == 1 and c != '0':\n            swaps2 += 1\n    swaps2 = swaps2 // 2\n\n    if zeroCount == oneCount:\n        return min(swaps1, swaps2)\n    return swaps2 if zeroCount > oneCount else swaps1", "from collections import defaultdict\n\nclass FindSumPairs:\n    def __init__(self, nums1: list[int], nums2: list[int]):\n        self.nums1 = nums1\n        self.nums2 = nums2\n        self.nums2_map = defaultdict(int)\n        for num in nums2:\n            self.nums2_map[num] += 1\n\n    def add(self, index: int, val: int) -> None:\n        self.nums2_map[self.nums2[index]] -= 1\n        self.nums2[index] += val\n        self.nums2_map[self.nums2[index]] += 1\n\n    def count(self, tot: int) -> int:\n        return sum(self.nums2_map.get(tot - num, 0) for num in self.nums1)", "from collections import defaultdict\n\ndef restoreArray(adjacentPairs):\n    graph = defaultdict(list)\n    for pair in adjacentPairs:\n        graph[pair[0]].append(pair[1])\n        graph[pair[1]].append(pair[0])\n\n    n = len(graph)\n    nums = [0] * n\n    for key, nodes in graph.items():\n        if len(nodes) == 1:\n            nums[0] = key\n            break\n\n    nums[1] = graph[nums[0]][0]\n    for i in range(2, n):\n        nums[i] = (graph[nums[i - 1]][1]\n                   if (nums[i - 2] == graph[nums[i - 1]][0])\n                   else graph[nums[i - 1]][0])\n\n    return nums", "def findRLEProduct(encoded1, encoded2):\n    result = []\n    i, j, count1, count2 = 0, 0, 0, 0\n\n    while i < len(encoded1) and j < len(encoded2):\n        product = encoded1[i][0] * encoded2[j][0]\n        count = min(encoded1[i][1] - count1, encoded2[j][1] - count2)\n        count1 += count\n        count2 += count\n\n        if result and result[-1][0] == product:\n            result[-1][1] += count\n        else:\n            result.append([product, count])\n\n        if count1 == encoded1[i][1]:\n            i += 1\n            count1 = 0\n\n        if count2 == encoded2[j][1]:\n            j += 1\n            count2 = 0\n\n    return result", "def checkZeroOnes(s: str) -> bool:\n    max_ones, max_zeros, current_ones, current_zeros = 0, 0, 0, 0\n    for c in s:\n        if c == '1':\n            current_ones += 1\n            current_zeros = 0\n        else:\n            current_zeros += 1\n            current_ones = 0\n        max_ones = max(max_ones, current_ones)\n        max_zeros = max(max_zeros, current_zeros)\n    return max_ones > max_zeros", "from math import ceil\n\ndef minSpeedOnTime(dist, hour):\n    max_time = hour - len(dist) + 1\n    lower, upper = 1.0, 1e7\n    while upper - lower >= 1e-9:\n        mid = (lower + upper) / 2\n        time_taken = sum(ceil(d / mid) - (0 if i == len(dist) - 1 else 1) for i, d in enumerate(dist))\n        if time_taken <= max_time:\n            upper = mid\n        else:\n            lower = mid\n    return ceil(lower) if lower <= 1e7 else -1", "def is_palindrome(s, l, r):\n    while l < r:\n        if s[l] != s[r]:\n            return False\n        l += 1\n        r -= 1\n    return True\n\ndef check_partitioning(s):\n    n = len(s)\n    for i in range(n - 2):\n        if is_palindrome(s, 0, i):\n            for j in range(i + 1, n - 1):\n                if is_palindrome(s, i + 1, j) and is_palindrome(s, j + 1, n - 1):\n                    return True\n    return False", "def can_eat(candiesCount, queries):\n    prefix_sum = [0] * (len(candiesCount) + 1)\n    for i in range(len(candiesCount)):\n        prefix_sum[i + 1] = prefix_sum[i] + candiesCount[i]\n\n    result = [False] * len(queries)\n    for i in range(len(queries)):\n        favoriteType, favoriteDay, dailyCap = queries[i]\n        x1 = favoriteDay + 1\n        y1 = (favoriteDay + 1) * dailyCap\n\n        x2 = prefix_sum[favoriteType] + 1\n        y2 = prefix_sum[favoriteType + 1]\n\n        result[i] = not (x1 > y2 or y1 < x2)\n\n    return result", "def can_choose(groups, nums):\n    g_i, n_i = 0, 0\n    while g_i < len(groups) and n_i + len(groups[g_i]) <= len(nums):\n        if nums[n_i : n_i + len(groups[g_i])] == groups[g_i]:\n            n_i += len(groups[g_i])\n            g_i += 1\n        else:\n            n_i += 1\n    return g_i == len(groups)", "from collections import deque\n\ndef highest_island(is_water):\n    m, n = len(is_water), len(is_water[0])\n    height = [[-1] * n for _ in range(m)]\n    q = deque()\n\n    for i in range(m):\n        for j in range(n):\n            if is_water[i][j] == 1:\n                height[i][j] = 0\n                q.append((i, j))\n\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n\n    while q:\n        x, y = q.popleft()\n\n        for i in range(4):\n            newX = x + dx[i]\n            newY = y + dy[i]\n\n            if 0 <= newX < m and 0 <= newY < n and height[newX][newY] == -1:\n                height[newX][newY] = height[x][y] + 1\n                q.append((newX, newY))\n\n    return height", "def minPairSum(nums):\n    nums.sort()\n    max_sum = 0\n    for i in range(len(nums) // 2):\n        max_sum = max(max_sum, nums[i] + nums[-1 - i])\n    return max_sum", "def check(nums):\n    count = 0\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i - 1]:\n            count += 1\n        if count > 1:\n            return False\n    return count == 1 or nums[0] >= nums[-1]", "def max_score(a: int, b: int, c: int) -> int:\n    return (a + b + c - max(a, b, c)) // 2", "def largest_merge(word1: str, word2: str) -> str:\n    merge = []\n    while word1 or word2:\n        if word1 > word2:\n            merge.append(word1[0])\n            word1 = word1[1:]\n        else:\n            merge.append(word2[0])\n            word2 = word2[1:]\n    return ''.join(merge)", "from itertools import combinations\n\ndef minAbsDifference(nums, goal):\n    n = len(nums)\n    left = nums[:n//2]\n    right = nums[n//2:]\n\n    sums_left = set()\n\n    for i in range(len(left) + 1):\n        for comb in combinations(left, i):\n            sums_left.add(sum(comb))\n\n    ans = abs(goal)\n\n    for i in range(len(right) + 1):\n        for comb in combinations(right, i):\n            sum_r = sum(comb)\n            sum_goal = goal - sum_r\n            sum_l = min(sums_left, key=lambda x: abs(x - sum_goal))\n\n            ans = min(ans, abs(sum_l + sum_r - goal))\n\n    return ans", "import heapq\nfrom typing import List\n\ndef assignTasks(servers: List[int], tasks: List[int]) -> List[int]:\n    free_servers = [(servers[i], i) for i in range(len(servers))]\n    heapq.heapify(free_servers)\n    busy_servers = []\n    result = [0] * len(tasks)\n\n    for time in range(len(tasks)):\n        while busy_servers and busy_servers[0][0] <= time:\n            _, server_elem = heapq.heappop(busy_servers)\n            heapq.heappush(free_servers, server_elem)\n        \n        if free_servers:\n            server_elem = heapq.heappop(free_servers)\n            result[time] = server_elem[1]\n            heapq.heappush(busy_servers, (time + tasks[time], server_elem))\n\n    return result", "def minSkips(dist, speed, hoursBefore):\n    n = len(dist)\n    dp = [[1e9] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(n):\n        for j in range(i+1):\n            t = dist[i] / speed + (1 if j else 0)\n            dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j] + t)\n            skipped_t = -(-dist[i] / speed) - dp[i][j]\n            dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + skipped_t)\n\n    for i in range(n + 1):\n        if dp[n][i] <= hoursBefore:\n            return i\n    return -1", "def min_operations_to_alternate(s: str) -> int:\n    count_a, count_b = 0, 0\n    for i, c in enumerate(s):\n        if i % 2 == 0:\n            if c == '0':\n                count_a += 1\n            else:\n                count_b += 1\n        else:\n            if c == '0':\n                count_b += 1\n            else:\n                count_a += 1\n    return min(count_a, count_b)", "def count_homogenous(s: str) -> int:\n    res, count, mod = 0, 1, 10**9 + 7\n    for i in range(1, len(s)):\n        count = count + 1 if s[i] == s[i - 1] else 1\n        res = (res + count) % mod\n    return res", "import heapq\n\ndef minimumSize(nums, maxOperations):\n    pq = [-num for num in nums] # Negative numbers to simulate max heap\n    heapq.heapify(pq)\n    while maxOperations > 0:\n        maxBalls = -heapq.heappop(pq)\n        heapq.heappush(pq, -maxBalls // 2)\n        heapq.heappush(pq, -(maxBalls - (maxBalls // 2)))\n        maxOperations -= 1\n    return -pq[0]", "from collections import defaultdict\n\ndef min_trio_degree(n, edges):\n    graph = defaultdict(dict)\n    degree = [0] * (n + 1)\n\n    for u, v in edges:\n        graph[u][v] = graph[v][u] = True\n        degree[u] += 1\n        degree[v] += 1\n\n    min_degree = float('inf')\n    for u, v in edges:\n        for w in range(1, n + 1):\n            if graph[u].get(w) and graph[v].get(w):\n                min_degree = min(min_degree, degree[u] + degree[v] + degree[w] - 6)\n\n    return min_degree if min_degree != float('inf') else -1", "def nearestValidPoint(x, y, points):\n    min_distance = float('inf')\n    min_index = -1\n\n    for i, point in enumerate(points):\n        if x == point[0] or y == point[1]:\n            distance = abs(x - point[0]) + abs(y - point[1])\n            if distance < min_distance:\n                min_distance = distance\n                min_index = i\n\n    return min_index", "def check_powers_of_three(n: int) -> bool:\n    while n > 0:\n        if n % 3 == 2:\n            return False\n        n //= 3\n    return True", "def isCovered(ranges: List[List[int]], left: int, right: int) -> bool:\n    for i in range(left, right + 1):\n        found = False\n        for _range in ranges:\n            if _range[0] <= i <= _range[1]:\n                found = True\n                break\n        if not found:\n            return False\n    return True", "def merge_alternately(word1, word2):\n    merged = []\n    i, j = 0, 0\n    while i < len(word1) or j < len(word2):\n        if i < len(word1):\n            merged.append(word1[i])\n            i += 1\n        if j < len(word2):\n            merged.append(word2[j])\n            j += 1\n    return \"\".join(merged)", "def min_operations(boxes: str):\n    result = [0] * len(boxes)\n    count, total = 0, 0\n\n    for i in range(len(boxes)):\n        total += count\n        result[i] = total\n        if boxes[i] == '1':\n            count += 1\n\n    count, total = 0, 0\n    for i in range(len(boxes) - 1, -1, -1):\n        total += count\n        result[i] += total\n        if boxes[i] == '1':\n            count += 1\n\n    return result", "def maximumScore(nums, multipliers):\n    n, m = len(nums), len(multipliers)\n    dp = [[0] * (m + 1) for _ in range(m + 1)]\n    maxScore = float('-inf')\n\n    for i in range(m + 1):\n        for j in range(m - i + 1):\n            if i == 0 and j == 0:\n                continue\n            score = 0\n            if i == 0:\n                score = dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1]\n            elif j == 0:\n                score = dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1]\n            else:\n                score = max(dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1],\n                            dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1])\n            dp[i][j] = score\n            if i + j == m:\n                maxScore = max(maxScore, score)\n\n    return maxScore", "def longestPalindromeSubseq(word1, word2):\n    n, m = len(word1), len(word2)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for i in range(n):\n        for j in range(m):\n            if word1[i] == word2[j]:\n                dp[i + 1][j + 1] = dp[i][j] + 1\n            else:\n                dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j])\n\n    return dp[n][m]", "def maximumRemovals(s: str, p: str, removable: List[int]) -> int:\n    low, high = 0, len(removable)\n    while low < high:\n        mid = (low + high + 1) // 2\n        temp_s = list(s)\n        for i in range(mid):\n            temp_s[removable[i]] = '-'\n        i, j = 0, 0\n        while i < len(temp_s) and j < len(p):\n            if temp_s[i] == p[j]:\n                j += 1\n            i += 1\n        if j == len(p):\n            low = mid\n        else:\n            high = mid - 1\n    return low", "def count_matches(items, rule_key, rule_value):\n    rule = {\"type\": 0, \"color\": 1, \"name\": 2}\n    count = 0\n\n    for item in items:\n        if item[rule[rule_key]] == rule_value:\n            count += 1\n\n    return count", "def closest_cost(base_costs, topping_costs, target):\n    closest = base_costs[0]\n    \n    for base in base_costs:\n        cost = base\n        \n        for i in range(1 << (len(topping_costs) * 2)):\n            bit_mask = i\n            \n            for j, topping_cost in enumerate(topping_costs):\n                cost += (bit_mask & 3) * topping_cost\n                bit_mask >>= 2\n                \n            if abs(target - cost) < abs(target - closest):\n                closest = cost\n            elif abs(target - cost) == abs(target - closest) and cost < closest:\n                closest = cost\n                \n            cost = base\n            \n    return closest", "def min_operations(nums1, nums2):\n    sum1, sum2 = sum(nums1), sum(nums2)\n    if sum1 == sum2: return 0\n    if sum1 < sum2: nums1, nums2 = nums2, nums1\n    nums1.sort(reverse=True)\n    nums2.sort()\n    diff, operations, i, j = abs(sum1 - sum2), 0, 0, 0\n    while diff > 0 and (i < len(nums1) or j < len(nums2)):\n        option1 = nums1[i] - 1 if i < len(nums1) else 0\n        option2 = 6 - nums2[j] if j < len(nums2) else 0\n        if option1 > option2:\n            diff -= option1\n            i += 1\n        else:\n            diff -= option2\n            j += 1\n        operations += 1\n    return operations if diff == 0 else -1", "def get_collision_times(cars):\n    n = len(cars)\n    collisions = [-1] * n\n    for i in range(n-1, -1, -1):\n        time_to_collision = 1e9\n        for j in range(i+1, n):\n            if cars[j][1] > cars[i][1]:\n                continue\n            current_collision = (cars[j][0] - cars[i][0]) / (cars[i][1] - cars[j][1])\n            if current_collision < time_to_collision:\n                time_to_collision = min(time_to_collision, min(collisions[j], current_collision))\n        collisions[i] = -1.0 if time_to_collision == 1e9 else time_to_collision\n    return collisions", "def largest_odd_number(num: str) -> str:\n    for i in range(len(num) - 1, -1, -1):\n        if int(num[i]) % 2 != 0:\n            return num[:i + 1]\n    return \"\"", "def second_largest_digit(s: str) -> int:\n    largest = -1\n    second_largest = -1\n    for c in s:\n        if c.isdigit():\n            digit = int(c)\n            if digit > largest:\n                second_largest = largest\n                largest = digit\n            elif digit != largest and digit > second_largest:\n                second_largest = digit\n    return second_largest", "from functools import lru_cache\nfrom math import gcd\n\ndef maxScore(nums):\n    n = len(nums)\n\n    @lru_cache(None)\n    def dfs(i, j):\n        if i > n:\n            return 0\n        ans = 0\n        for k in range(j + 1, n * 2):\n            ans = max(ans, dfs(i + 1, k) + i * gcd(nums[j], nums[k]))\n        return ans\n\n    return dfs(1, 0)", "def alice_wins(piles):\n    xor_sum = 0\n    for pile in piles:\n        xor_sum ^= pile\n    return xor_sum != 0", "def canBeIncreasing(nums):\n    count = 0\n    for i in range(1, len(nums)):\n        if nums[i - 1] >= nums[i]:\n            count += 1\n            if count > 1: return False\n            if i > 1 and nums[i - 2] >= nums[i] and i < len(nums) - 1 and nums[i - 1] >= nums[i + 1]: return False\n    return True", "def check_ones_segment(s: str) -> bool:\n    count = 0\n    for i in range(len(s)):\n        if s[i] == '1':\n            if i > 0 and s[i - 1] == '0':\n                count += 1\n    return count <= 1", "def min_elements(nums, limit, goal):\n    total_sum = sum(nums)\n    diff = abs(goal - total_sum)\n    return (diff + limit - 1) // limit", "from heapq import heappush, heappop\nfrom collections import defaultdict\nfrom functools import lru_cache\n\nmod = 10**9 + 7\n\ndef countRestrictedPaths(n, edges):\n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    dist = [float('inf')] * (n + 1)\n    dist[n] = 0\n    pq = [(0, n)] # (distance, node)\n    \n    while pq:\n        d, u = heappop(pq)\n        if d != dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heappush(pq, (dist[v], v))\n\n    @lru_cache(None)\n    def dfs(u):\n        if u == n:\n            return 1\n        ans = 0\n        for v, _ in graph[u]:\n            if dist[v] < dist[u]:\n                ans = (ans + dfs(v)) % mod\n        return ans\n\n    return dfs(1)", "def min_changes(nums, k):\n    n = len(nums)\n    xor_prefix = [0] * (n + 1)\n    for i in range(1, n + 1):\n        xor_prefix[i] = xor_prefix[i - 1] ^ nums[i - 1]\n\n    dp = [{} for _ in range(k)]\n    min_dp = [n] * k\n\n    for i in range(1, n + 1):\n        x = xor_prefix[i] ^ xor_prefix[i - k]\n\n        if i >= k:\n            dp[0][x] = dp[0].get(x, 0) + 1\n\n        for j in range(1, 1 + (i - j * k) // k):\n            if x in dp[j - 1]:\n                dp[j][x] = dp[j].get(x, 0) + 1\n                min_dp[j] = min(min_dp[j], dp[j - 1][x] - dp[j][x])\n\n    return min(n, [min_dp[j] + j for j in range(k)])", "def rotateGrid(grid, k):\n    if not grid: return grid\n    \n    m, n = len(grid), len(grid[0])\n    numLayers = min(m, n) // 2\n\n    for layer in range(numLayers):\n        numToRotate = (m - 2 * layer) * 2 + (n - 2 * layer - 2) * 2\n        effective_k = k % numToRotate\n\n        while effective_k:\n            temp = grid[layer][layer]\n            for i in range(layer + 1, m - layer): temp, grid[i][layer] = grid[i][layer], temp\n            for j in range(layer + 1, n - layer): temp, grid[m - layer - 1][j] = grid[m - layer - 1][j], temp\n            for i in range(m - layer - 2, layer - 1, -1): temp, grid[i][n - layer - 1] = grid[i][n - layer - 1], temp\n            for j in range(n - layer - 2, layer, -1): temp, grid[layer][j] = grid[layer][j], temp\n            effective_k -= 1\n\n    return grid", "def are_almost_equal(s1, s2):\n    diff_count = 0\n    first_diff = -1\n    second_diff = -1\n    for i in range(len(s1)):\n        if s1[i] != s2[i]:\n            diff_count += 1\n            if diff_count == 1:\n                first_diff = i\n            elif diff_count == 2:\n                second_diff = i\n            else:\n                return False\n    return diff_count == 0 or (diff_count == 2 and s1[first_diff] == s2[second_diff] and s1[second_diff] == s2[first_diff])", "def findCenter(edges):\n    if edges[0][0] == edges[1][0] or edges[0][0] == edges[1][1]:\n        return edges[0][0]\n    return edges[0][1]", "def maxScore(nums: List[int], k: int) -> int:\n    n = len(nums)\n    result = 0\n    for i in range(k, -1, -1):\n        for j in range(k, n):\n            min_val = min(nums[i:j+1])\n            result = max(result, min_val * (j - i + 1))\n    return result", "def square_is_white(coordinates: str) -> bool:\n    return (ord(coordinates[0]) - ord('a') + ord(coordinates[1]) - ord('1')) % 2 == 0", "def eliminate_maximum(dist, speed):\n    n = len(dist)\n    time_to_reach_city = [(dist[i] + speed[i] - 1) // speed[i] for i in range(n)]\n    time_to_reach_city.sort()\n    eliminated = 0\n    for i in range(n):\n        if time_to_reach_city[i] > i:\n            eliminated += 1\n        else:\n            break\n    return eliminated", "def goodDigitStrings(n: int) -> int:\n    MOD = 1000000007\n    even_count, prime_count = 1, 1\n    for i in range(n):\n        if i % 2 == 0:\n            even_count = (even_count * 5) % MOD\n        else:\n            prime_count = (prime_count * 4) % MOD\n    return (even_count * prime_count) % MOD", "def are_sentences_similar(sentence1, sentence2):\n    words1 = sentence1.split()\n    words2 = sentence2.split()\n\n    while words1 and words2 and words1[0] == words2[0]:\n        words1.pop(0)\n        words2.pop(0)\n    \n    while words1 and words2 and words1[-1] == words2[-1]:\n        words1.pop()\n        words2.pop()\n\n    return not words1 or not words2", "def max_happy_groups(batchSize, groups):\n    remainders = [0] * batchSize\n    for g in groups:\n        remainders[g % batchSize] += 1\n\n    result = remainders[0]\n    i, j = 1, batchSize - 1\n\n    while i < j:\n        result += min(remainders[i], remainders[j])\n        i += 1\n        j -= 1\n\n    if i == j:\n        result += remainders[i] // 2\n\n    return result", "def reverse(x):\n    rev = 0\n\n    while x != 0:\n        rev = rev * 10 + x % 10\n        x = x // 10\n\n    return rev\n\ndef count_nice_pairs(nums):\n    MOD = 1_000_000_007\n    count = {}\n    result = 0\n\n    for num in nums:\n        diff = num - reverse(num)\n        count[diff] = count.get(diff, 0) + 1\n\n    for val in count.values():\n        result = (result + ((val * (val - 1)) // 2) % MOD) % MOD\n\n    return result", "from collections import deque\n\ndef nearest_exit(maze, entrance):\n    m, n = len(maze), len(maze[0])\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    q = deque([tuple(entrance)])\n    \n    steps = -1\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            if maze[r][c] == '+': continue\n            if r == 0 or r == m-1 or c == 0 or c == n-1:\n                if r != entrance[0] or c != entrance[1]: return steps\n            maze[r][c] = '+'\n            for dr, dc in moves:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < m and 0 <= nc < n:\n                    q.append((nr, nc))\n    return -1", "def max_ascending_sum(nums):\n    max_sum = current_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            current_sum += nums[i]\n        else:\n            max_sum = max(max_sum, current_sum)\n            current_sum = nums[i]\n\n    return max(max_sum, current_sum)", "from heapq import heappush, heappop\n\ndef getNumberOfBacklogOrders(orders):\n    buy, sell = [], []\n\n    for price, amount, orderType in orders:\n        if orderType == 0:\n            while amount > 0 and sell and -sell[0][0] <= price:\n                executedAmount = min(amount, sell[0][1])\n                amount -= executedAmount\n                sell[0] = [-sell[0][0], sell[0][1] - executedAmount]\n                if sell[0][1] == 0:\n                    heappop(sell)\n            if amount:\n                heappush(buy, [-price, amount])\n        else:\n            while amount > 0 and buy and buy[0][0] >= price:\n                executedAmount = min(amount, buy[0][1])\n                amount -= executedAmount\n                buy[0] = [buy[0][0], buy[0][1] - executedAmount]\n                if buy[0][1] == 0:\n                    heappop(buy)\n            if amount:\n                heappush(sell, [-price, amount])\n\n    res = sum(item[1] for item in buy) + sum(item[1] for item in sell)\n    return res % 1000000007", "def maxValue(n, index, maxSum):\n    maxSum -= n\n    left, right, ans = 0, maxSum, 0\n    while left <= right:\n        mid = left + (right - left) // 2\n        sum = min(mid, index) * (min(mid, index) + 1) // 2 + min(mid, n - index - 1) * (min(mid, n - index) + 1) // 2\n        if mid > index:\n            sum += (mid - index - 1) * (mid - index) // 2\n        if mid > n - index:\n            sum += (mid - n + index) * (mid - n + index + 1) // 2\n        if sum <= maxSum:\n            ans = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n    return ans + 1", "def max_consecutive_values(coins):\n    coins.sort()\n    max_value = 0    \n    for coin in coins:\n        if coin <= max_value + 1:\n            max_value += coin\n        else:\n            break\n    return max_value + 1", "def numOfWays(m, n):\n    mod = 1000000007\n    a, b, c, d = 6, 6, 3, 3\n    while n > 1:\n        n -= 1\n        temp_a = a\n        temp_c = c\n        a = (a * 3 + b * 2) % mod\n        b = (temp_a * 2 + b * 2) % mod\n        c = (c * 3 + d * 2) % mod\n        d = (temp_c * 2 + d * 2) % mod\n    return b if m == 1 else (a + c) % mod", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef canMerge(trees):\n    leaf_count = {}\n    root_map = {}\n    \n    for tree in trees:\n        if tree.left:\n            leaf_count[tree.left.val] = leaf_count.get(tree.left.val, 0) + 1\n        if tree.right:\n            leaf_count[tree.right.val] = leaf_count.get(tree.right.val, 0) + 1\n        root_map[tree.val] = tree\n\n    def is_valid_bst(node, min_val, max_val):\n        if not node:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        if node.left and node.left.val in root_map:\n            left_child = root_map.pop(node.left.val)\n            leaf_count[tree.left.val] -= 1\n            tree.left = left_child\n        if node.right and node.right.val in root_map:\n            right_child = root_map.pop(node.right.val)\n            leaf_count[tree.right.val] -= 1\n            tree.right = right_child\n        return is_valid_bst(node.left, min_val, node.val) and is_valid_bst(node.right, node.val, max_val)\n            \n\n    for tree in trees:\n        if leaf_count.get(tree.val, 0) == 0:\n            if is_valid_bst(tree, 0, 5e4 + 1):\n                return tree\n            break\n\n    return None", "def num_different_integers(word):\n    for c in word:\n        if not c.isdigit():\n            word = word.replace(c, ' ')\n    nums = word.split()\n    unique_nums = set()\n    for num in nums:\n        num = num.lstrip('0') or '0'\n        unique_nums.add(num)\n    return len(unique_nums)", "def min_operations(n):\n    count = 1\n    temp = 1\n\n    while temp % n != 0:\n        temp = (temp * 2) % n\n        count += 1\n\n    return count", "def numberOfNiceDivisors(primeFactors):\n    MOD = 1000000007\n    result = 1\n    p = 2\n    while p <= primeFactors:\n        if primeFactors % p == 0:\n            count = 0\n            while primeFactors % p == 0:\n                primeFactors //= p\n                count += 1\n            result = (result * (count * 2 + 1)) % MOD\n        p += 1\n    return result", "def maxPoints(points):\n    m, n = len(points), len(points[0])\n    dp = [0] * n\n    for row in points:\n        next_dp = [0] * n\n        for c1 in range(n):\n            score = dp[c1] + row[c1] - c1\n            for c2 in range(n):\n                next_dp[c2] = max(next_dp[c2], score - row[c1] + c2)\n        dp = next_dp\n    return max(dp)", "def min_operations(nums):\n    operations = 0\n    for i in range(1, len(nums)):\n        if nums[i] <= nums[i - 1]:\n            operations += nums[i - 1] - nums[i] + 1\n            nums[i] = nums[i - 1] + 1\n    return operations", "def make_string_sorted(s):\n    mod = 1000000007\n    n = len(s)\n    fact = [1] * (n + 1)\n    inv = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n        inv[i] = inv[i - 1] * (mod - mod // i) % mod\n        \n    ans = 0\n    for i in range(n):\n        less_than = 0\n        for j in range(i + 1, n):\n            if s[j] < s[i]:\n                less_than += 1\n        ans = (ans + less_than * fact[n - i - 1]) % mod\n    return ans", "from sortedcontainers import SortedDict\nfrom sortedcontainers import SortedSet\n\ndef smallestChair(times, targetFriend):\n    events = SortedDict()\n    for i, (arrival, leaving) in enumerate(times):\n        events[arrival] = i\n        events[leaving] = ~i\n\n    availableChairs = SortedSet(range(len(times)))\n    assignedChair = [0] * len(times)\n\n    for time, idx in events.items():\n        if idx >= 0:\n            chair = availableChairs.pop(0)\n            assignedChair[idx] = chair\n            if idx == targetFriend:\n                return chair\n        else:\n            availableChairs.add(assignedChair[~idx])\n\n    return -1", "def splitPainting(segments):\n    line = {}\n    for s in segments:\n        start, end, color = s\n        if start not in line:\n            line[start] = 0\n        if end not in line:\n            line[end] = 0\n        line[start] += color\n        line[end] -= color\n    res = []\n    pre = 0\n    sum = 0\n    for key in sorted(line.keys()):\n        if pre > 0:\n            if sum > 0:\n                res.append([pre, key, sum])\n        pre = key\n        sum += line[key]\n    return res", "def truncate_sentence(s, k):\n    words = s.split(' ')\n    return ' '.join(words[:k])", "from collections import defaultdict\n\ndef finding_users_active_minutes(logs, k):\n    user_minutes = defaultdict(set)\n    for log in logs:\n        user_minutes[log[0]].add(log[1])\n    result = [0] * k\n    for minutes in user_minutes.values():\n        if len(minutes) <= k:\n            result[len(minutes) - 1] += 1\n    return result", "import bisect\n\ndef minAbsoluteSumDiff(nums1, nums2):\n    n = len(nums1)\n    total = 0\n    max_diff = 0\n    mod = 10**9 + 7\n    sorted_nums1 = sorted(nums1)\n    \n    for i in range(n):\n        diff = abs(nums1[i] - nums2[i])\n        total += diff\n        \n        pos = bisect_left(sorted_nums1, nums2[i])\n        if pos != n:\n            max_diff = max(max_diff, diff - abs(sorted_nums1[pos] - nums2[i]))\n        if pos != 0:\n            max_diff = max(max_diff, diff - abs(sorted_nums1[pos - 1] - nums2[i]))\n    \n    return (total - max_diff + mod) % mod", "def count_different_subsequence_GCDs(nums):\n    maximum = max(nums)\n    gcd_count = [0] * (maximum + 1)\n    \n    for num in nums:\n        for i in range(1, int(num**0.5) + 1):\n            if num % i == 0:\n                gcd_count[i] += 1\n                if i * i != num:\n                    gcd_count[num // i] += 1\n                    \n    different_GCDs = sum(1 for count in gcd_count if count > 0)\n    \n    return different_GCDs", "from collections import defaultdict\n\ndef delete_duplicate_folder(paths):\n    folder_counts = defaultdict(int)\n    \n    for path in paths:\n        path_string = '/' + '/'.join(path)\n        folder_counts[path_string] += 1\n\n    remaining_paths = []\n\n    for path in paths:\n        path_string = '/' + path[0]\n        not_duplicate = folder_counts[path_string] == 1\n        for i in range(1, len(path)):\n            path_string += '/' + path[i]\n            if folder_counts[path_string] > 1:\n                not_duplicate = False\n                break\n        if not_duplicate:\n            remaining_paths.append(path)\n\n    return remaining_paths", "def sign_func(x):\n    if x > 0:\n        return 1\n    elif x < 0:\n        return -1\n    else:\n        return 0\n\ndef array_sign(nums):\n    product = 1\n    for x in nums:\n        product *= x\n    return sign_func(product)", "def minSideJumps(obstacles):\n    n = len(obstacles)\n    dp = [[n] * 3 for _ in range(n)]\n    dp[0][1] = 0\n    dp[0][0] = dp[0][2] = 1\n\n    for i in range(1, n):\n        if obstacles[i] != 1:\n            dp[i][0] = min(dp[i - 1][0], dp[i - 1][1] + 1, dp[i - 1][2] + 1)\n        if obstacles[i] != 2:\n            dp[i][1] = min(dp[i - 1][1], dp[i - 1][0] + 1, dp[i - 1][2] + 1)\n        if obstacles[i] != 3:\n            dp[i][2] = min(dp[i - 1][2], dp[i - 1][0] + 1, dp[i - 1][1] + 1)\n\n    return min(dp[-1])", "from collections import deque\nfrom sortedcontainers import SortedList\n\nclass MKAverage:\n\n    def __init__(self, m: int, k: int):\n        self.m = m\n        self.k = k\n        self.sum = 0\n        self.min_set = SortedList()\n        self.mid_set = SortedList()\n        self.max_set = SortedList()\n        self.q = deque()\n\n    def add_element(self, num: int) -> None:\n        if len(self.q) == self.m:\n            self.remove_element()\n\n        self.min_set.add(num)\n        self.sum += num\n        \n        if len(self.min_set) > self.k:\n            temp = self.min_set.pop()\n            self.mid_set.add(temp)\n            self.sum += temp\n\n        if self.min_set and self.mid_set and self.min_set[-1] > self.mid_set[0]:\n            temp1 = self.min_set.pop()\n            temp2 = self.mid_set.pop(0)\n            self.min_set.add(temp2)\n            self.mid_set.add(temp1)\n            self.sum += temp2 - temp1\n\n        self.max_set.add(self.mid_set.pop())\n        self.sum -= self.mid_set.pop()\n        self.mid_set.add(self.max_set.pop(0))\n\n        if len(self.max_set) > self.k:\n            temp = self.max_set.pop(0)\n            self.mid_set.add(temp)\n            self.sum += temp\n        \n        self.q.append(num)\n\n    def calculate_mkaverage(self) -> int:\n        if len(self.q) < self.m:\n            return -1\n        return self.sum // (self.m - 2 * self.k)\n\n    def remove_element(self) -> None:\n        temp = self.q.popleft()\n\n        if temp in self.min_set:\n            self.min_set.remove(temp)\n        elif temp in self.mid_set:\n            self.mid_set.remove(temp)\n            self.sum -= temp\n        else:\n            self.max_set.remove(temp)", "def replace_digits(s: str) -> str:\n    s = list(s)\n    for i in range(1, len(s), 2):\n        s[i] = chr(ord(s[i - 1]) + int(s[i]))\n    return ''.join(s)", "import heapq\n\nclass SeatManager:\n    def __init__(self, n: int):\n        self.available_seats = [i for i in range(1, n + 1)]\n        heapq.heapify(self.available_seats)\n\n    def reserve(self) -> int:\n        return heapq.heappop(self.available_seats)\n\n    def unreserve(self, seatNumber: int) -> None:\n        heapq.heappush(self.available_seats, seatNumber)", "def max_element(arr):\n    max_val = max(arr)\n    return max_val // 2", "def smallest_difference_room(rooms, queries):\n    n = len(rooms)\n    k = len(queries)\n    rooms.sort(key=lambda x: x[0])\n    results = []\n\n    for i in range(k):\n        preferred, minSize = queries[i]\n        diff = float(\"inf\")\n        room_idx = -1\n\n        for j in range(n):\n            if rooms[j][1] >= minSize:\n                tmp_diff = abs(preferred - rooms[j][0])\n                if tmp_diff < diff:\n                    diff = tmp_diff\n                    room_idx = rooms[j][0]\n\n        results.append(room_idx)\n\n    return results", "def checkMove(board, rMove, cMove, color):\n    directions = ((-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1))\n    opposite_color = 'B' if color == 'W' else 'W'\n\n    for d in directions:\n        x, y = rMove + d[0], cMove + d[1]\n        count = 0\n        while 0 <= x < 8 and 0 <= y < 8 and board[x][y] == opposite_color:\n            x += d[0]\n            y += d[1]\n            count += 1\n\n        if count > 0 and 0 <= x < 8 and 0 <= y < 8 and board[x][y] == color:\n            return True\n\n    return False", "def minSpaceWastedKResizing(nums, k):\n    n = len(nums)\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    sum_nums = [0] * (n + 1)\n    dp[0][0] = 0\n    \n    for i in range(1, n + 1):\n        sum_nums[i] = sum_nums[i - 1] + nums[i - 1]\n        max_val = nums[i - 1]\n        for j in range(i - 1, -1, -1):\n            max_val = max(max_val, nums[j])\n            waste = max_val * (i - j) - (sum_nums[i] - sum_nums[j])\n            for c in range(k):\n                dp[i][c + 1] = min(dp[i][c + 1], dp[j][c] + waste)\n\n    return dp[n][k]", "def is_pangram(sentence):\n    alphabet = [False] * 26\n    for c in sentence:\n        alphabet[ord(c) - ord('a')] = True\n    return all(alphabet)", "def max_ice_cream(costs, coins):\n    costs.sort()\n    count = 0\n    for cost in costs:\n        if coins >= cost:\n            coins -= cost\n            count += 1\n        else:\n            break\n    return count", "from queue import PriorityQueue\n\ndef getOrder(tasks):\n    task_indices = sorted(range(len(tasks)), key=lambda i: tasks[i][0])\n    min_heap = PriorityQueue()\n    time = 0\n    task_idx = 0\n    result = []\n\n    while task_indices:\n        while task_idx < len(task_indices) and tasks[task_indices[task_idx]][0] <= time:\n            idx = task_indices[task_idx]\n            min_heap.put((tasks[idx][1], idx))\n            task_idx += 1\n\n        if not min_heap.empty():\n            processing_time, index = min_heap.get()\n            time += processing_time\n            result.append(index)\n            task_indices.remove(index)\n        elif task_idx < len(task_indices):\n            time = max(time, tasks[task_indices[task_idx]][0])\n\n    return result", "def get_xor_sum(arr1, arr2):\n    xor_arr1 = xor_arr2 = 0\n    for i in arr1:\n        xor_arr1 ^= i\n    for j in arr2:\n        xor_arr2 ^= j\n    return xor_arr1 & xor_arr2", "def longest_obstacle_course(obstacles):\n    dp = []\n    ans = [0] * len(obstacles)\n\n    for obstacle in obstacles:\n        index = bisect_left(dp, obstacle)\n        ans[index] = index + 1\n        if index == len(dp):\n            dp.append(obstacle)\n        else:\n            dp[index] = obstacle\n\n    return ans", "def maxFrequency(nums, k):\n    nums.sort()\n    max_freq, n, total = 1, len(nums), 0\n    i = 0\n    for j in range(n):\n        total += nums[j]\n        while total < nums[j] * (j - i + 1) - k:\n            total -= nums[i]\n            i += 1\n        max_freq = max(max_freq, j - i + 1)\n    return max_freq", "def longest_beautiful_substring(word: str) -> int:\n    if len(word) < 5:\n        return 0\n\n    max_length = current_length = 1\n    current_vowels = word[0]\n\n    for i in range(1, len(word)):\n        if word[i] >= current_vowels[-1] and word[i] not in current_vowels:\n            current_vowels += word[i]\n        elif word[i] == current_vowels[-1]:\n            pass\n        else:\n            current_vowels = word[i]\n            current_length = 0\n\n        current_length += 1\n\n        if current_vowels == \"aeiou\":\n            max_length = max(max_length, current_length)\n\n    return max_length", "def max_building(n, restrictions):\n    restrictions += [[1, 0], [n, n - 1]]\n    restrictions.sort()\n\n    for i in range(1, len(restrictions)):\n        restrictions[i][1] = min(restrictions[i][1], restrictions[i - 1][1] + restrictions[i][0] - restrictions[i - 1][0])\n\n    for i in range(len(restrictions) - 2, -1, -1):\n        restrictions[i][1] = min(restrictions[i][1], restrictions[i + 1][1] + restrictions[i + 1][0] - restrictions[i][0])\n\n    maxHeight = 0\n    for i in range(1, len(restrictions)):\n        height = (restrictions[i][1] + restrictions[i - 1][1] + restrictions[i][0] - restrictions[i - 1][0]) // 2\n        maxHeight = max(maxHeight, height)\n\n    return maxHeight", "def minNonZeroProduct(p: int) -> int:\n    mod = 10**9 + 7\n    x = (1 << p) - 1\n    y = (1 << p) - 2\n    z = pow(y, x - 1, mod)\n    return x * z % mod", "def sort_sentence(s: str) -> str:\n    tokens = s.split()\n    words = [''] * len(tokens)\n    \n    for token in tokens:\n        pos = int(token[-1]) - 1\n        words[pos] = token[:-1]\n    \n    return ' '.join(words)", "def mem_sticks_crash(memory1, memory2):\n    crash_time = 1\n    while True:\n        if memory1 >= memory2:\n            if memory1 >= crash_time:\n                memory1 -= crash_time\n            else:\n                break\n        else:\n            if memory2 >= crash_time:\n                memory2 -= crash_time\n            else:\n                break\n        crash_time += 1\n    return [crash_time, memory1, memory2]", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def dfs(self, root, count):\n        if not root:\n            return 0\n        left_sum = self.dfs(root.left, count)\n        right_sum = self.dfs(root.right, count)\n        if root.val == left_sum + right_sum:\n            count[0] += 1\n        return root.val + left_sum + right_sum\n\n    def equalToDescendants(self, root):\n        count = [0]\n        self.dfs(root, count)\n        return count[0]", "def minTimeToType(word: str) -> int:\n    time = 0\n    position = 0\n    for c in word:\n        next_position = ord(c) - ord('a')\n        diff = abs(next_position - position)\n        time += min(diff, 26 - diff) + 1\n        position = next_position\n    return time", "def find_target_distance(nums, target, start):\n    min_distance = float('inf')\n    for i, num in enumerate(nums):\n        if num == target:\n            distance = abs(i - start)\n            min_distance = min(min_distance, distance)\n    return min_distance", "def can_split_string(s: str) -> bool:\n    count = [0] * 10\n\n    for c in s:\n        count[int(c)] += 1\n\n    for i in range(1, 10):\n        if count[i] > 0 and count[i] == count[i - 1]:\n            return True\n\n    return False", "def intervalFinding(intervals, queries):\n    intervals.sort(key=lambda x: x[0])\n    ans = []\n    for q in queries:\n        min_size = float('inf')\n        for interval in intervals:\n            if interval[0] <= q <= interval[1]:\n                min_size = min(min_size, interval[1] - interval[0] + 1)\n        ans.append(-1 if min_size == float('inf') else min_size)\n    return ans", "def findGCD(nums):\n    min_val, max_val = min(nums), max(nums)\n    while max_val % min_val != 0:\n        min_val, max_val = max_val % min_val, min_val\n    return min_val", "def findDifferentBinaryString(nums):\n    s = set(nums)\n    n = len(nums)\n    \n    for i in range(1 << n):\n        candidate = ''.join(['1' if i & (1 << j) else '0' for j in range(n)])\n        if candidate not in s:\n            return candidate\n    return \"\"", "def minimizeTheDifference(mat, target):\n    m, n = len(mat), len(mat[0])\n    dp = [[0 for _ in range(800 * 70 + 1)] for _ in range(m)]\n    dp[0] = mat[0]\n\n    for i in range(1, m):\n        for j in range(n):\n            for k in range(800 * 70, 0, -1):\n                if k - mat[i][j] >= 0 and dp[i - 1][k - mat[i][j]]:\n                    dp[i][k] = 1\n\n    min_diff = float('inf')\n    for k in range(800 * 70 + 1):\n        if dp[-1][k]:\n            min_diff = min(min_diff, abs(k - target))\n\n    return min_diff", "from collections import Counter\n\ndef recoverArray(n, sums):\n    sums = Counter(sums)\n    ans = []\n\n    while len(ans) < n:\n        # remove the 0 sum\n        sums[0] -= 1\n        if sums[0] == 0: del sums[0]\n\n        # selected next value\n        cur = next(iter(sums))\n        sums[cur] -= 1\n        if sums[cur] == 0: del sums[cur]\n\n        # update sums\n        tmp = Counter()\n        for k, v in sums.items():\n            cnt = v - Ans.count(k - cur)\n            if cnt > 0:\n                tmp[k] = cnt\n        sums = tmp\n        ans.append(cur)\n    return ans", "def max_alive_year(logs):\n    years = [0] * 2051\n    \n    for log in logs:\n        years[log[0]] += 1\n        years[log[1]] -= 1\n    \n    max_population = 0\n    max_year = 0\n    population = 0\n    for i in range(1950, 2051):\n        population += years[i]\n        if population > max_population:\n            max_population = population\n            max_year = i\n\n    return max_year", "def max_distance(nums1, nums2):\n    i, j, max_dist = 0, 0, 0\n    while i < len(nums1) and j < len(nums2):\n        if i <= j and nums1[i] <= nums2[j]:\n            max_dist = max(max_dist, j - i)\n            j += 1\n        else:\n            i += 1\n    return max_dist", "def maxMinProduct(nums):\n    res, mod = 0, 10**9 + 7\n    n = len(nums)\n    prefix = [0] * (n + 1)\n    stack = []\n\n    for i in range(n):\n        prefix[i + 1] = (prefix[i] + nums[i]) % mod\n\n    for i in range(n + 1):\n        while stack and (i == n or nums[stack[-1]] > nums[i]):\n            j = stack.pop()\n            res = max(res, nums[j] * (prefix[i] - prefix[stack[-1] + 1 if stack else 0]) % mod)\n        stack.append(i)\n\n    return res", "from collections import defaultdict\n\n\ndef largestPathValue(colors, edges):\n    def dfs(node):\n        if not cache[node][ord(colors[node]) - ord('a')]:\n            cache[node][ord(colors[node]) - ord('a')] = 1\n            for neighbor in graph[node]:\n                cache[node][ord(colors[node]) - ord('a')] = max(cache[node][ord(colors[node]) - ord('a')],\n                                                               1 + dfs(neighbor))\n        return cache[node][ord(colors[node]) - ord('a')]\n\n    n = len(colors)\n    graph = [set() for _ in range(n)]\n    for a, b in edges:\n        graph[a].add(b)\n\n    cache = [[0] * 26 for _ in range(n)]\n    in_degree = [0] * n\n    for a, b in edges:\n        in_degree[b] += 1\n    res = -1\n    for i in range(n):\n        if in_degree[i] == 0:\n            res = max(res, dfs(i))\n    return res", "def count_good_substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s) - 2):\n        if s[i] != s[i + 1] and s[i] != s[i + 2] and s[i + 1] != s[i + 2]:\n            count += 1\n    return count", "def minimum_xor_sum(nums1, nums2):\n    nums2.sort()\n    xor_sum = 0\n    for i in range(len(nums1)):\n        xor_sum += nums1[i] ^ nums2[i]\n    return xor_sum", "def findMiddleIndex(nums):\n    total_sum = sum(nums)\n    left_sum = 0\n\n    for i, num in enumerate(nums):\n        if left_sum == total_sum - left_sum - num:\n            return i\n        left_sum += num\n\n    return -1", "def findFarmland(land):\n    m, n = len(land), len(land[0])\n    groups = []\n    \n    for i in range(m):\n        for j in range(n):\n            if land[i][j] == 1:\n                r1, c1 = i, j\n                while j + 1 < n and land[i][j + 1] == 1:\n                    j += 1\n                r2, c2 = i, j\n                while r2 + 1 < m and land[r2 + 1][j] == 1:\n                    r2 += 1\n                for r in range(r1, r2 + 1):\n                    for c in range(c1, c2 + 1):\n                        land[r][c] = 0\n                groups.append([r1, c1, r2, c2])\n\n    return groups", "def subset_xor_sum(nums):\n    result = 0\n    n = len(nums)\n    num_subsets = 1 << n\n\n    for i in range(num_subsets):\n        subset_xor = 0\n        for j in range(n):\n            if i & (1 << j):\n                subset_xor ^= nums[j]\n        result += subset_xor\n\n    return result", "def min_swaps(s: str) -> int:\n    zeros, ones = 0, 0\n    for c in s:\n        if c == '0':\n            zeros += 1\n        else:\n            ones += 1\n\n    if abs(zeros - ones) > 1:\n        return -1\n\n    mismatch_count1, mismatch_count2 = 0, 0\n    for i, c in enumerate(s):\n        if i % 2 == 0:\n            if c != '0': mismatch_count1 += 1\n            if c != '1': mismatch_count2 += 1\n        else:\n            if c != '1': mismatch_count1 += 1\n            if c != '0': mismatch_count2 += 1\n\n    return min(mismatch_count1, mismatch_count2) // 2", "def numberOfSticks(n, k):\n    MOD = 10**9 + 7\n    if n < k: return 0\n    dp = [[0] * (n+1) for _ in range(n+1)]\n\n    for i in range(1, n+1):\n        dp[i][1] = 1\n        for j in range(2, i+1):\n            dp[i][j] = (dp[i-1][j-1] + (i-1) * dp[i-1][j]) % MOD\n\n    return dp[n][k]", "def firstDayBeenInAllRooms(nextVisit):\n    n = len(nextVisit)\n    MOD = 10**9 + 7\n    dp = [0] * n\n\n    for i in range(1, n):\n        dp[i] = (dp[i - 1] * 2 - dp[nextVisit[i - 1]] + 2) % MOD\n\n    return dp[n - 1]", "from math import gcd\n\ndef can_be_sorted(nums):\n    sorted_nums = sorted(nums)\n    for i in range(len(nums)):\n        if nums[i] != sorted_nums[i] and gcd(nums[i], sorted_nums[i]) == 1:\n            return False\n    return True", "def checkZeroOnes(s: str) -> bool:\n    longest_zero = longest_one = current_zero = current_one = 0\n    \n    for c in s:\n        if c == '0':\n            current_zero += 1\n            longest_zero = max(longest_zero, current_zero)\n            current_one = 0\n        else:\n            current_one += 1\n            longest_one = max(longest_one, current_one)\n            current_zero = 0\n            \n    return longest_one > longest_zero", "import math\ndef minimum_speed(n, hour, dist):\n    if n > math.ceil(hour): return -1\n    low, high = 1, int(1e7)\n    \n    while low <= high:\n        mid = low + (high - low) // 2\n        time = sum(math.ceil(d / mid) for d in dist)\n        if time <= hour:\n            speed = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n            \n    return speed", "def canReach(s: str, minJump: int, maxJump: int) -> bool:\n    n = len(s)\n    dp = [False] * n\n    dp[0] = True\n    pre = 0\n    for i in range(1, n):\n        if i >= minJump:\n            pre += dp[i - minJump]\n        if i > maxJump:\n            pre -= dp[i - maxJump - 1]\n        dp[i] = pre > 0 and s[i] == '0'\n    return dp[n - 1]", "def stoneGameVII(stones):\n    n = len(stones)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            dp[i][j] = max(stones[i] - dp[i + 1][j], stones[j] - dp[i][j - 1])\n\n    return dp[0][n - 1]", "from collections import defaultdict\n\ndef smallestMissingValueSubtree(parents, nums):\n    n = len(parents)\n    children = defaultdict(set)\n    for i in range(1, n):\n        children[parents[i]].add(nums[i])\n\n    ans = [0] * n\n    dfs(0, parents, nums, children, ans)\n    return ans\n\ndef dfs(node, parents, nums, children, ans):\n    for child in list(children[node]):\n        dfs(child, parents, nums, children, ans)\n        children[node].remove(child)\n        children[node].add(ans[child])\n    it = next((x for x in children[node] if x > nums[node]), nums[node] + 1)\n    ans[node] = it - 1 if it != nums[node] + 1 else it", "def is_covered(ranges, left, right):\n    for i in range(left, right + 1):\n        is_covered = False\n        for range_ in ranges:\n            if i >= range_[0] and i <= range_[1]:\n                is_covered = True\n                break\n        if not is_covered:\n            return False\n    return True", "def chalk_replacer(chalk, k):\n    total_chalk = sum(chalk)\n    k %= total_chalk\n    for i, val in enumerate(chalk):\n        if k < val:\n            return i\n        k -= val\n    return 0", "def find_original_array(changed):\n    if len(changed) % 2 != 0:\n        return []\n\n    count = {}\n    for num in changed:\n        count[num] = count.get(num, 0) + 1\n\n    original = []\n    for num, freq in count.items():\n        if freq > count.get(num * 2, 0):\n            return []\n\n        for _ in range(freq):\n            original.append(num)\n\n    return original", "def minOperationsToFlip(expression: str) -> int:\n    zero, one, op = [0], [0], []\n    for c in expression:\n        if c == '&':\n            op.append(1)\n        elif c == '|':\n            op.append(2)\n        elif c.isdigit():\n            if c == '0':\n                one.append(1)\n                zero.append(0)\n            else:\n                zero.append(1)\n                one.append(0)\n        elif c == ')':\n            cur_op = op.pop()\n            x = zero.pop()\n            y = one.pop() + 1\n            if cur_op == 1:\n                new_zero = max(x, y)\n                new_one = one[-1] + min(x, zero[-1])\n            else:\n                new_zero = zero[-1] + min(x, one[-1])\n                new_one = max(y, one[-1])\n            zero.pop()\n            one.pop()\n            zero.append(new_zero)\n            one.append(new_one)\n    return zero[-1] + 1", "def min_operations(nums):\n    n = len(nums)\n    s = sorted(set(nums))\n    res = float('inf')\n    j = 0\n    \n    for i in range(len(s)):\n        while j < len(s) and s[j] <= s[i] + n - 1:\n            j += 1\n        res = min(res, n - (j - i))\n        \n    return res", "def max_value(n: str, x: int) -> str:\n    is_negative = n[0] == '-'\n    pos = 1 if is_negative else 0\n\n    while pos < len(n):\n        if (is_negative and int(n[pos]) > x) or (not is_negative and int(n[pos]) < x):\n            break\n        pos += 1\n\n    return n[:pos] + str(x) + n[pos:]", "from queue import PriorityQueue\n\ndef assignTasks(servers, tasks):\n    n, m = len(servers), len(tasks)\n    ans = [0] * m\n    freeServers = PriorityQueue()\n\n    for i in range(n):\n        freeServers.put((servers[i], i))\n\n    busyServers = PriorityQueue()\n    currentTask = 0\n\n    while currentTask < m:\n        while not busyServers.empty() and busyServers.queue[0][0] <= currentTask:\n            _, idx = busyServers.get()\n            freeServers.put((servers[idx], idx))\n\n        while not freeServers.empty() and currentTask < m:\n            _, idx = freeServers.get()\n            ans[currentTask] = idx\n            busyServers.put((currentTask + tasks[currentTask], idx))\n            currentTask += 1\n            \n        if freeServers.empty():\n            currentTask = busyServers.queue[0][0]\n    \n    return ans", "from math import ceil\n\ndef min_skips(dist, speed, hours_before):\n    n = len(dist)\n    dp = [[1e6] * (n + 1) for _ in range(n + 1)]\n    \n    dp[0][0] = 0\n    for i in range(1, n + 1):\n        dp[i][0] = ceil(dp[i - 1][0] + dist[i - 1] / speed)\n    \n    for i in range(1, n + 1):\n        for skip in range(1, i + 1):\n            dp[i][skip] = min(dp[i][skip], dp[i - 1][skip - 1] + dist[i - 1] / speed)\n            dp[i][skip] = min(dp[i][skip], ceil(dp[i - 1][skip] + dist[i - 1] / speed))\n    \n    for skip in range(n + 1):\n        if dp[n][skip] <= hours_before:\n            return skip\n    return -1", "def longestSubsequenceRepeatedK(s, k):\n    count = [0] * 26\n    for c in s:\n        count[ord(c) - ord('a')] += 1\n    seq = \"\".join(chr(i + ord('a')) * (count[i] // k) for i in range(26) if count[i] >= k)\n\n    def dp(i, j):\n        if (i, j) in memo:\n            return memo[(i, j)]\n        if i >= len(seq) or j >= len(seq):\n            return 0\n        if seq[i] == seq[j]:\n            res = 1 + dp(i + 1, j + 1)\n        else:\n            res = max(dp(i + 1, j), dp(i, j + 1))\n        memo[(i, j)] = res\n        return res\n\n    memo = {}\n    res = []\n    i, j = 0, 0\n    while j < len(seq) and len(res) < len(seq) // k:\n        if not res or seq[j] > res[-1]:\n            if dp(i, j) >= (len(seq) // k - len(res)) * 2:\n                res.append(seq[j])\n                i = j + 1\n        j += 1\n\n    return \"\".join(res)", "def findRotation(mat, target):\n    for _ in range(4):\n        if mat == target:\n            return True\n        n = len(mat)\n        for r in range((n + 1) // 2):\n            for c in range(n // 2):\n                mat[r][c], mat[n - 1 - c][r], mat[n - 1 - r][n - 1 - c], mat[c][n - 1 - r] = mat[n - 1 - c][r], mat[n - 1 - r][n - 1 - c], mat[c][n - 1 - r], mat[r][c]\n    return False", "def min_steps_to_equal_elements(nums):\n    min_elem = min(nums)\n    steps = 0\n    for num in nums:\n        steps += (num - min_elem)\n    return steps", "def min_operations(s):\n    cnt = 0\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            cnt += 1\n    return cnt", "from bisect import bisect_right\n\nclass Solution:\n    def minWastedSpace(self, packages, boxes) -> int:\n        MOD = 10**9 + 7\n        packages.sort()\n        total_package_size = sum(packages)\n        min_wasted_space = float('inf')\n\n        for box_sizes in boxes:\n            box_sizes.sort()\n            if box_sizes[-1] < packages[-1]:\n                continue\n            wasted_space = 0\n            package_idx = 0\n            for box_size in box_sizes:\n                package_idx = bisect_right(packages, box_size, package_idx)\n                wasted_space += box_size - packages[package_idx - 1]\n            min_wasted_space = min(min_wasted_space, wasted_space)\n\n        return -1 if min_wasted_space == float('inf') else (total_package_size + min_wasted_space) % MOD", "def sumOfPoints(s: str, answers: List[int]) -> int:\n    correct = 0\n    mul = 1\n    add = 0\n    for i in range(len(s)):\n        if s[i].isdigit():\n            num = int(s[i])\n            mul *= num\n            if i == len(s) - 1 or s[i + 1] == '+':\n                add += mul\n                mul = 1\n    correct = add\n\n    wrongOrder = int(s[0])\n    for i in range(2, len(s), 2):\n        if s[i - 1] == '+':\n            wrongOrder += int(s[i])\n        else:\n            wrongOrder *= int(s[i])\n\n    return sum(5 * (ans == correct) + 2 * (ans == wrongOrder) for ans in answers)", "def remove_occurrences(s, part):\n    while part in s:\n        s = s.replace(part, '', 1)\n    return s", "def max_alternating_sum(nums):\n    even_sum = odd_sum = 0\n    for num in nums:\n        even_sum, odd_sum = max(even_sum + num, odd_sum), even_sum - num\n    return even_sum", "from collections import defaultdict\nfrom sortedcontainers import SortedList\n\nclass MovieRentingSystem:\n\n    def __init__(self, n: int, entries: List[List[int]]):\n        self.price = defaultdict(dict)\n        self.rented = SortedList(key=lambda x: (x[0], x[1]))\n        self.available = defaultdict(SortedList)\n        for shop, movie, p in entries:\n            self.price[shop][movie] = p\n            self.available[movie].add((p, shop))\n\n    def search(self, movie: int) -> List[int]:\n        return [x[1] for x in self.available[movie][:5]]\n\n    def rent(self, shop: int, movie: int) -> None:\n        p = self.price[shop][movie]\n        self.rented.add((p, shop))\n        self.available[movie].discard((p, shop))\n\n    def drop(self, shop: int, movie: int) -> None:\n        p = self.price[shop][movie]\n        self.rented.discard((p, shop))\n        self.available[movie].add((p, shop))\n\n    def report(self) -> List[List[int]]:\n        return [[shop, movie] for p, shop, movie in self.rented]", "def max_consecutive_answers(answer_key: str, k: int) -> int:\n    max_len, left, T_cnt, F_cnt = 0, 0, 0, 0\n\n    for right, c in enumerate(answer_key):\n        if c == 'T':\n            T_cnt += 1\n        else:\n            F_cnt += 1\n\n        if min(T_cnt, F_cnt) > k:\n            if answer_key[left] == 'T':\n                T_cnt -= 1\n            else:\n                F_cnt -= 1\n            left += 1\n        else:\n            max_len = max(max_len, T_cnt + F_cnt)\n\n    return max_len", "def make_equal(words):\n    chars = set()\n    total_chars = 0\n    for word in words:\n        total_chars += len(word)\n        for c in word:\n            chars.add(c)\n    return total_chars % len(chars) == 0", "def maximumRemovals(s: str, p: str, removable: List[int]) -> int:\n    low, high = 0, len(removable)\n    while low < high:\n        mid = low + (high - low + 1) // 2\n        ss = list(s)\n        for i in range(mid):\n            ss[removable[i]] = '-'\n        j, i = 0, 0\n        while i < len(ss) and j < len(p):\n            if ss[i] == p[j]:\n                j += 1\n            i += 1\n        if j == len(p):\n            low = mid\n        else:\n            high = mid - 1\n    return low", "def earliest_and_latest(n, first_player, second_player):\n    earliest, latest = 1, 1\n    while (first_player + second_player) != n + 1 or abs(first_player - second_player) != 1:\n        if (first_player + second_player) <= n + 1 and (first_player - 1) // 2 == (second_player - 1) // 2:\n            break\n        if (first_player + second_player) > n + 1:\n            n = (n + 1) // 2\n            first_player, second_player = (n + 1) - second_player, (n + 1) - first_player\n        else:\n            first_player = (first_player + 1) // 2\n            second_player = (second_player + 1) // 2\n        earliest += 1\n        latest += 1\n\n    return [earliest, latest]", "def stoneGameIX(stones: List[int]) -> bool:\n    cnt = [0, 0, 0]\n    for s in stones:\n        cnt[s % 3] += 1\n    return (cnt[1] and cnt[2]) or (cnt[1] > cnt[2] if cnt[1] > cnt[2] + 2 else cnt[2] > cnt[1] + 1)", "def min_moves(n):\n    dp = [0, 1] + [0] * (n - 1)\n\n    for i in range(2, n + 1):\n        dp[i] = i\n        for x in range(1, i):\n            broken = x - 1\n            unbroken = i - x\n            dp[i] = min(dp[i], 1 + max(dp[broken], dp[unbroken]))\n\n    return dp[n]", "def largest_odd(num: str) -> str:\n    for i in range(len(num)):\n        if (int(num[i]) % 2) == 1:\n            return num[:i + 1]\n    return \"\"", "def full_rounds_played(login_time, logout_time):\n    login_hour, login_minute = map(int, login_time.split(':'))\n    logout_hour, logout_minute = map(int, logout_time.split(':'))\n\n    if (logout_hour * 60 + logout_minute) < (login_hour * 60 + login_minute):\n        logout_hour += 24\n\n    rounds = (logout_hour * 60 + logout_minute - (login_hour * 60 + login_minute)) // 15\n    return rounds", "def min_absolute_difference(nums, queries):\n    result = []\n\n    for query in queries:\n        left, right = query\n        unique = list(set(nums[left:right + 1]))\n\n        if len(unique) == 1:\n            result.append(-1)\n        else:\n            unique.sort()\n            min_diff = float('inf')\n            for i in range(1, len(unique)):\n                min_diff = min(min_diff, unique[i] - unique[i - 1])\n\n            result.append(min_diff)\n\n    return result", "def countSubIslands(grid1, grid2):\n    def dfs(i, j):\n        if i < 0 or i >= len(grid1) or j < 0 or j >= len(grid1[0]) or grid2[i][j] == 0:\n            return True\n\n        grid2[i][j] = 0\n\n        isSubIsland = grid1[i][j] == 1\n        isSubIsland &= dfs(i + 1, j)\n        isSubIsland &= dfs(i - 1, j)\n        isSubIsland &= dfs(i, j + 1)\n        isSubIsland &= dfs(i, j - 1)\n\n        return isSubIsland\n\n    count = 0\n\n    for i in range(len(grid1)):\n        for j in range(len(grid1[0])):\n            if grid2[i][j] == 1 and dfs(i, j):\n                count += 1\n\n    return count", "def maxAlternatingSum(nums):\n    odd, even = 0, 0\n    for num in nums:\n        newOdd = max(even + num, odd)\n        even = max(odd - num, even)\n        odd = newOdd\n    return odd", "def count_square_triples(n):\n    count = 0\n    for a in range(1, n + 1):\n        for b in range(a, n + 1):\n            c = int((a * a + b * b)**0.5)\n            if c * c == a * a + b * b and c <= n:\n                count += 1\n    return count", "from collections import deque\n\ndef nearest_exit(maze, entrance):\n    m, n = len(maze), len(maze[0])\n    directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n    q = deque()\n    maze[entrance[0]][entrance[1]] = '+'\n    q.append((entrance[0], entrance[1]))\n    steps = 0\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            x, y = q.popleft()\n            if (x == 0 or x == m - 1 or y == 0 or y == n - 1) and (x != entrance[0] or y != entrance[1]):\n                return steps\n\n            for dir in directions:\n                xx, yy = x + dir[0], y + dir[1]\n                if 0 <= xx < m and 0 <= yy < n and maze[xx][yy] == '.':\n                    maze[xx][yy] = '+'\n                    q.append((xx, yy))\n        steps += 1\n\n    return -1", "def sumGame(num: str) -> bool:\n    n = len(num)\n    sum1, sum2, cnt1, cnt2 = 0, 0, 0, 0\n\n    for i in range(n // 2):\n        if num[i] == '?': cnt1 += 1\n        else: sum1 += int(num[i])\n\n    for i in range(n // 2, n):\n        if num[i] == '?': cnt2 += 1\n        else: sum2 += int(num[i])\n\n    return (sum1 - sum2) != ((cnt2 - cnt1) // 2) * 9", "import heapq\nfrom collections import defaultdict\n\ndef minCost(maxTime, edges, passingFees):\n    n = len(passingFees)\n    graph = defaultdict(list)\n    for x, y, time in edges:\n        graph[x].append((y, time))\n        graph[y].append((x, time))\n\n    dp = [[float('inf')] * (maxTime + 1) for _ in range(n)]\n    dp[0][0] = passingFees[0]\n\n    pq = [(0, 0, passingFees[0])]\n    while pq:\n        time, city, cost = heapq.heappop(pq)\n        if city == n - 1:\n            return cost\n\n        for neighbor, t in graph[city]:\n            next_time = time + t\n            if next_time > maxTime:\n                continue\n\n            new_cost = cost + passingFees[neighbor]\n            if new_cost < dp[neighbor][next_time]:\n                dp[neighbor][next_time] = new_cost\n                heapq.heappush(pq, (next_time, neighbor, new_cost))\n\n    return -1", "def maxProductDifference(nums):\n    min1, min2, max1, max2 = float('inf'), float('inf'), float('-inf'), float('-inf')\n    for num in nums:\n        if num < min1:\n            min2, min1 = min1, num\n        elif num < min2:\n            min2 = num\n        if num > max1:\n            max2, max1 = max1, num\n        elif num > max2:\n            max2 = num\n    return max1 * max2 - min1 * min2", "def rotateGrid(grid, k):\n    def rotateLayer(layer, k):\n        m, n = len(grid), len(grid[0])\n        top, bottom = layer, m - 1 - layer\n        left, right = layer, n - 1 - layer\n        data_in_layer = (right - left + 1) * 2 + (bottom - top - 1) * 2\n        k %= data_in_layer\n        for _ in range(k):\n            temp = grid[top][left]\n            for j in range(left, right):\n                grid[top][j] = grid[top][j + 1]\n            for i in range(top, bottom):\n                grid[i][right] = grid[i + 1][right]\n            for j in range(right, left, -1):\n                grid[bottom][j] = grid[bottom][j - 1]\n            for i in range(bottom, top, -1):\n                grid[i][left] = grid[i - 1][left]\n            grid[top + 1][left] = temp\n\n    m, n = len(grid), len(grid[0])\n    layers = min(m, n) // 2\n    for layer in range(layers):\n        rotateLayer(layer, k)\n    return grid", "def wonderfulSubstrings(word: str) -> int:\n    res = 0\n    mask = 0\n    count = {0: 1}\n    for c in word:\n        mask ^= 1 << (ord(c) - ord('a'))\n        res += count.get(mask, 0)\n        for i in range(10):\n            res += count.get(mask ^ (1 << i), 0)\n        count[mask] = count.get(mask, 0) + 1\n    return res", "from collections import defaultdict, deque\n\ndef secondMinimum(n, edges, time, change):\n    graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    dist = [float('inf')] * (n + 1)\n    dist2 = [float('inf')] * (n + 1)\n    dist[1] = 0\n\n    q = deque([1])\n\n    while q:\n        cur = q.popleft()\n\n        nextDist = dist[cur] + time\n        waitTime = change if (nextDist // change) % 2 == 1 else 0\n        nextDist += waitTime\n\n        for next in graph[cur]:\n            if nextDist < dist[next]:\n                nextDist, dist[next] = dist[next], nextDist\n                q.append(next)\n            if nextDist < dist2[next]:\n                nextDist, dist2[next] = dist2[next], nextDist\n                q.append(next)\n\n    return dist2[n]", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef sortedList(head):\n    if not head or not head.next:\n        return head\n\n    prev = head\n    cur = head.next\n\n    while cur:\n        if cur.val < prev.val:\n            prev.next = cur.next\n            cur.next = head\n            head = cur\n            cur = prev\n        else:\n            prev = cur\n        cur = cur.next\n    return head", "def findPeakGrid(mat: List[List[int]]) -> List[int]:\n    m, n = len(mat), len(mat[0])\n    l, r = 0, n - 1\n\n    while l < r:\n        mid = (l + r) // 2\n        max_row = 0\n\n        for i in range(1, m):\n            if mat[i][mid] > mat[max_row][mid]:\n                max_row = i\n\n        if mat[max_row][mid] < mat[max_row][mid + 1]:\n            l = mid + 1\n        else:\n            r = mid\n\n    max_row = 0\n    for i in range(1, m):\n        if mat[i][l] > mat[max_row][l]:\n            max_row = i\n\n    return [max_row, l]", "def build_array(nums):\n    ans = []\n    for i in range(len(nums)):\n        ans.append(nums[nums[i]])\n    return ans", "def eliminate_monsters(dist, speed):\n    n = len(dist)\n    time_to_reach = sorted(dist[i] / speed[i] for i in range(n))\n    monsters_eliminated = 0\n    for time in time_to_reach:\n        if monsters_eliminated < time:\n            monsters_eliminated += 1\n    return monsters_eliminated", "def count_good_digit_strings(n):\n    mod = 10 ** 9 + 7\n    even_digits, prime_digits = 5, 4\n    total = 1\n    for i in range(n):\n        total = total * (even_digits if i % 2 == 0 else prime_digits) % mod\n    return total", "def minCost(sentence: str, k: int) -> int:\n    words = sentence.split()\n    dp = [float('inf')] * (len(words) + 1)\n    dp[0] = 0\n    for i in range(len(words)):\n        length = 0\n        j = i\n        while j >= 0:\n            length += len(words[j])\n            if length + (i - j) <= k:\n                dp[i + 1] = min(dp[i + 1], dp[j] + (k - length - (i - j)) * (k - length - (i - j)))\n            else:\n                break\n            length += 1\n            j -= 1\n    return dp[-1]", "def is_good_string(s: str) -> bool:\n    freq_map = {}\n    for c in s:\n        if c in freq_map:\n            freq_map[c] += 1\n        else:\n            freq_map[c] = 1\n\n    count = next(iter(freq_map.values()))\n    for value in freq_map.values():\n        if value != count:\n            return False\n    return True", "def find_chair(times, target_friend):\n    n = len(times)\n    events = []\n    for i, (arrival, leaving) in enumerate(times):\n        events.append((arrival, i))\n        events.append((leaving, ~i))\n    events.sort()\n    chairs = [-1] * n\n    available_chairs = sorted(range(n))\n    for time, friend_id in events:\n        if friend_id >= 0:\n            chairs[friend_id] = available_chairs.pop(0)\n            if friend_id == target_friend:\n                return chairs[friend_id]\n        else:\n            available_chairs.append(chairs[~friend_id])\n            available_chairs.sort()\n    return -1", "from collections import defaultdict\n\ndef splitPainting(segments):\n    changes = defaultdict(int)\n    for start, end, color in segments:\n        changes[start] += color\n        changes[end] -= color\n\n    result = []\n    start, color_sum = 0, 0\n    for key in sorted(changes.keys()):\n        if start != key:\n            if color_sum:\n                result.append([start, key, color_sum])\n            start = key\n        color_sum += changes[key]\n\n    return result", "def count_valid_combos(pieces, positions, index=0):\n    if index == len(pieces):\n        return 1\n\n    r, c = positions[index]\n    dr = [0, 1, 0, -1, 1, 1, -1, -1]\n    dc = [1, 0, -1, 0, 1, -1, 1, -1]\n    valids = 0\n\n    for x in range(8):\n        if pieces[index] == \"bishop\" and x < 4:\n            continue\n        if pieces[index] == \"rook\" and x >= 4:\n            break\n\n        for dist in range(1, 9):\n            nr, nc = r + dr[x] * dist, c + dc[x] * dist\n            if nr < 1 or nr > 8 or nc < 1 or nc > 8:\n                break\n            if nr == r and nc == c:\n                continue\n\n            valid = True\n            for other in range(len(positions)):\n                if other == index:\n                    continue\n                orr, occ = positions[other]\n                if orr == nr and occ == nc:\n                    valid = False\n                    break\n                if orr + occ == nr + nc or orr - occ == nr - nc:\n                    valid = False\n                    break\n                if orr == nr or occ == nc:\n                    valid = False\n                    break\n\n            if valid:\n                positions[index] = [nr, nc]\n                valids += count_valid_combos(pieces, positions, index + 1)\n                positions[index] = [r, c]\n\n    return valids", "def smallest_index(nums):\n    for i, num in enumerate(nums):\n        if i % 10 == num:\n            return i\n    return -1", "def get_concatenation(nums):\n    n = len(nums)\n    ans = [0] * (2 * n)\n    for i in range(n):\n        ans[i] = nums[i]\n        ans[i + n] = nums[i]\n    return ans", "def count_three_char_palindromes(s):\n    count = 0\n    freq = {}\n    for ch in s:\n        if ch in freq:\n            freq[ch] += 1\n        else:\n            freq[ch] = 1\n    for value in freq.values():\n        count += value * (value - 1) // 2\n    return count", "def merge_trees(trees):\n    while len(trees) > 1:\n        tree1 = trees.pop()\n        tree2 = trees.pop()\n\n        if tree1.val < tree2.val:\n            tree1.right = tree2\n            trees.append(tree1)\n        else:\n            tree2.right = tree1\n            trees.append(tree2)\n    return None if not trees else trees[0]", "def colorTheGrid(m, n):\n    mod = 10**9 + 7\n    dp = [6, 6]\n    dpf = [3, 3]\n\n    for _ in range(2, max(m, n) + 1):\n        temp = dp[1]\n        dp[1] = (dpf[1] * 2) % mod\n        dp[0] = temp\n        dpf[1] = (dpf[1] + dpf[0]) % mod\n        dpf[0] = (dpf[0] + temp) % mod\n\n    return (dp[0 if m == 1 else 1] * dpf[0 if n == 1 else 1]) % mod", "def count_vowel_substrings(word: str) -> int:\n    count, a, e, i, o, u = 0, 0, 0, 0, 0, 0\n    for c in word:\n        if c == 'a': a += 1\n        elif c == 'e': e = a + e\n        elif c == 'i': i = e + i\n        elif c == 'o': o = i + o\n        elif c == 'u': u = o + u\n    return u", "def count_vowels(word):\n    sum = 0\n    count = 0\n    for letter in word:\n        if letter in \"aeiou\":\n            count += 1\n        sum += count\n    return sum\n\ndef count_vowels_in_substrings(word):\n    return count_vowels(word)", "def minimum_maximum(n, quantities):\n    sum_products = sum(quantities)\n    x = (sum_products + n - 1) // n\n    remaining_stores = n\n    for q in quantities:\n        remaining_stores -= (q + x - 1) // x\n        if remaining_stores < 0:\n            x = (sum_products + remaining_stores) // (n + remaining_stores)\n            remaining_stores = n\n    return x", "from collections import defaultdict\n\ndef maxQuality_dfs(node, time_left, visited, values, neighbors):\n    acc = 0\n    for neighbor, cost in neighbors[node]:\n        if time_left >= cost and not visited[neighbor]:\n            visited[neighbor] = 1\n            acc = max(acc, values[neighbor] + maxQuality_dfs(neighbor, time_left - cost, visited, values, neighbors))\n            visited[neighbor] = 0\n    return acc\n\ndef maxQuality(values, edges, maxTime):\n    neighbors = defaultdict(list)\n    for u, v, cost in edges:\n        neighbors[u].append((v, cost))\n        neighbors[v].append((u, cost))\n    visited = [0] * len(values)\n    return maxQuality_dfs(0, maxTime, visited, values, neighbors)", "def maxScore(points):\n    m, n = len(points), len(points[0])\n    dp = [points[0]]\n\n    for r in range(1, m):\n        dp.append([0] * n)\n        for c in range(n):\n            score = points[r][c]\n            dp[r][c] = max(dp[r - 1][c_prev] + score - abs(c - c_prev) for c_prev in range(n))\n            \n    return max(dp[m - 1])", "import collections\n\ndef maxGeneticDifference(parents, queries):\n    M = 17\n    tr = [0, 0]\n\n    def insert(x):\n        nonlocal tr\n        u = 0\n        for i in range(M - 1, -1, -1):\n            v = (x >> i) & 1\n            if not tr[u][v]:\n                tr[u][v] = len(tr)\n                tr.append([0, 0])\n            u = tr[u][v]\n\n    def query(x, y=0):\n        u = 0\n        ans = 0\n        for i in range(M - 1, -1, -1):\n            v = ((x >> i) & 1) ^ 1\n            if not tr[u][v]:\n                v ^= 1\n            ans |= (y := (y << 1) | v)\n            u = tr[u][v]\n        return ans\n\n    def dfs(u, tree=0, g=collections.defaultdict(list), ans=None):\n        nonlocal tr\n        insert(tree := tree ^ u)\n        ans[u] = query(tree)\n        for v in g[u]:\n            dfs(v, tree, g, ans)\n\n    n = len(parents)\n    root = -1\n    graph = collections.defaultdict(list)\n    for i, parent in enumerate(parents):\n        if parent != -1:\n            graph[parent].append(i)\n        else:\n            root = i\n\n    ans = [0] * n\n    dfs(root, 0, graph, ans)\n    result = [ans[node] ^ val for node, val in queries]\n    return result", "class Robot:\n\n    def __init__(self, width: int, height: int):\n        self.width = width\n        self.height = height\n        self.x, self.y = 0, 0\n        self.dir = 0\n        self.dx = [1, 0, -1, 0]\n        self.dy = [0, 1, 0, -1]\n\n    def step(self, num: int):\n        while num > 0:\n            nx, ny = self.x + self.dx[self.dir], self.y + self.dy[self.dir]\n            if 0 <= nx < self.width and 0 <= ny < self.height:\n                self.x, self.y = nx, ny\n            else:\n                self.dir = (self.dir + 1) % 4\n                num += 1  # Retry the step\n            num -= 1\n\n    def getPos(self) -> list[int]:\n        return [self.x, self.y]\n\n    def getDir(self) -> str:\n        return [\"East\", \"North\", \"West\", \"South\"][self.dir]", "from bisect import bisect_right\n\ndef maxPrices(items, queries):\n    answer = []\n    sorted_items = [item[0] for item in items]\n    sorted_items.sort()\n\n    max_beauty = 0\n    for i, price in enumerate(sorted_items):\n        max_beauty = max(max_beauty, items[i][1])\n        sorted_items[i] = max_beauty\n\n    for query in queries:\n        idx = bisect_right(sorted_items, query) - 1\n        answer.append(sorted_items[idx] if idx >= 0 else 0)\n\n    return answer", "def maxTasks(tasks, workers, pills, strength):\n  tasks.sort()\n  workers.sort()\n\n  cnt = 0\n  i = 0\n  for j in range(pills):\n    while i < len(tasks) and tasks[i] > workers[j] + strength:\n      i += 1\n    if i < len(tasks):\n      cnt += 1\n      i += 1\n\n  i = 0\n  for j in range(pills, len(workers)):\n    if i < len(tasks) and tasks[i] <= workers[j]:\n      cnt += 1\n      i += 1\n      \n  return cnt", "def time_to_buy_tickets(tickets, k):\n    time = 0\n    while tickets[k] > 0:\n        for i in range(len(tickets)):\n            if tickets[i] > 0:\n                tickets[i] -= 1\n                time += 1\n                if i == k and tickets[k] == 0:\n                    break\n    return time", "class Solution:\n    def reverseGroup(self, head, k):\n        if not head or k == 1:\n            return head\n        prev = None\n        cur = head\n        for _ in range(k):\n            next = cur.next\n            cur.next = prev\n            prev = cur\n            cur = next\n        head.next = cur\n        return prev\n\n    def reverseEvenGroups(self, head):\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        n = 0\n        cur = head\n        while cur:\n            n += 1\n            cur = cur.next\n        i, k = 1, 1\n        while n >= 0 and k <= n:\n            if i % 2 == 0:\n                tail = prev.next\n                next = prev.next\n                for _ in range(k):\n                    next = next.next\n                prev.next = self.reverseGroup(tail, k)\n                tail.next = next\n            n -= k\n            for _ in range(k):\n                prev = prev.next\n            i += 1\n            k += i\n        return dummy.next", "def slanted_transposition_cipher(encodedText, rows):\n    if rows == 1:\n        return encodedText\n    \n    n = len(encodedText)\n    cols = (n + rows - 2) // (rows - 1)\n    pos = 0\n    matrix = [[' ' for col in range(cols)] for row in range(rows)]\n    for k in range(cols):\n        for i in range(rows):\n            if k % 2 == 0 or i != 0:\n                matrix[i][k] = encodedText[pos]\n                pos += 1\n                \n    originalText = ''.join(''.join(row) for row in matrix)\n    \n    return originalText", "def alphabet_position_sum(s, k):\n    sum = 0\n    for c in s:\n        sum += ord(c) - ord('a') + 1\n    for _ in range(k):\n        new_sum = 0\n        while sum > 0:\n            new_sum += sum % 10\n            sum //= 10\n        sum = new_sum\n    return sum", "def maximumNumber(num: str, change: List[int]) -> str:\n    num = list(num)\n    mutatable = False\n    for i in range(len(num)):\n        digit = int(num[i])\n        if digit < change[digit]:\n            if not mutatable: mutatable = True\n            num[i] = str(change[digit])\n        elif digit > change[digit] and mutatable:\n            break\n    return \"\".join(num)", "from itertools import permutations\n\ndef maxCompatibilitySum(students, mentors):\n    ans = 0\n    for mentors_perm in permutations(mentors):\n        cur_sum = sum(sum(a == b for a, b in zip(student, mentor)) for student, mentor in zip(students, mentors_perm))\n        ans = max(ans, cur_sum)\n    return ans", "from collections import defaultdict\n\ndef deleteDuplicateFolder(paths):\n    graph = defaultdict(set)\n    count = defaultdict(int)\n\n    for path in paths:\n        serialized_path = \"\"\n        for folder in path:\n            serialized_path += \"/\" + folder\n            graph[serialized_path].add(folder)\n\n    for value in graph.values():\n        count[str(value)] += 1\n\n    ans = []\n    for path in paths:\n        serialized_path = \"\"\n        duplicate = False\n        for folder in path:\n            serialized_path += \"/\" + folder\n            if count[str(graph[serialized_path])] > 1:\n                duplicate = True\n                break\n        if not duplicate:\n            ans.append(path)\n\n    return ans", "def check_good_line(board, r, c, color, dr, dc):\n    opp_color = 'B' if color == 'W' else 'W'\n    count = 0\n    r += dr\n    c += dc\n    while 0 <= r < 8 and 0 <= c < 8 and board[r][c] == opp_color:\n        count += 1\n        r += dr\n        c += dc\n    return 0 <= r < 8 and 0 <= c < 8 and board[r][c] == color and count >= 2\n\ndef is_legal_move(board, r_move, c_move, color):\n    if board[r_move][c_move] != '.':\n        return False\n    board[r_move][c_move] = color\n    for dr in range(-1, 2):\n        for dc in range(-1, 2):\n            if not (dr == 0 and dc == 0) and check_good_line(board, r_move, c_move, color, dr, dc):\n                return True\n    return False", "def minWastedSpace(nums, k):\n    n = len(nums)\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        total = 0\n        for j in range(i, 0, -1):\n            total += nums[j - 1]\n            for l in range(k):\n                dp[i][l + 1] = min(dp[i][l + 1], dp[j - 1][l] + (i - j + 1) * nums[j - 1] - total)\n\n    return min(dp[n])", "def has_three_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n        if count > 3:\n            break\n    return count == 3", "def rearrangeArray(nums):\n    nums.sort()\n    for i in range(1, len(nums) - 1, 2):\n        nums[i], nums[i + 1] = nums[i + 1], nums[i]\n    return nums", "def num_special_subsequences(nums):\n    zeros, ones, twos = 0, 0, 0\n    mod = 1000000007\n    for num in nums:\n        if num == 0:\n            zeros = (zeros + 1) % mod\n        elif num == 1:\n            ones = (ones + zeros) % mod\n        else:\n            twos = (twos + ones) % mod\n    return twos", "def minTotalCost(startPos, homePos, rowCosts, colCosts):\n    row_difference = abs(startPos[0] - homePos[0])\n    col_difference = abs(startPos[1] - homePos[1])\n\n    row_cost = sum(rowCosts[min(startPos[0], homePos[0]):min(startPos[0], homePos[0]) + row_difference])\n    col_cost = sum(colCosts[min(startPos[1], homePos[1]):min(startPos[1], homePos[1]) + col_difference])\n\n    return row_cost + col_cost", "def min_time_to_type(word: str) -> int:\n    time, prev = 0, 0\n    for c in word:\n        pos = ord(c) - ord('a')\n        time += min(abs(pos - prev), 26 - abs(pos - prev)) + 1\n        prev = pos\n    return time", "def maxMatrixSum(matrix):\n    n = len(matrix)\n    minValue, negativeCount, total = float('inf'), 0, 0\n\n    for i in range(n):\n        for j in range(n):\n            total += abs(matrix[i][j])\n            minValue = min(minValue, abs(matrix[i][j]))\n            if matrix[i][j] < 0:\n                negativeCount += 1\n\n    if negativeCount % 2 == 0:\n        return total\n    else:\n        return total - 2 * minValue", "from heapq import heappush, heappop\n\nMODULO = 1000000007\n\ndef countPaths(n, roads):\n    adj_list = [[] for _ in range(n)]\n\n    for u, v, time in roads:\n        adj_list[u].append((v, time))\n        adj_list[v].append((u, time))\n\n    dist = [float('inf')] * n\n    dist[0] = 0\n    count = [0] * n\n    count[0] = 1\n    pq = [(0, 0)]\n\n    while pq:\n        distance, node = heappop(pq)\n\n        if distance > dist[node]:\n            continue\n\n        for next_node, edge_distance in adj_list[node]:\n            if distance + edge_distance > dist[next_node]:\n                continue\n\n            if distance + edge_distance == dist[next_node]:\n                count[next_node] = (count[next_node] + count[node]) % MODULO\n            else:\n                count[next_node] = count[node]\n                dist[next_node] = distance + edge_distance\n                heappush(pq, (dist[next_node], next_node))\n\n    return count[n - 1]", "def numberOfLists(num: str) -> int:\n    mod = 10 ** 9 + 7\n    n = len(num)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for j in range(1, n + 1):\n            if num[i] == '0': continue\n            for k in range(1, min(n - i + 1, 11)):\n                if k > 1 and num[i + k - 1] == '0': break\n                dp[i + k][j] = (dp[i + k][j] + dp[i][j - 1]) % mod\n\n    return sum(dp[n]) % mod", "def find_secret_sharers(n, meetings, first_person):\n    secret_holders = [-1] * n\n    secret_holders[0] = 0\n    secret_holders[first_person] = 0\n\n    meetings.sort(key=lambda x: x[2])\n\n    for x, y, time in meetings:\n        if secret_holders[x] != -1 and secret_holders[x] <= time:\n            secret_holders[y] = time\n        if secret_holders[y] != -1 and secret_holders[y] <= time:\n            secret_holders[x] = time\n\n    return [i for i in range(n) if secret_holders[i] != -1]", "def is_prefix_string(s, words):\n    temp = \"\"\n    for word in words:\n        temp += word\n        if temp == s:\n            return True\n        if len(temp) > len(s):\n            break\n    return False", "def min_stones_remaining(piles, k):\n    for _ in range(k):\n        max_pile_index = piles.index(max(piles))\n        piles[max_pile_index] -= piles[max_pile_index] // 2\n\n    return sum(piles)", "def min_swaps_to_balance(s: str) -> int:\n    open_brackets = 0\n    swaps = 0\n\n    for c in s:\n        if c == '[':\n            open_brackets += 1\n        else:\n            if open_brackets == 0:\n                swaps += 1\n                open_brackets += 1\n            else:\n                open_brackets -= 1\n\n    return swaps", "from bisect import bisect_right\n\ndef longest_obstacle_course(obstacles):\n    ans, active = [0] * len(obstacles), []\n    for i, obstacle in enumerate(obstacles):\n        idx = bisect_right(active, obstacle)\n        ans[i] = idx + 1\n        if idx == len(active):\n            active.append(obstacle)\n        else:\n            active[idx] = obstacle\n    return ans", "def valid_arrangement(pairs):\n    graph = {}\n    for start, end in pairs:\n        if start not in graph:\n            graph[start] = []\n        graph[start].append(end)\n\n    result = []\n    current = pairs[0][0]\n\n    while graph:\n        pair = [current, graph[current].pop()]\n        if not graph[current]:\n            del graph[current]\n        result.append(pair)\n        current = pair[1]\n\n    return result", "def largest_even_sum(nums, k):\n    evens = sorted([num for num in nums if num % 2 == 0], reverse=True)\n    odds = sorted([num for num in nums if num % 2 != 0], reverse=True)\n\n    sum = 0\n    for _ in range(k):\n        if evens:\n            sum += evens.pop()\n\n    for _ in range(0, k - 1, 2):\n        if odds:\n            first = odds.pop()\n            if odds:\n                second = odds.pop()\n                sum += first + second\n\n    return sum if sum % 2 == 0 else -1", "def count_patterns_in_word(patterns, word):\n    count = 0\n    for pattern in patterns:\n        if pattern in word:\n            count += 1\n    return count", "def minNonZeroProduct(p):\n    MOD = 10**9 + 7\n    prod = 1\n    a = (1 << p) - 2\n    b = ((1 << p) - 1) % MOD\n       \n    while a > 0:\n        if a % 2:\n            prod = (prod * b) % MOD\n        b = (b * b) % MOD\n        a //= 2\n    return prod", "def can_reach_bottom(grid, row, col):\n    if row == len(grid) - 1:\n        return True\n    grid[row][col] = 1\n\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    for dr, dc in directions:\n        nr, nc = row + dr, col + dc\n        if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == 0:\n            if can_reach_bottom(grid, nr, nc):\n                return True\n\n    return False\n\ndef latestDayToCross(row, col, cells):\n    grid = [[0] * col for _ in range(row)]\n    ans = 0\n\n    for day, cell in enumerate(cells):\n        grid[cell[0] - 1][cell[1] - 1] = 1\n\n        found = False\n        for j in range(col):\n            if grid[0][j] == 0 and can_reach_bottom(grid, 0, j):\n                found = True\n                break\n\n        if not found:\n            ans = day\n            break\n\n    return ans", "def findMiddleIndex(nums):\n    total_sum = sum(nums)\n    \n    left_sum = 0\n    for i, num in enumerate(nums):\n        total_sum -= num\n        if left_sum == total_sum:\n            return i\n        left_sum += num\n    \n    return -1", "def findFarmland(land):\n    m, n = len(land), len(land[0])\n    res = []\n    \n    for i in range(m):\n        for j in range(n):\n            if land[i][j] == 1:\n                r, c = i, j\n                while r < m and land[r][j] == 1: r += 1\n                while c < n and land[i][c] == 1: c += 1\n                for x in range(i, r):\n                    for y in range(j,c):\n                        land[x][y] = 0\n                res.append([i, j, r - 1, c - 1])\n\n    return res", "from collections import defaultdict\n\nclass LockingTree:\n\n    def __init__(self, parent):\n        self.parent = parent\n        self.children = defaultdict(set)\n        self.locks = [-1] * len(parent)\n        for i in range(1, len(parent)):\n            self.children[parent[i]].add(i)\n    \n    def lock(self, num, user):\n        if self.locks[num] == -1:\n            self.locks[num] = user\n            return True\n        return False\n    \n    def unlock(self, num, user):\n        if self.locks[num] == user:\n            self.locks[num] = -1\n            return True\n        return False\n    \n    def upgrade(self, num, user):\n        if self.locks[num] != -1: return False\n        \n        cur = num\n        while cur != -1:\n            if self.locks[cur] != -1: return False\n            cur = self.parent[cur]\n        \n        locked_descendant = self._has_locked_descendants(num)\n        if locked_descendant:\n            self.locks[num] = user\n        return locked_descendant\n    \n    def _has_locked_descendants(self, node):\n        locked_descendant = False\n        for child in self.children[node]:\n            if self.locks[child] != -1:\n                locked_descendant = True\n                self.locks[child] = -1\n            locked_descendant |= self._has_locked_descendants(child)\n        return locked_descendant", "def numberOfGoodSubsets(nums: list[int]) -> int:\n    MOD = 10**9 + 7\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    primes = [i for i in range(2, 91) if is_prime(i)]\n    cnt = [0] * 100\n    for n in nums:\n        cnt[n] += 1\n\n    dp = [0] * (1 << 20)\n    dp[0] = 1\n    \n    for i in range(30, 0, -1):\n        if cnt[i] == 0:\n            continue\n        mask = [j for j in primes if i % j == 0]\n        i = i // j\n        if i > 1:\n            continue\n\n        m = 0\n        for j in mask:\n            m |= 1 << (j - 2)\n\n        for j in range(len(dp)-1, -1, -1):\n            if dp[j] == 0:\n                continue\n            cur = 1\n            for k in range(cnt[m]):\n                cur = (cur * 2) % MOD\n                dp[j | m] = (dp[j | m] + dp[j] * cur) % MOD\n\n    ans = sum(dp) % MOD\n    ans = (ans - dp[0] + MOD) % MOD\n    return (ans * (1 << (cnt[1] - 1))) % MOD", "from math import gcd\n\ndef findGCD(nums):\n    return gcd(min(nums), max(nums))", "def find_different_binary_string(nums):\n    return \"\".join(\"1\" if nums[i][i] == \"0\" else \"0\" for i in range(len(nums)))", "def minimizeTheDifference(mat, target):\n    m, n = len(mat), len(mat[0])\n    dp, new_dp = [1] + [0] * 4900, [0] * 4901\n    for i in range(m):\n        for j in range(n):\n            for k in range(4900 - mat[i][j] + 1):\n                new_dp[k + mat[i][j]] |= dp[k]\n        dp, new_dp = new_dp, [0] * 4901\n    for i in range(4901):\n        if dp[i]:\n            return abs(target - i)\n    return float('inf')", "from collections import Counter\ndef recoverArray(n, sums):\n    counter = Counter(sums)\n    ans = []\n    for _ in range(n):\n        num, _ = counter.most_common(1)[0]\n        counter -= Counter([num] + [prevNum - num for prevNum in ans])\n        ans.append(num)\n    return ans", "def num_smooth_descent_periods(prices):\n    result = 0\n    count = 0\n    for i in range(1, len(prices)):\n        if prices[i] == prices[i - 1] - 1:\n            count += 1\n        else:\n            count = 0\n        result += count + 1\n    return result + 1", "def minOperations(arr, k):\n    dp = [0] * len(arr)\n    for i in range(k, len(arr)):\n        dp[i] = max(dp[i - k] + 1 - (arr[i] - arr[i - k]), 0)\n    return sum(dp)", "def kthLargestNumber(nums, k):\n    nums.sort(key=lambda x: (len(x), x))\n    return nums[-k]", "def min_sessions(tasks, session_time):\n    sessions = []\n    tasks.sort(reverse=True)\n\n    for task in tasks:\n        added = False\n        for session_idx, session in enumerate(sessions):\n            if session + task <= session_time:\n                sessions[session_idx] += task\n                added = True\n                break\n\n        if not added:\n            sessions.append(task)\n\n    return len(sessions)", "def numDistinct(binary):\n    mod = 10**9 + 7\n    zero_count, ones_count = 0, 0\n\n    for c in binary:\n        if c == '0':\n            zero_count = (zero_count + ones_count) % mod\n        else:\n            ones_count = (ones_count * 2 + 1) % mod\n    \n    return zero_count", "def count_pairs_with_difference_k(nums, k):\n    freq_map = {}\n    count = 0\n\n    for num in nums:\n        count += freq_map.get(num - k, 0) + freq_map.get(num + k, 0)\n        freq_map[num] = freq_map.get(num, 0) + 1\n\n    return count", "def findOriginalArray(changed):\n    count = {}\n    for num in changed:\n        count[num] = count.get(num, 0) + 1\n\n    sorted_values = sorted(count.keys())\n\n    original = []\n    for num in sorted_values:\n        while count[num] > 0 and count.get(num * 2, 0) > 0:\n            original.append(num)\n            count[num] -= 1\n            count[num * 2] -= 1\n        if count[num] > 0:\n            return []\n\n    return original", "def minOperations(nums):\n    nums = sorted(set(nums))\n    n = len(nums)\n    ans = n\n    for i in range(n):\n        j = 0\n        while j < n and nums[j] <= nums[i] + n - 1:\n            j += 1\n        ans = min(ans, n - (j - i))\n    return ans", "def findNoOfInstructions(n: int, startPos: List[int], s: str) -> List[int]:\n    answer = [0] * len(s)\n    x, y = startPos\n\n    for i in range(len(s)):\n        cnt = 0\n        cx, cy = x, y\n        for j in range(i, len(s)):\n            step = s[j]\n            if step == 'L':\n                if cy == 0: break\n                cy -= 1\n            elif step == 'R':\n                if cy == n - 1: break\n                cy += 1\n            elif step == 'U':\n                if cx == 0: break\n                cx -= 1\n            else:\n                if cx == n - 1: break\n                cx += 1\n            cnt += 1\n            if j == len(s) - 1: break\n        answer[i] = cnt\n\n    return answer", "from collections import defaultdict, deque\n\ndef has_path(n, edges, source, destination):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    q = deque([source])\n    visited = [False] * n\n    while q:\n        current = q.popleft()\n        visited[current] = True\n        if current == destination:\n            return True\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                q.append(neighbor)\n    return False", "def numberOfWeakCharacters(properties):\n    properties.sort(key=lambda x: (x[0], -x[1]))\n    \n    max_defense = 0\n    weak_count = 0\n    for attack, defense in reversed(properties):\n        if defense < max_defense:\n            weak_count += 1\n        else:\n            max_defense = defense\n            \n    return weak_count", "def firstDayBeenInAllRooms(nextVisit):\n    n = len(nextVisit)\n    ans = 0\n    MOD = 10**9 + 7\n    dp = [0] * n\n\n    for i in range(1, n):\n        dp[i] = (dp[i - 1] + 1 + dp[i - 1] - dp[nextVisit[i - 1]] + MOD) % MOD\n        ans = (ans + dp[i]) % MOD\n    return ans", "def can_sort_using_swap(nums):\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i - 1]:\n            nums[i], nums[i - 1] = nums[i - 1], nums[i]\n            if sorted(nums) == nums:\n                return True\n            nums[i], nums[i - 1] = nums[i - 1], nums[i]\n    return False", "def can_destroy_all(mass: int, asteroids: List[int]) -> bool:\n    asteroids.sort()\n    for asteroid in asteroids:\n        if mass >= asteroid:\n            mass += asteroid\n        else:\n            return False\n    return True", "def max_invited(favorite):\n    in_degree = [0] * len(favorite)\n    for fav in favorite:\n        in_degree[fav] += 1\n    result = 0\n    for degree in in_degree:\n        result += max(degree - 1, 0)\n    return min(result + 2, len(favorite))", "def reverse_prefix(word: str, ch: str) -> str:\n    try:\n        index = word.index(ch)\n        return word[:index+1][::-1] + word[index+1:]\n    except ValueError:\n        return word", "def interchangeable_rectangles(rectangles):\n    ratio_count = {}\n    count = 0\n\n    for r in rectangles:\n        ratio = r[0] / r[1]\n        count += ratio_count.get(ratio, 0)\n        ratio_count[ratio] = ratio_count.get(ratio, 0) + 1\n\n    return count", "def maxProduct(s: str) -> int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1\n    \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    max_product = 0\n    for i in range(1, n):\n        max_product = max(max_product, dp[0][i - 1] * dp[i][n - 1])\n\n    return max_product", "def smallest_missing_value_subtree(parents, nums):\n    def dfs(node, parents, nums, tree, ans):\n        tree[node].add(nums[node])\n        for i in range(1, len(parents)):\n            if parents[i] == node:\n                dfs(i, parents, nums, tree, ans)\n                tree[node].update(tree[i])\n        missing = 1\n        while missing in tree[node]:\n            missing += 1\n        ans[node] = missing\n\n    n = len(parents)\n    ans = [0] * n\n    tree = [set() for _ in range(n)]\n    \n    dfs(0, parents, nums, tree, ans)\n    return ans", "def construct2DArray(original, m, n):\n    if m * n != len(original): return []\n    res = [[0] * n for _ in range(m)]\n    for i in range(len(original)):\n        res[i // n][i % n] = original[i]\n    return res", "def count_pairs(nums, target):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target or nums[j] + nums[i] == target:\n                count += 1\n    return count", "def max_consecutive_answers(answer_key: str, k: int) -> int:\n    n = len(answer_key)\n    start, max_len, max_count = 0, 0, 0\n    count = {'T': 0, 'F': 0}\n\n    for end in range(n):\n        max_count = max(max_count, count.__setitem__(answer_key[end], count[answer_key[end]] + 1))\n\n        if end - start + 1 - max_count > k:\n            count[answer_key[start]] -= 1\n            start += 1\n\n        max_len = max(max_len, end - start + 1)\n\n    return max_len", "def numOfWays(nums, k):\n    left = 0\n    right = 0\n    for num in nums:\n        if num < k:\n            left += 1\n        if num <= k:\n            right += 1\n\n    if left == len(nums):\n        return 0\n    if right - left != len(nums) - right:\n        return left + 1\n    return left", "def earliestBlooms(plantTime, growTime):\n    n = len(plantTime)\n    processTime = list(zip(plantTime, growTime))\n    processTime.sort()\n\n    day = 0\n    blooms = 0\n    for p in processTime:\n        day += p[0]\n        blooms = max(blooms, day + p[1])\n    return blooms", "def perform_operations(operations):\n    X = 0\n    for op in operations:\n        if op == \"++X\" or op == \"X++\":\n            X += 1\n        elif op == \"--X\" or op == \"X--\":\n            X -= 1\n    return X", "def sum_of_beauties(nums: List[int]) -> int:\n    n = len(nums)\n    result = 0\n\n    left_max = [0] * n\n    left_max[0] = nums[0]\n    right_min = [0] * n\n    right_min[n - 1] = nums[n - 1]\n\n    for i in range(1, n):\n        left_max[i] = max(left_max[i - 1], nums[i])\n\n    for i in range(n - 2, -1, -1):\n        right_min[i] = min(right_min[i + 1], nums[i])\n\n    for i in range(1, n - 1):\n        if nums[i] > left_max[i - 1] and nums[i] < right_min[i + 1]:\n            result += 1\n\n    return result", "class DetectSquares:\n\n    def __init__(self):\n        self.points = collections.defaultdict(lambda: collections.defaultdict(int))\n\n    def add(self, point):\n        self.points[point[0]][point[1]] += 1\n\n    def count(self, point):\n        ans = 0\n        for x2 in self.points[point[0]]:\n            if x2 == point[1]:\n                continue\n            for y2 in self.points[x2]:\n                if y2 == point[1] or abs(x2 - point[1]) != abs(y2 - point[0]):\n                    continue\n                ans += self.points[point[0]][x2] * self.points[x2][y2] * self.points[point[0]][y2]\n        return ans", "def longest_subsequence_repeated_k(s, k):\n    counts = [0] * 26\n    for c in s:\n        counts[ord(c) - ord('a')] += 1\n    seq = ''.join([chr(i + ord('a')) * (counts[i] // k) for i in range(25, -1, -1)])\n    return seq", "def max_computer_runtime(n, batteries):\n    batteries.sort()\n    result = 0\n    for i in range(len(batteries)):\n        result = max(result, min(n, len(batteries) - i) * batteries[i])\n    return result", "def max_difference(nums):\n    min_val = nums[0]\n    max_diff = -1\n\n    for i in range(1, len(nums)):\n        if nums[i] > min_val:\n            max_diff = max(max_diff, nums[i] - min_val)\n        else:\n            min_val = nums[i]\n\n    return max_diff", "def min_second_robot_points(grid: List[List[int]]) -> int:\n    n = len(grid[0])\n    for r in range(2):\n        for c in range(1, n):\n            grid[r][c] += grid[r][c - 1]\n    dp = [grid[0][n - 1], 0]\n    for c in range(n - 2, -1, -1):\n        dp_new = [max(dp[0] - grid[0][c], dp[1] + grid[1][c]), max(dp[1] - grid[1][c], dp[0] + grid[0][c])]\n        dp = dp_new\n    return max(dp)", "def can_place_word(board, word):\n    m, n = len(board), len(board[0])\n    for i in range(m):\n        for j in range(n):\n            if board[i][j] == word[0]:\n                if check_word(board, word, i, j, 0, 1) or check_word(board, word, i, j, 1, 0):\n                    return True\n    return False\n\ndef check_word(board, word, i, j, di, dj):\n    m, n = len(board), len(board[0])\n    for k in range(len(word)):\n        i += di\n        j += dj\n        if i < 0 or i >= m or j < 0 or j >= n:\n            return False\n        if k == 0 or k == len(word) - 1:\n            if board[i][j] != word[k] and board[i][j] != ' ':\n                return False\n        if k > 0 and k < len(word) - 1:\n            if board[i][j] != word[k] and board[i][j] != ' ' and board[i][j] != '#':\n                return False\n    return True", "def sum_of_points(s, answers):\n    total_points = 0\n    result = 0\n    term = 1\n    sign = \"+\"\n\n    for char in s:\n        if char.isdigit():\n            number = int(char)\n            if sign == \"+\":\n                result += term\n                term = number\n            elif sign == \"*\":\n                term *= number\n        else:\n            sign = char\n\n    result += term\n\n    for ans in answers:\n        total_points += (ans == result)\n\n    return total_points", "def min_moves(seats, students):\n    seats.sort()\n    students.sort()\n\n    moves = 0\n    for i in range(len(seats)):\n        moves += abs(seats[i] - students[i])\n    return moves", "def solve_puzzle(colors: str) -> bool:\n    return colors.count('A') % 2 == 1", "from collections import defaultdict, deque\n\ndef network_becomes_idle(edges, patience):\n    n = len(patience)\n    graph = defaultdict(list)\n    \n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n\n    dist = [-1] * n\n    dist[0] = 0\n    q = deque([0])\n    \n    while q:\n        node = q.popleft()\n        \n        for neighbor in graph[node]:\n            if dist[neighbor] == -1:\n                dist[neighbor] = dist[node] + 1\n                q.append(neighbor)\n\n    max_time = 0\n    for i in range(1, n):\n        time = ((2 * dist[i] - 1) // patience[i]) * patience[i] + 2 * dist[i]\n        max_time = max(max_time, time)\n    \n    return max_time + 1", "from math import gcd\nfrom itertools import combinations\n\ndef minStraightLines(points):\n    lines = set()\n    for p1, p2 in combinations(points, 2):\n        dy, dx = p2[1] - p1[1], p2[0] - p1[0]\n        g = gcd(dx, dy)\n        lines.add((dy // g, dx // g))\n    return len(lines)", "def min_moves_to_convert(s):\n    count = 0\n    i = 0\n    while i < len(s) - 2:\n        if s[i] == \"X\" and s[i + 1] == \"X\" and s[i + 2] == \"X\":\n            count += 1\n            i += 3\n        else:\n            i += 1\n    return count", "from typing import List\n\ndef missing_rolls(rolls: List[int], mean: int, n: int) -> List[int]:\n    m = len(rolls)\n    total_sum = mean * (n + m)\n    sum_m = sum(rolls)\n    \n    if total_sum - sum_m < n or total_sum - sum_m > 6 * n:\n        return []\n    \n    ans = [1] * n\n    total_sum -= sum_m + n\n    for i in range(n):\n        add = min(5, total_sum)\n        ans[i] += add\n        total_sum -= add\n    \n    return ans", "def alice_wins(stones):\n    sum_, count = 0, [0] * 3\n    for stone in stones:\n        sum_ += stone\n        count[stone % 3] += 1\n    if sum_ % 3:\n        return count[sum_ % 3] % 2 == 1\n    return count[1] % 2 == 0 or count[2] % 2 == 0 or count[1] == 0 or count[2] == 0", "from heapq import heappop, heappush\n\ndef smallest_subsequence(s, k, letter, repetition):\n    result = []\n    letter_count = s.count(letter)\n\n    pq = []\n    for c in s:\n        if c <= letter or letter_count > repetition:\n            while pq and pq[0] > c:\n                if heappop(pq) == letter:\n                    letter_count -= 1\n            heappush(pq, c)\n            if len(pq) > k:\n                heappop(pq)\n        if k - len(pq) == repetition:\n            letter_count -= 1\n        repetition = max(0, repetition)\n\n    return \"\".join(pq)", "def painting_plan(paint):\n    worklog = [0] * len(paint)\n    painted = set()\n\n    for i in range(len(paint)):\n        start, end = paint[i]\n\n        for j in range(start, end):\n            if j not in painted:\n                painted.add(j)\n                worklog[i] += 1\n\n    return worklog", "def min_operations(grid, x):\n    min_element = min(min(row) for row in grid)\n    min_ops = float('inf')\n\n    base = min_element\n    while True:\n        operations = 0\n        impossible = False\n        for row in grid:\n            if impossible:\n                break\n            for cell in row:\n                diff = abs(cell - base)\n                if diff % x != 0:\n                    impossible = True\n                    break\n                operations += diff // x\n        if impossible:\n            break\n        min_ops = min(min_ops, operations)\n        base -= 1\n\n    return -1 if min_ops == float('inf') else min_ops", "def min_partition_difference(nums):\n    n = len(nums) // 2\n    nums.sort(reverse=True)\n    return sum(nums[:n]) - sum(nums[n:])", "def kth_distinct_string(arr, k):\n    frequency = {}\n    for s in arr:\n        frequency[s] = frequency.get(s, 0) + 1\n\n    count = 0\n    for s in arr:\n        if frequency[s] == 1:\n            count += 1\n            if count == k:\n                return s\n\n    return \"\"", "def maxValue(events):\n    events.sort(key=lambda a: a[1])\n\n    dp = [0] * len(events)\n    dp[0] = events[0][2]\n\n    for i in range(1, len(events)):\n        lastNonConflict = -1\n        for j in range(i - 1, -1, -1):\n            if events[j][1] < events[i][0]:\n                lastNonConflict = j\n                break\n                \n        includedValue = events[i][2]\n        if lastNonConflict != -1:\n            includedValue += dp[lastNonConflict]\n\n        dp[i] = max(includedValue, dp[i - 1])\n\n    return dp[-1]", "from typing import List, Tuple\n\ndef plates_between_candles(s: str, queries: List[Tuple[int, int]]) -> List[int]:\n    n = len(s)\n    prefix = [0] * n\n    plates = 0\n    \n    for i in range(1, n):\n        prefix[i] = prefix[i - 1]\n        if s[i] == '*' and s[i - 1] == '|':\n            plates += 1\n        prefix[i] += plates\n    \n    res = []\n    for left, right in queries:\n        res.append(prefix[right] - (prefix[left - 1] if left > 0 else 0))\n    \n    return res", "def valid_move_combinations(pieces, positions):\n    n = len(pieces)\n    count = 0\n\n    for i in range(n):\n        for j in range(n):\n            if i != j and not (pieces[i] == \"bishop\" and (positions[i][0] + positions[i][1]) % 2 != (positions[j][0] + positions[j][1]) % 2):\n                count += 1\n\n    return count", "def min_time_to_remove_illegal_goods(s: str) -> int:\n    ones = twos = 0\n    for c in s:\n        if c == '1':\n            twos += ones\n            ones += 1\n    return ones + min(ones, twos)", "def are_numbers_increasing(s: str) -> bool:\n    tokens = s.split()\n    numbers = []\n    \n    for token in tokens:\n        if token.isdigit():\n            num = int(token)\n            if numbers and numbers[-1] >= num:\n                return False\n            numbers.append(num)\n    \n    return True", "def count_max_or_subsets(nums):\n    max_OR = 0\n    for num in nums:\n        max_OR |= num\n\n    OR_subsets = {0}\n    for num in nums:\n        tmp = OR_subsets.copy()\n        for x in OR_subsets:\n            tmp.add(x | num)\n        OR_subsets = tmp\n\n    return OR_subsets.count(max_OR)", "import heapq\n\ndef second_minimum(n: int, edges: List[List[int]], time: int, change: int) -> int:\n    adj = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    dist = [-1] * (n + 1)\n    queue = [(0, 1)]\n    dist[1] = 0\n\n    while queue:\n        t1, v1 = heapq.heappop(queue)\n\n        if v1 == n:\n            return t1\n\n        for v2 in adj[v1]:\n            t2 = t1 + time\n            waiting = change - (t2 % change) if (t2 // change) % 2 == 1 else 0\n\n            if dist[v2] == -1 or dist[v2] > t2 + waiting:\n                if dist[v2] != -1:\n                    heapq.heappush(queue, (dist[v2], v2))\n                dist[v2] = t2 + waiting\n                heapq.heappush(queue, (dist[v2], v2))\n\n    return -1", "def max_and_sum(nums, num_slots, idx, used, sum):\n    if idx == len(nums):\n        return sum\n    max_sum = 0\n    for i in range(1, num_slots + 1):\n        if not used & (1 << (i - 1)):\n            new_sum = sum + (nums[idx] & i)\n            new_used = used | (1 << (i - 1))\n            max_sum = max(max_sum, max_and_sum(nums, num_slots, idx + 1, new_used, new_sum))\n            if idx + 1 < len(nums):\n                new_sum = new_sum + (nums[idx + 1] & i)\n                max_sum = max(max_sum, max_and_sum(nums, num_slots, idx + 2, new_used, new_sum))\n    return max_sum\n\ndef max_and_sum(nums, num_slots):\n    return max_and_sum(nums, num_slots, 0, 0, 0)", "def next_balanced(n):\n    while True:\n        n += 1\n        digit_count = {}\n        temp = n\n        while temp:\n            digit = temp % 10\n            digit_count[digit] = digit_count.get(digit, 0) + 1\n            temp //= 10\n        balanced = all(k == v for k, v in digit_count.items())\n        if balanced:\n            return n", "def min_months(n, relations, time):\n    order = [0] * n\n    for r in relations:\n        order[r[1] - 1] = max(order[r[1] - 1], r[0])\n    totalTime = 0\n    for i in range(n):\n        totalTime = max(totalTime, time[i] + order[i])\n    return totalTime", "def almost_equivalent(word1, word2):\n    freq1 = {}\n    freq2 = {}\n\n    for c in word1:\n        freq1[c] = freq1.get(c, 0) + 1\n    for c in word2:\n        freq2[c] = freq2.get(c, 0) + 1\n\n    for c in \"abcdefghijklmnopqrstuvwxyz\":\n        if abs(freq1.get(c, 0) - freq2.get(c, 0)) > 3:\n            return False\n\n    return True", "class Robot:\n    def __init__(self):\n        self.x, self.y, self.dir = 0, 0, 1\n\n    def move(self, steps):\n        if self.dir == 0:\n            self.y += steps\n        elif self.dir == 1:\n            self.x += steps\n        elif self.dir == 2:\n            self.y -= steps\n        else:\n            self.x -= steps\n\n    def turn_left(self):\n        self.dir = (self.dir + 3) % 4\n\n    def turn_right(self):\n        self.dir = (self.dir + 1) % 4", "def max_beauty(items, queries):\n    sorted_items = [0] * 10001\n    for price, beauty in items:\n        sorted_items[price] = max(sorted_items[price], beauty)\n\n    for i in range(1, len(sorted_items)):\n        sorted_items[i] = max(sorted_items[i], sorted_items[i - 1])\n\n    return [sorted_items[query] for query in queries]", "def max_tasks(tasks, workers, pills, strength):\n    tasks.sort()\n    workers.sort()\n    task_index = 0\n    pill_index = pills\n    completed_tasks = 0\n\n    for worker_strength in workers:\n        while pill_index > 0 and worker_strength + strength >= tasks[task_index]:\n            worker_strength += strength\n            pill_index -= 1\n        \n        if worker_strength >= tasks[task_index]:\n            task_index += 1\n            completed_tasks += 1\n\n        if task_index >= len(tasks):\n            break\n\n    return completed_tasks", "def smallest_index(nums):\n    for i in range(len(nums)):\n        if i % 10 == nums[i]:\n            return i\n    return -1", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef critical_distance(head):\n    min_distance, max_distance = float('inf'), float('-inf')\n    last_cp, index = -1, 0\n    current = head.next\n\n    while current and current.next:\n        if (current.val > current.next.val and current.val > current.prev.val) or \\\n           (current.val < current.next.val and current.val < current.prev.val):\n\n            if last_cp != -1:\n                min_distance = min(min_distance, index - last_cp)\n                max_distance = max(max_distance, index - last_cp)\n            last_cp = index\n\n        current = current.next\n        index += 1\n\n    if min_distance != float('inf'):\n        return [min_distance, max_distance]\n    return [-1, -1]", "from collections import deque\n\ndef minOperations(nums, start, goal):\n    seen = {start}\n    q = deque([start])\n    level = 0\n\n    while q:\n        size = len(q)\n        for i in range(size):\n            x = q.popleft()\n            if x == goal:\n                return level\n            for num in nums:\n                next_x = x + num\n                if 0 <= next_x <= 1000 and next_x not in seen:\n                    seen.add(next_x)\n                    q.append(next_x)\n        level += 1\n\n    return -1", "def are_encoded_strings_equal(s1: str, s2: str) -> bool:\n    decoded1, decoded2 = \"\", \"\"\n\n    for i, c in enumerate(s1):\n        if c.isdigit():\n            count = int(c)\n            decoded1 += s1[i - 1] * count\n        else:\n            decoded1 += c\n\n    for i, c in enumerate(s2):\n        if c.isdigit():\n            count = int(c)\n            decoded2 += s2[i - 1] * count\n        else:\n            decoded2 += c\n\n    return decoded1 == decoded2", "def count_prefixes(words, pref):\n    return sum(1 for word in words if word.startswith(pref))", "def count_vowel_substrings(word: str) -> int:\n    count = 0\n    n = len(word)\n    vowels = set()\n\n    for i in range(n):\n        if word[i] in \"aeiou\":\n            vowels.clear()\n            for j in range(i, n):\n                if word[j] in \"aeiou\":\n                    vowels.add(word[j])\n                if len(vowels) == 5:\n                    count += 1\n    return count", "def sum_of_vowels_in_the_substrings(word: str) -> int:\n    total_sum = 0\n    n = len(word)\n\n    for i, char in enumerate(word):\n        if char in {'a', 'e', 'i', 'o', 'u'}:\n            total_sum += (i + 1) * (n - i)\n\n    return total_sum", "def min_x(n, quantities):\n    total_products = sum(quantities)\n    return (total_products + n - 1) // n", "from collections import defaultdict\n\ndef maxQualityRec(adjDict, values, node, timeLeft, visited):\n    if timeLeft < 0:\n        return float('-inf')\n\n    maxQuality = 0\n    visited.add(node)\n    for neighbor, time in adjDict[node]:\n        adjDict[neighbor].remove((node, time))\n        maxQuality = max(maxQuality, maxQualityRec(adjDict, values, neighbor, timeLeft - time, visited))\n        adjDict[neighbor].append((node, time))\n    \n    visited.remove(node)\n    return maxQuality + (values[node] if node not in visited else 0)\n\ndef maxQuality(n, values, edges, maxTime):\n    adjDict = defaultdict(list)\n    for u, v, time in edges:\n        adjDict[u].append((v, time))\n        adjDict[v].append((u, time))\n\n    visited = set()\n    return maxQualityRec(adjDict, values, 0, maxTime, visited)", "def count_once_in_both(words1, words2):\n    counter1 = {}\n    counter2 = {}\n\n    for word in words1:\n        counter1[word] = counter1.get(word, 0) + 1\n    for word in words2:\n        counter2[word] = counter2.get(word, 0) + 1\n\n    count = 0\n    for item in counter1.items():\n        if item[1] == 1 and counter2.get(item[0], 0) == 1:\n            count += 1\n\n    return count", "def min_buckets(street):\n    buckets = 0\n    i = 0\n    n = len(street)\n    while i < n:\n        if street[i] == 'H':\n            if i + 1 < n and street[i + 1] == '.':\n                buckets += 1\n                i += 2\n            elif i + 2 < n and street[i + 2] == '.':\n                buckets += 1\n                i += 3\n            else:\n                return -1\n        else:\n            i += 1\n    return buckets", "def min_cost(grid, start_pos, home_pos, row_costs, col_costs):\n    return abs(row_costs[start_pos[0]] - row_costs[home_pos[0]]) + abs(col_costs[start_pos[1]] - col_costs[home_pos[1]])", "def count_pyramids(grid):\n    m, n, count = len(grid), len(grid[0]), 0\n    for i in range(1, m - 1):\n        for j in range(1, n - 1):\n            if grid[i][j] == grid[i - 1][j] + grid[i][j - 1] - grid[i - 1][j - 1] \\\n                and grid[i][j] == grid[i + 1][j] + grid[i][j + 1] - grid[i + 1][j + 1]:\n                count += grid[i][j]\n    return count", "def cell_range(s):\n    r1 = int(s[1])\n    r2 = int(s[4])\n    c1 = ord(s[0]) - ord('A') + 1\n    c2 = ord(s[3]) - ord('A') + 1\n\n    res = []\n    for c in range(c1, c2 + 1):\n        for r in range(r1, r2 + 1):\n            res.append(chr(ord('A') + c - 1) + str(r))\n    return res", "def time_to_buy_tickets(tickets, k):\n    time = 0\n    while tickets[k] > 0:\n        for i in range(len(tickets)):\n            if tickets[i] > 0:\n                tickets[i] -= 1\n                time += 1\n                if i == k and tickets[k] == 0:\n                    return time\n    return time", "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef reverse_even_groups(head: ListNode) -> ListNode:\n    dummy = ListNode(-1)\n    dummy.next = head\n    prev, curr = dummy, head\n    count = 0\n    while curr:\n        count += 1\n        curr = curr.next\n    curr = head\n    i = 2\n    while i <= count:\n        next_group_head = curr\n        for _ in range(i):\n            if not next_group_head:\n                break\n            next_group_head = next_group_head.next\n        prev_group_tail = prev\n        for _ in range(i):\n            if not curr:\n                break\n            next_node = curr.next\n            curr.next = prev_group_tail.next\n            prev_group_tail.next = curr\n            curr = next_node\n        for _ in range(i):\n            prev = prev.next\n        i += 2\n    return dummy.next", "def decode_slanted_cipher(encoded_text, rows):\n    matrix = ['' for _ in range(rows)]\n    index = 0\n\n    for diagonal in range(2 * (rows - 1)):\n        for row in range(max(0, diagonal - rows + 1), min(diagonal, rows - 1) + 1):\n            if index < len(encoded_text):\n                matrix[row] += encoded_text[index]\n                index += 1\n\n    return ''.join(matrix)", "from collections import defaultdict\n\ndef check_friends(n, restrictions, requests):\n    friends = defaultdict(set)\n    for a, b in restrictions:\n        friends[a].add(b)\n        friends[b].add(a)\n\n    result = []\n    for a, b in requests:\n        if b not in friends[a] and a not in friends[b]:\n            friends[a].add(b)\n            friends[b].add(a)\n            result.append(True)\n        else:\n            result.append(False)\n    return result", "def can_fit_stamps(grid, stampHeight, stampWidth):\n    m, n = len(grid), len(grid[0])\n    for i in range(m - stampHeight + 1):\n        for j in range(n - stampWidth + 1):\n            canFit = True\n            for x in range(stampHeight):\n                for y in range(stampWidth):\n                    if grid[i + x][j + y] == 1:\n                        canFit = False\n                        break\n                if not canFit:\n                    break\n            if canFit:\n                return True\n    return False", "def arrange_pairs(pairs):\n    adj = {pair[0]: pair for pair in pairs}\n    result = []\n    start = pairs[0][0]\n\n    while adj:\n        pair = adj.pop(start)\n        result.append(pair)\n        start = pair[1]\n\n    return result", "def to_base_k(num, k):\n    base_k_num = ''\n    while num:\n        base_k_num = str(num % k) + base_k_num\n        num //= k\n    return base_k_num\n\ndef is_k_mirror(num, k):\n    base_10_num = str(num)\n    base_k_num = to_base_k(num, k)\n    return base_10_num == base_10_num[::-1] and base_k_num == base_k_num[::-1]\n\ndef sum_k_mirror_numbers(k, n):\n    total = 0\n    num = 0\n    while n:\n        if is_k_mirror(num, k):\n            total += num\n            n -= 1\n        num += 1\n    return total", "from heapq import heappop, heappush\nfrom sys import maxsize\n\ndef dijkstra(src, adj):\n    dist = [maxsize] * len(adj)\n    dist[src] = 0\n    pq = [(0, src)]\n\n    while pq:\n        d, u = heappop(pq)\n        if d != dist[u]:\n            continue\n        for v, w in adj[u]:\n            if d + w < dist[v]:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\ndef min_weight_subgraph(n, edges, src1, src2, dest):\n    adj = [[] for _ in range(n)]\n    for u, v, w in edges:\n        adj[u].append((v, w))\n\n    dist1 = dijkstra(src1, adj)\n    dist2 = dijkstra(src2, adj)\n\n    res = dist1[dest] + dist2[dest]\n    for u, v, w in edges:\n        res = min(res, dist1[u] + dist2[v] + w)\n        res = min(res, dist1[v] + dist2[u] + w)\n\n    return res if res != maxsize else -1", "import heapq\n\ndef largest_sum_sequence(nums, k):\n    min_heap = []\n    \n    for num in nums:\n        heapq.heappush(min_heap, num)\n        if len(min_heap) > k:\n            heapq.heappop(min_heap)\n    \n    result = [0] * k\n    for i in range(k-1, -1, -1):\n        result[i] = heapq.heappop(min_heap)\n    \n    return result", "from typing import List\n\ndef max_bombs_detonated(bombs: List[List[int]]) -> int:\n    n = len(bombs)\n    max_bombs = 0\n\n    for i in range(n):\n        count = 0\n        for j in range(n):\n            dx = bombs[i][0] - bombs[j][0]\n            dy = bombs[i][1] - bombs[j][1]\n            distance = dx * dx + dy * dy\n            range_ = bombs[i][2] * bombs[i][2] + bombs[j][2] * bombs[j][2]\n            if distance <= range_:\n                count += 1\n        max_bombs = max(max_bombs, count)\n\n    return max_bombs", "import heapq\n\ndef min_operations(nums):\n    max_heap = [-num for num in nums]\n    heapq.heapify(max_heap)\n    initial_sum = sum(nums)\n    target_sum = initial_sum // 2\n    sum_so_far = 0\n    operations = 0\n\n    while sum_so_far <= target_sum:\n        largest = -heapq.heappop(max_heap)\n        sum_so_far += largest // 2\n        operations += 1\n\n    return operations", "def minVisibleWhiteTiles(floor: str, numCarpets: int, carpetLen: int) -> int:\n    n, res = len(floor), len(floor)\n    for i in range(n - carpetLen + 1):\n        count = sum(1 for j in range(carpetLen) if floor[i + j] == '1')\n        for k in range(1, numCarpets + 1):\n            if k * carpetLen - 1 <= i + carpetLen:\n                res = min(res, n - count * k)\n                if i + carpetLen < n:\n                    count -= floor[i + carpetLen - k * carpetLen] == '1'\n                    count += floor[i + carpetLen] == '1'\n    return res", "def sorted_target_indices(nums, target):\n    result = [i for i, num in enumerate(nums) if num == target]\n    return sorted(result)", "def k_radius_average(nums, k):\n    n = len(nums)\n    avgs = [-1] * n\n    for i in range(k, n - k):\n        sum = 0\n        for j in range(i - k, i + k + 1):\n            sum += nums[j]\n        avgs[i] = sum // (2 * k + 1)\n    return avgs", "def min_deletions(nums):\n    n = len(nums)\n    if n <= 2:\n        return 0\n        \n    min_idx, max_idx = 0, 0\n\n    for i in range(1, n):\n        if nums[i] < nums[min_idx]:\n            min_idx = i\n        if nums[i] > nums[max_idx]:\n            max_idx = i\n\n    return min(max(min_idx, max_idx), n - min(min_idx, max_idx) - 1, min_idx + n - max_idx - 1)", "from collections import defaultdict\n\ndef people_with_secret(n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n    secret_holders = set([firstPerson])\n    meetings_by_time = defaultdict(list)\n\n    for meeting in meetings:\n        meetings_by_time[meeting[2]].append(tuple(meeting[:2]))\n        \n    for time in range(n):\n        if time in meetings_by_time:\n            for x, y in meetings_by_time[time]:\n                if x in secret_holders or y in secret_holders:\n                    secret_holders.add(x)\n                    secret_holders.add(y)\n\n    return list(secret_holders)", "def min_health(damage, armor):\n    health = 0\n    for dmg in reversed(damage):\n        health += dmg\n        if health > armor:\n            health -= armor\n            armor = 0\n    return health + 1", "from itertools import permutations\n\ndef unique_permutations(digits):\n    unique_perms = set(permutations(digits))\n    unique_ints = sorted({int(''.join(map(str, perm))) for perm in unique_perms})\n    \n    return unique_ints", "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef delete_middle(head):\n    if not head or not head.next:\n        return head\n    slow = head\n    fast = head\n    prev = None\n\n    while fast and fast.next:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n\n    prev.next = slow.next\n    return head", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef find_path(root, target, path):\n    if not root: return \"\"\n    if root.val == target: return path\n    left = find_path(root.left, target, path + \"L\")\n    right = find_path(root.right, target, path + \"R\")\n    return left if left else right\n\ndef shortest_path(root, start_value, dest_value):\n    s_path = find_path(root, start_value, \"\")\n    t_path = find_path(root, dest_value, \"\")\n    i = 0\n    while i < len(s_path) and i < len(t_path) and s_path[i] == t_path[i]: i += 1\n    res = \"U\" * (len(s_path) - i) + t_path[i:]\n    return res", "import heapq\n\ndef maxCoins(piles, k):\n    pq = []\n    for pile in piles:\n        for coin in pile:\n            heapq.heappush(pq, -coin)\n    \n    max_value = 0\n    while k > 0:\n        max_value += -heapq.heappop(pq)\n        k -= 1\n    return max_value", "def max_words_in_sentence(sentences):\n    max_words = 0\n    for sentence in sentences:\n        words = len(sentence.split())\n        max_words = max(max_words, words)\n    return max_words", "def is_valid_parentheses_string(s: str, locked: str) -> bool:\n    balance = 0\n    for i in range(len(s)):\n        if locked[i] == '0':\n            balance += 1 if s[i] == '(' else -1\n            if balance < 0:\n                return False\n    return balance == 0", "def abbreviated_product(left: int, right: int) -> str:\n    product = 1\n    for i in range(left, right + 1):\n        product *= i\n    return str(product)", "def string_sum_scores(s):\n    score = 0\n    prefix_length = 0\n\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == s[-1]:\n            prefix_length += 1\n        else:\n            prefix_length = 0\n        score += prefix_length\n        \n    return score", "def minimum_operations(current: str, correct: str) -> int:\n    ch, cm = map(int, current.split(':'))\n    th, tm = map(int, correct.split(':'))\n    ct = ch * 60 + cm\n    tt = th * 60 + tm\n\n    operations = 0\n    while ct < tt:\n        if tt - ct >= 60:\n            ct += 60\n        elif tt - ct >= 15:\n            ct += 15\n        elif tt - ct >= 5:\n            ct += 5\n        else:\n            ct += 1\n\n        operations += 1\n\n    return operations", "from collections import defaultdict\nfrom typing import List, Set\n\ndef twoLists(matches: List[List[int]]) -> List[Set[int]]:\n    loss_count = defaultdict(int)\n    participants = set()\n    \n    for winner, loser in matches:\n        loss_count[loser] += 1\n        participants.add(winner)\n        participants.add(loser)\n    \n    no_losses = {participant for participant in participants if loss_count[participant] == 0}\n    one_loss = {participant for participant in participants if loss_count[participant] == 1}\n    \n    return [no_losses, one_loss]", "def count_rods_with_all_colors(rings: str) -> int:\n    rod_colors = [0] * 10\n\n    for i in range(0, len(rings), 2):\n        color = ord(rings[i]) - ord('A')\n        rod = int(rings[i + 1])\n\n        rod_colors[rod] |= (1 << color)\n\n    return rod_colors.count(7)", "def sum_of_subarray_ranges(nums):\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i, n):\n            ans += max(nums[i:j+1]) - min(nums[i:j+1])\n    return ans", "from bisect import bisect_left\n\ndef maxFruits(fruits, startPos, k):\n    n = len(fruits)\n    left, right = [0] * (n + 1), [0] * (n + 1)\n    j = 0\n\n    for i in range(n):\n        while j < n and fruits[j][0] - fruits[i][0] <= k:\n            right[i + 1] += fruits[j][1]\n            j += 1\n        right[i + 1] += right[i]\n        if j < n and fruits[j][0] - startPos <= k:\n            right[0] += fruits[j][1]\n            j += 1\n\n    j = n - 1\n    for i in range(n - 1, -1, -1):\n        while j >= 0 and fruits[j][0] - fruits[i][0] <= k:\n            left[i] += fruits[j][1]\n            j -= 1\n        left[i] += left[i + 1]\n\n    ans = 0\n    for i in range(n):\n        rest = max(0, k - abs(fruits[i][0] - startPos))\n        idx = bisect_left(fruits, [fruits[i][0] + rest, 0])\n        ans = max(ans, left[i] + right[idx])\n\n    return ans", "def first_palindrome(words):\n    for word in words:\n        if word == word[::-1]:\n            return word\n    return \"\"", "def add_spaces(s: str, spaces: List[int]) -> str:\n    result = []\n    j = 0\n    for i, c in enumerate(s):\n        while j < len(spaces) and i == spaces[j]:\n            result.append(' ')\n            j += 1\n        result.append(c)\n    return ''.join(result)", "def smooth_descent_periods(prices):\n    count = 0\n    i = 1\n    while i < len(prices):\n        if prices[i] == prices[i - 1] - 1:\n            while i < len(prices) and prices[i] == prices[i - 1] - 1:\n                i += 1\n            count += 1\n        else:\n            i += 1\n    return count", "def min_operations_to_K_increasing(arr, k):\n    operations = 0\n    for i in range(k, len(arr)):\n        if arr[i] <= arr[i - k]:\n            operations += (arr[i - k] - arr[i] + 1)\n            arr[i] = arr[i - k] + 1\n    return operations", "def capitalize_title(title):\n    return ' '.join([word.capitalize() for word in title.split(' ')])", "def max_twin_sum(head):\n    sum = 0\n    max_sum = 0\n    i = 0\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n        fast = fast.next.next\n        i += 1\n\n    for j in range(i):\n        sum = slow.val + fast.val\n        max_sum = max(max_sum, sum)\n        slow = slow.next\n        fast = fast.prev\n\n    return max_sum", "def longest_palindrome(words):\n    from collections import defaultdict\n    dict = defaultdict(int)\n    result = 0\n    has_odd = False\n\n    for word in words:\n        dict[word[0]] += 1\n        dict[word[1]] += 1\n\n    for count in dict.values():\n        result += count // 2 * 2\n        has_odd |= count % 2\n\n    return result + has_odd", "def robot_instructions(n: int, start_pos: list, s: str) -> list:\n    answer = [0] * len(s)\n\n    for idx in range(len(s)):\n        row, col = start_pos\n\n        for i in range(idx, len(s)):\n            move = s[i]\n            if move == 'L':\n                col -= 1\n            elif move == 'R':\n                col += 1\n            elif move == 'U':\n                row -= 1\n            elif move == 'D':\n                row += 1\n\n            if row < 0 or row >= n or col < 0 or col >= n:\n                break\n\n            answer[idx] += 1\n\n    return answer", "from collections import defaultdict\n\ndef sum_of_intervals(arr):\n    n = len(arr)\n    indices = defaultdict(list)\n    intervals = [0] * n\n\n    for i in range(n):\n        indices[arr[i]].append(i)\n\n    for i in range(n):\n        for index in indices[arr[i]]:\n            intervals[i] += abs(index - i)\n\n    return intervals", "def recoverArray(n, nums):\n    nums.sort()\n    arr = [nums[i * 2] for i in range(n)]\n    return arr", "def maxScore(scores, edges):\n    adj_list = [[] for _ in range(len(scores))]\n    result = -1\n\n    for edge in edges:\n        adj_list[edge[0]].append(edge[1])\n        adj_list[edge[1]].append(edge[0])\n\n    for edge in edges:\n        for neighbor in adj_list[edge[0]]:\n            for next in adj_list[edge[1]]:\n                if next != neighbor and next != edge[0]:\n                    result = max(result, scores[edge[0]] + scores[edge[1]] + scores[neighbor] + scores[next])\n\n    return result", "def is_a_only_before_b(s: str) -> bool:\n    last_index_a = -1\n    for i, c in enumerate(s):\n        if c == 'a':\n            last_index_a = i\n        elif c == 'b' and last_index_a > -1:\n            return False\n    return True", "def numOfBeams(bank):\n    m = len(bank)\n    n = len(bank[0])\n    beams = 0\n\n    for i in range(m):\n        for j in range(n):\n            if bank[i][j] == '1':\n                k = j + 1\n                while k < n and bank[i][k] != '1':\n                    beams += bank[i][k] == '0'\n                    k += 1\n                k = i + 1\n                while k < m and bank[k][j] != '1':\n                    beams += bank[k][j] == '0'\n                    k += 1\n\n    return beams", "def can_destroy_all_asteroids(mass, asteroids):\n    asteroids.sort()\n    for asteroid in asteroids:\n        if mass >= asteroid:\n            mass += asteroid\n        else:\n            return False\n    return True", "def max_invites(favorite):\n    n = len(favorite)\n    dp = [0] * n\n    max_invites = 0\n\n    for i in range(n):\n        dp[i] = 2 if i == favorite[favorite[i]] else 1\n        max_invites = max(max_invites, dp[i])\n\n    return max_invites", "def dfs(curr_city, remaining_highways, cost_so_far, highways, visited):\n    if remaining_highways == 0:\n        return cost_so_far\n\n    visited[curr_city] = True\n    max_cost = -1\n\n    for highway in highways:\n        next_city = -1\n        if highway[0] == curr_city and not visited[highway[1]]:\n            next_city = highway[1]\n        elif highway[1] == curr_city and not visited[highway[0]]:\n            next_city = highway[0]\n\n        if next_city != -1:\n            cost = dfs(next_city, remaining_highways - 1, cost_so_far + highway[2], highways, visited)\n            max_cost = max(max_cost, cost)\n\n    visited[curr_city] = False\n    return max_cost\n\ndef max_cost(n, highways, k):\n    visited = [False] * n\n    max_cost = -1\n\n    for i in range(n):\n        cost = dfs(i, k, 0, highways, visited)\n        max_cost = max(max_cost, cost)\n\n    return max_cost", "def min_cost(cost):\n    cost.sort(reverse=True)\n    n = len(cost)\n    min_cost = 0\n\n    for i in range(0, n, 3):\n        min_cost += cost[i]\n        if i+1 < n:\n            min_cost += cost[i+1]\n\n    return min_cost", "def count_sequences(differences, lower, upper):\n    count = 0\n    n = len(differences)\n    hidden = [0] * (n + 1)\n\n    hidden[0] = lower\n    while True:\n        valid = True\n        for i in range(1, n + 1):\n            hidden[i] = hidden[i - 1] + differences[i - 1]\n            if hidden[i] < lower or hidden[i] > upper:\n                valid = False\n                break\n        if valid: count += 1\n\n        if hidden[0] == upper: break\n        hidden[0] += 1\n    \n    return count", "from heapq import heappush, heappop\n\ndef kHighestRankedItems(grid, pricing, start, k):\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = []\n    pq = []\n    visited = [[False for _ in range(n)] for _ in range(m)]\n\n    heappush(pq, (0, -grid[start[0]][start[1]], start[0], start[1]))\n    visited[start[0]][start[1]] = True\n\n    while pq and k > 0:\n        size = len(pq)\n        for _ in range(size):\n            curr = heappop(pq)\n            steps, price, row, col = curr\n\n            if pricing[0] <= -price <= pricing[1]:\n                res.append([row, col])\n                k -= 1\n\n            for dr, dc in directions:\n                newRow, newCol = row + dr, col + dc\n                if 0 <= newRow < m and 0 <= newCol < n and not visited[newRow][newCol]:\n                    visited[newRow][newCol] = True\n                    heappush(pq, (steps + 1, -grid[newRow][newCol], newRow, newCol))\n\n    return res", "MOD = 10**9 + 7\n\ndef corridor_ways(corridor):\n    n = len(corridor)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    seats = 0\n    for i in range(n):\n        if corridor[i] == 'S':\n            seats += 1\n            if seats % 2 == 0:\n                dp[i + 1] = dp[max(0, i - 1)]\n            dp[i + 1] = (dp[i] + dp[i + 1]) % MOD\n        else:\n            dp[i + 1] = dp[i]\n\n    return dp[n]", "def isValidMatrix(matrix):\n    n = len(matrix)\n    for i in range(n):\n        row = set(matrix[i])\n        col = set(matrix[j][i] for j in range(n))\n        if len(row) != n or len(col) != n:\n            return False\n    return True", "def minSwaps(nums):\n    ones = maxOnes = currOnes = left = 0\n\n    for num in nums:\n        ones += num\n\n    for right in range(len(nums)):\n        currOnes += nums[right]\n\n        if right - left + 1 > ones:\n            currOnes -= nums[left]\n            left += 1\n\n        maxOnes = max(maxOnes, currOnes)\n\n    return ones - maxOnes", "def count_convertible_words(start_words, target_words):\n    count = 0\n    for target in target_words:\n        for start in start_words:\n            if len(start) + 1 == len(target) and target.startswith(start):\n                count += 1\n                break\n    return count", "def earliest_blooming_day(plant_time, grow_time):\n    bloom_time = [plant_time[i] + grow_time[i] for i in range(len(plant_time))]\n    bloom_time.sort()\n    earliest_day = 0\n    for i in bloom_time:\n        earliest_day = max(earliest_day, i)\n        earliest_day += 1\n    return earliest_day", "from collections import deque\n\ndx = [0, 1, 0, -1]\ndy = [1, 0, -1, 0]\n\ndef getMaxSafeMinutes(grid):\n    m, n = len(grid), len(grid[0])\n    dist = [[-1 for _ in range(n)] for _ in range(m)]\n    q = deque()\n\n    if grid[m - 1][n - 1] != 1:\n        dist[m - 1][n - 1] = 0\n        q.append((m - 1, n - 1))\n\n    while q:\n        x, y = q.popleft()\n        for d in range(4):\n            nx, ny = x + dx[d], y + dy[d]\n            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and dist[nx][ny] == -1:\n                dist[nx][ny] = dist[x][y] + 1\n                q.append((nx, ny))\n\n    if dist[0][0] == -1:\n        return -1\n\n    res = 0\n    for test in range(dist[0][0], int(1e9)):\n        ok = True\n        for x in range(m):\n            for y in range(n):\n                if grid[x][y] == 1:\n                    for d in range(4):\n                        nx, ny = x + dx[d], y + dy[d]\n                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 2:\n                            break\n                    else:\n                        ok = False\n                        break\n        if ok:\n            res = test\n        else:\n            break\n    return res", "def max_number_after_remove_digit(number: str, digit: str) -> str:\n    index = number.find(digit)\n    return number[:index] + number[index + 1:]", "def partition_string(s, k, fill):\n    partitions = []\n    current_partition = ''\n    for c in s:\n        current_partition += c\n        if len(current_partition) == k:\n            partitions.append(current_partition)\n            current_partition = ''\n    if current_partition:\n        current_partition += fill * (k - len(current_partition))\n        partitions.append(current_partition)\n    return partitions", "def highestScoreDivisions(nums):\n    count0, count1 = 0, 0\n    for n in nums:\n        if n == 1:\n            count1 += 1\n            \n    max_score, current_score = -1, 0\n    result = []\n    for i, n in enumerate(nums):\n        if n == 0:\n            current_score += 1\n        else:\n            count1 -= 1\n            \n        if current_score > max_score:\n            max_score = current_score\n            result = [i]\n        elif current_score == max_score:\n            result.append(i)\n            \n    return result", "def max_points(questions):\n    n = len(questions)\n    dp = [0] * (n + 1)\n\n    for i in range(n - 1, -1, -1):\n        skip_next = i + questions[i][1]\n        dp[i] = max(dp[i + 1], questions[i][0] + (dp[skip_next] if skip_next < n else 0))\n\n    return dp[0]", "def max_running_time(n, batteries):\n    batteries.sort(reverse=True)\n    total_time = sum(batteries[:n])\n    return total_time // n", "def split_and_minimize(num):\n    a = num // 1000\n    b = (num % 1000) // 100\n    c = (num % 100) // 10\n    d = num % 10\n    return ((a * 10 + c) * 10 + b) * 10 + d", "def rearrange_array_around_pivot(nums, pivot):\n    return sorted(nums, key=lambda x: (x >= pivot, x))", "def min_cost(startAt, moveCost, pushCost, targetSeconds):\n    min_cost = float('inf')\n\n    for i in range(100):\n        for j in range(100):\n            if i * 60 + j == targetSeconds:\n                minute_move_cost = abs(i - startAt) * moveCost\n                second_move_cost = abs(j - i) * moveCost\n                total_push_cost = (2 if j > 0 else 0) + (1 if j // 10 != 0 else 0) + (1 if i // 10 != 0 else 0)\n                \n                min_cost = min(min_cost, minute_move_cost + second_move_cost + total_push_cost * pushCost)\n\n    return min_cost", "def minDifference(nums):\n    n = len(nums) // 3\n    prefix, suffix = [0] * (n + 2), [0] * (n + 2)\n    \n    window = sorted(nums[:n])\n    prefix[0] = sum(window)\n    \n    for i in range(n, 2 * n):\n        window.remove(nums[i - n])\n        bisect.insort(window, nums[i])\n        prefix[i - n + 1] = sum(window)\n\n    window = sorted(nums[-n:])\n    suffix[n] = sum(window)\n    \n    for i in range(2 * n - 1, n - 1, -1):\n        j = 3 * n - i - 1\n        window.remove(nums[j])\n        idx = bisect_left(window, nums[n * 2 - j - 1])\n        window.insert(idx, nums[n * 2 - j - 1])\n        suffix[i] = sum(window)\n\n    return min(abs(a - b) for a, b in zip(prefix, suffix))", "def min_keypresses(s: str) -> int:\n    keypresses = [(i % 9) + 1 for i in range(26)]\n    result = 0\n    for c in s:\n        result += keypresses[ord(c) - ord('a')]\n    return result", "def num_elements_with_smaller_and_greater(nums):\n    n = len(nums)\n    res = 0\n    for i in range(n):\n        has_smaller = has_greater = False\n        for j in range(n):\n            if i == j:\n                continue\n            if nums[j] > nums[i]:\n                has_greater = True\n            if nums[j] < nums[i]:\n                has_smaller = True\n            if has_smaller and has_greater:\n                res += 1\n                break\n    return res", "def lonely_numbers(nums):\n    num_set = set(nums)\n    lonely = []\n    for num in nums:\n        if num - 1 not in num_set and num + 1 not in num_set:\n            lonely.append(num)\n    return lonely", "def rearrange_array(nums):\n    nums.sort()\n    half = len(nums) // 2\n    result = [0] * len(nums)\n    j = 0\n    for i in range(half):\n        result[j] = nums[i]\n        result[j + 1] = nums[half + i]\n        j += 2\n    return result", "def maximum_good_people(statements):\n    n = len(statements)\n    count_good = 0\n    for i in range(n):\n        is_good = True\n        for j in range(n):\n            if statements[j][i] == 1 and statements[i][j] == 0:\n                is_good = False\n                break\n        if is_good:\n            count_good += 1\n    return count_good", "def anagramOperations(words):\n    i = 1\n    while i < len(words):\n        word1 = sorted(words[i])\n        word2 = sorted(words[i - 1])\n        if word1 == word2:\n            del words[i]\n        else:\n            i += 1\n    return words", "def final_value(nums, original):\n    while original in nums:\n        original += 1\n    return original", "def find_substring(s, power, modulo, k, hash_value):\n    current_hash = 0\n    power_k = 1\n\n    for i in range(k):\n        current_hash = (current_hash * power + (ord(s[i]) - ord('a') + 1)) % modulo\n        power_k = (power_k * power) % modulo\n\n    if current_hash == hash_value:\n        return s[:k]\n\n    for i in range(k, len(s)):\n        current_hash = ((current_hash - (ord(s[i - k]) - ord('a') + 1) * power_k) % modulo + modulo) % modulo\n        current_hash = (current_hash * power + (ord(s[i]) - ord('a') + 1)) % modulo\n        if current_hash == hash_value:\n            return s[i - k + 1:i + 1]\n\n    raise AssertionError(\"No matching substring found\")", "def group_strings(words):\n    groups = {}\n    groups_count = 0\n\n    for word in words:\n        s_key = ''.join(sorted(word))\n\n        if s_key not in groups:\n            groups[s_key] = groups_count\n            groups_count += 1\n\n    return [groups_count, len(words) - groups_count]", "from collections import deque\n\ndef closest_nodes(n, edges, query):\n    answer = []\n    tree = [[] for _ in range(n)]\n    \n    for edge in edges:\n        tree[edge[0]].append(edge[1])\n        tree[edge[1]].append(edge[0])\n    \n    def bfs(start, end):\n        queue = deque([start])\n        visited = {start}\n        \n        while queue:\n            current = queue.popleft()\n            \n            if current == end:\n                return current\n            \n            for neighbor in tree[current]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n                    visited.add(neighbor)\n    \n    for q in query:\n        lca = bfs(q[0], q[1])\n        node1 = bfs(lca, q[0])\n        node2 = bfs(lca, q[1])\n        answer.append(q[0] if node1 == q[2] else q[1])\n    \n    return answer", "def three_consecutive_integers(num):\n    if num % 3 == 0:\n        return [num // 3 - 1, num // 3, num // 3 + 1]\n    elif num % 3 == 1:\n        return [(num - 2) // 3, (num + 1) // 3, (num + 4) // 3]\n    else:\n        return []", "def max_unique_even_sum(final_sum):\n    result = []\n    current = 2\n    while final_sum > 0:\n        if final_sum >= current:\n            result.append(current)\n            final_sum -= current\n            current += 2\n        else:\n            break\n    return result", "def count_good_triplets(nums1: list, nums2: list) -> int:\n    n = len(nums1)\n    pos1 = [0] * n\n    pos2 = [0] * n\n    for i in range(n):\n        pos1[nums1[i]] = i\n        pos2[nums2[i]] = i\n    count = 0\n    for x in range(n):\n        for y in range(x + 1, n):\n            for z in range(y + 1, n):\n                if pos1[x] < pos1[y] < pos1[z] and pos2[x] < pos2[y] < pos2[z]:\n                    count += 1\n    return count", "mod = 1000000007\ndef sum_of_strength(strength):\n    res, strength_len = 0, len(strength)\n    for i in range(strength_len):\n        minimum = total = strength[i]\n        for j in range(i, strength_len):\n            minimum = min(minimum, strength[j])\n            total += strength[j]\n            res = (res + minimum * total % mod) % mod\n    return res", "def visible_people(heights):\n    m, n = len(heights), len(heights[0])\n    answer = [[0 for _ in range(n)] for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            for k in range(j+1, n):\n                if heights[i][j] >= heights[i][k]:\n                    if heights[i][j] > heights[i][k]:\n                        answer[i][j] += 1\n                else:\n                    break\n            for k in range(i+1, m):\n                if heights[i][j] >= heights[k][j]:\n                    if heights[i][j] > heights[k][j]:\n                        answer[i][j] += 1\n                else:\n                    break\n\n    return answer", "def rearrange_array(nums):\n    nums.sort()\n    for i in range(1, len(nums) - 1, 2):\n        nums[i], nums[i + 1] = nums[i + 1], nums[i]\n    return nums", "def rearrange_digits(num):\n    if num == 0:\n        return 0\n    digits = sorted(str(num))\n    \n    if digits[0] != '-' and digits[0] == '0':\n        nonzero_index = next(index for index, digit in enumerate(digits) if digit != '0')\n        digits[0], digits[nonzero_index] = digits[nonzero_index], digits[0]\n    \n    return int(\"\".join(digits))", "class BitSet:\n    def __init__(self, size):\n        self.bits = [0] * ((size + 31) // 32)\n\n    def set(self, index):\n        self.bits[index // 32] |= (1 << (index % 32))\n\n    def get(self, index):\n        return (self.bits[index // 32] & (1 << (index % 32))) != 0", "def maxNumberOfCopies(s, target):\n    s_counts = [0] * 26\n    target_counts = [0] * 26\n\n    for c in s:\n        s_counts[ord(c) - ord('a')] += 1\n\n    for c in target:\n        target_counts[ord(c) - ord('a')] += 1\n\n    max_copies = float('inf')\n    for i in range(26):\n        if target_counts[i] > 0:\n            max_copies = min(max_copies, s_counts[i] // target_counts[i])\n    return max_copies", "def operations(num1, num2):\n    count = 0\n    while num1 != 0 and num2 != 0:\n        if num1 >= num2:\n            num1 -= num2\n        else:\n            num2 -= num1\n        count += 1\n    return count", "def min_operations(nums):\n    n = len(nums)\n    even, odd = 0, 0\n\n    for i in range(n):\n        if i % 2 == 0 and nums[i] % 2 != 0:\n            even += 1\n        elif i % 2 != 0 and nums[i] % 2 == 0:\n            odd += 1\n\n    return min(even, odd)", "def min_number_of_beans_to_remove(beans):\n    count = {}\n    for bean in beans:\n        if bean not in count:\n            count[bean] = 0\n        count[bean] += 1\n\n    min_remove = len(beans)\n    for key, value in count.items():\n        remove = 0\n        for other_key, other_value in count.items():\n            if other_key != key:\n                remove += other_value * max(0, other_key - key)\n        min_remove = min(min_remove, remove)\n\n    return min_remove", "def max_and_sum(nums, num_slots):\n    slot = [0] * (num_slots + 1)\n    for num in nums:\n        for j in range(num_slots, 0, -1):\n            new_val = num & j\n            if new_val > slot[j]:\n                slot[j] = new_val\n\n    return sum(slot)", "def min_steps(s: str, t: str) -> int:\n    char_count = {}\n    for c in s:\n        char_count[c] = char_count.get(c, 0) + 1\n    for c in t:\n        char_count[c] = char_count.get(c, 0) - 1\n    \n    steps = sum(abs(count) for count in char_count.values())\n    \n    return steps // 2", "def minimum_time_for_trips(time, total_trips):\n    time.sort()\n\n    start, end = 0, time[-1] * total_trips\n    while start < end:\n        mid = start + (end - start) // 2\n        trips = sum(mid // t for t in time)\n        if trips < total_trips:\n            start = mid + 1\n        else:\n            end = mid\n\n    return start", "def min_race_time(tires, changeTime, numLaps):\n    n = len(tires)\n    times = [fi + (numLaps - 1) * ri for fi, ri in tires]\n    min_time = min(times) + (numLaps - 1) * changeTime\n    \n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                min_time = min(min_time, times[i] + times[j] - tires[i][0] + (numLaps - 2) * changeTime)\n    return min_time", "class TextEditor:\n    def __init__(self):\n        self.text = \"\"\n        self.cursor = 0\n\n    def addText(self, newText: str) -> None:\n        self.text = self.text[:self.cursor] + newText + self.text[self.cursor:]\n        self.cursor += len(newText)\n        \n    def deleteText(self, k: int) -> int:\n        deleted = min(k, self.cursor)\n        self.text = self.text[:self.cursor - deleted] + self.text[self.cursor:]\n        self.cursor -= deleted\n        return deleted\n\n    def cursorLeft(self, k: int) -> str:\n        self.cursor -= min(k, self.cursor)\n        return self.text[max(0, self.cursor - 10):self.cursor]\n        \n    def cursorRight(self, k: int) -> str:\n        self.cursor += min(k, len(self.text) - self.cursor)\n        return self.text[max(0, self.cursor - 10):self.cursor]", "def minHeightJump(nums, costs):\n    n = len(nums)\n    dp = [float('inf')] * n\n\n    dp[0] = 0\n    for i in range(1, n):\n        for j in range(i - 1, -1, -1):\n            if ((nums[j] <= nums[i] and (j == 0 or nums[j - 1] < nums[i])) or (nums[j] > nums[i] and (j == 0 or nums[j - 1] >= nums[i]))):\n                dp[i] = min(dp[i], dp[j] + costs[i])\n\n    return dp[n - 1]", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef merge_nodes_between_zeros(head: ListNode) -> ListNode:\n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n    cur = head\n\n    while cur:\n        if cur.val == 0:\n            tmp_sum = 0\n            while cur.next and cur.next.val != 0:\n                tmp_sum += cur.next.val\n                cur = cur.next\n            prev.next = ListNode(tmp_sum)\n            prev = prev.next\n            cur = cur.next\n\n    return dummy.next", "def repeat_limited_string(s, repeat_limit):\n    result = []\n    sorted_s = sorted(s, reverse=True)\n    \n    for c in sorted_s:\n        pos = result.count(c)\n        \n        if pos < repeat_limit:\n            result.insert(pos, c)\n\n    return \"\".join(result)", "def count_pairs(nums, k):\n    mod_count = [0] * k\n    count = 0\n\n    for num in nums:\n        mod_count[num % k] += 1\n\n    count += mod_count[0] * (mod_count[0] - 1) // 2\n\n    for i in range(1, k // 2 + 1):\n        if i != k - i:\n            count += mod_count[i] * mod_count[k-i]\n        else:\n            count += mod_count[i] * (mod_count[i] - 1) // 2\n\n    return count", "def countSubarrays(nums: List[int], k: int) -> int:\n    n = len(nums)\n    left, right = 0, 0\n    sum_, count = 0, 0\n\n    while right < n:\n        sum_ += nums[right]\n        while sum_ * (right - left + 1) >= k:\n            sum_ -= nums[left]\n            left += 1\n        count += right - left + 1\n        right += 1\n\n    return count", "def tax_amount(brackets, income):\n    tax = 0\n    prev_upper = 0\n    for upper, percent in brackets:\n        tax += (min(upper, income) - prev_upper) * (percent / 100)\n        prev_upper = upper\n        if income <= upper:\n            break\n    return tax", "def excel_sheet_cells(s: str):\n    c1, r1, c2, r2 = s.split(':')\n    r1, r2 = int(r1[1:]), int(r2[1:])\n    c1, c2 = ord(c1[0]), ord(c2[0])\n    result = []\n\n    for c in range(c1, c2 + 1):\n        for r in range(r1, r2 + 1):\n            result.append(chr(c) + str(r))\n\n    return result", "def min_append_k_sum(nums, k):\n    max_elem = max(nums)\n    return sum(range(max_elem + 1, max_elem + k + 1))", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef construct_tree(descriptions):\n    nodes = {}\n\n    for d in descriptions:\n        nodes[d[0]] = TreeNode(d[0])\n        nodes[d[1]] = TreeNode(d[1])\n\n    for d in descriptions:\n        if d[2]:\n            nodes[d[0]].left = nodes[d[1]]\n        else:\n            nodes[d[0]].right = nodes[d[1]]\n\n    return nodes[descriptions[0][0]]", "from math import gcd\n\ndef modify_array(nums):\n    i = 1\n    while i < len(nums):\n        if gcd(nums[i-1], nums[i]) > 1:\n            nums.insert(i, 1)\n            i += 1\n        i += 1\n    return nums", "def get_max_occurrences(text: str, pattern: str) -> int:\n    count = [0, 0]\n    for c in text:\n        if c == pattern[1]:\n            count[1] += count[0]\n        elif c == pattern[0]:\n            count[0] += 1\n    return count[1]", "def min_operations(nums):\n    nums.sort(reverse=True)\n    total_sum = sum(nums)\n    half_sum, operations = 0, 0\n    for num in nums:\n        half_sum += num\n        operations += 1\n        if half_sum >= (total_sum + 1) // 2:\n            break\n    return operations", "def min_visible_white_tiles(floor, num_carpets, carpet_len):\n    n = len(floor)\n    visible_white_count = floor.count('1')\n\n    covered_tiles = 0\n    for i in range(n):\n        if floor[i] == '1':\n            start = max(0, i - carpet_len + 1)\n            end = min(n - carpet_len, i)\n            max_cover = 0\n            for first_tile in range(start, end + 1):\n                cover = floor[first_tile:first_tile + carpet_len].count('1')\n                max_cover = max(max_cover, cover)\n                          \n            covered_tiles += max_cover\n            num_carpets -= 1            \n            if num_carpets == 0:\n                break\n\n    return visible_white_count - covered_tiles", "def max_count_target(nums, key):\n    count = {}\n    max_count = 0\n    max_target = -1\n    for i in range(1, len(nums)):\n        if nums[i - 1] == key:\n            count[nums[i]] = count.get(nums[i], 0) + 1\n            if count[nums[i]] > max_count:\n                max_count = count[nums[i]]\n                max_target = nums[i]\n    return max_target", "class Node:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef min_operations(root, result):\n    if root is None:\n        return 0\n    if root.val <= 1:\n        return 0 if root.val == result else 1\n    else:\n        left_operations = min_operations(root.left, result ^ 1 if root.val == 4 else result)\n        right_operations = min_operations(root.right, result ^ 1 if root.val == 4 else result)\n        if root.val == 3:\n            return min(left_operations, right_operations)\n        elif root.val == 2:\n            return max(left_operations, right_operations)\n        else:\n            return left_operations + right_operations", "def count_stars_except_between_pair(s: str) -> int:\n    count = 0\n    pipe_count = 0\n\n    for c in s:\n        if c == '|':\n            pipe_count += 1\n        elif c == '*' and pipe_count % 2 == 0:\n            count += 1\n\n    return count", "def count_hills_valleys(nums):\n    count = 0\n    for i in range(1, len(nums) - 1):\n        if (nums[i] > nums[i - 1] and nums[i] > nums[i + 1]) or (nums[i] < nums[i - 1] and nums[i] < nums[i + 1]):\n            count += 1\n    return count", "def count_collisions(directions: str) -> int:\n    collision_count = 0\n    left_count = 0\n\n    for direction in directions:\n        if direction == 'L':\n            left_count += 1\n        elif direction == 'R':\n            collision_count += left_count\n\n    return collision_count", "def bob_arrows(num_arrows, alice_arrows):\n    bob = [0] * 12\n    for i in range(11, -1, -1):\n        if num_arrows > 0 and alice_arrows[i] == 0:\n            shot = min(num_arrows, i+1)\n            bob[i] = shot\n            num_arrows -= shot\n    return bob", "def longest_repeat_substring(s, query_characters, query_indices):\n    k = len(query_characters)\n    lengths = []\n    s_copy = list(s)\n\n    for i in range(k):\n        s_copy[query_indices[i]] = query_characters[i]\n        max_len = cur_len = 1\n        for j in range(1, len(s_copy)):\n            if s_copy[j] == s_copy[j-1]:\n                cur_len += 1\n            else:\n                max_len = max(max_len, cur_len)\n                cur_len = 1\n        max_len = max(max_len, cur_len)\n        lengths.append(max_len)\n\n    return lengths", "def k_distant_indices(nums, key, k):\n    result = []\n    for i in range(len(nums)):\n        for j in range(max(0, i - k), min(i + k + 1, len(nums))):\n            if nums[j] == key:\n                result.append(i)\n                break\n    return result", "import heapq\nfrom collections import defaultdict\n\ndef shortest_path(n, edges, src1, src2, dest):\n    graph = defaultdict(list)\n    \n    for u, v, w in edges:\n        graph[u].append((v, w))\n    \n    def dijkstra(src):\n        dist = [float('inf')] * n\n        pq = [(0, src)]\n\n        dist[src] = 0\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            if d != dist[u]:\n                continue\n\n            for v, w in graph[u]:\n                if dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    heapq.heappush(pq, (dist[v], v))\n\n        return dist\n\n    src1_to_all = dijkstra(src1)\n    src2_to_all = dijkstra(src2)\n\n    min_weight = float('inf')\n    for u, v, w in edges:\n        min_weight = min(min_weight, src1_to_all[u] + w + src2_to_all[v])\n\n    return -1 if min_weight == float('inf') else min_weight", "def dfs(node, parent, xor_values, tree):\n    xor_value = xor_values[node]\n    for child in tree[node]:\n        if child != parent:\n            xor_value ^= dfs(child, node, xor_values, tree)\n    return xor_value\n\n\ndef minimumScore(nums, edges):\n    n = len(nums)\n    tree = [[] for _ in range(n)]\n    \n    for edge in edges:\n        tree[edge[0]].append(edge[1])\n        tree[edge[1]].append(edge[0])\n    \n    xor_values = [dfs(i, -1, nums, tree) for i in range(n)]\n    \n    ans = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor1 = xor_values[i]\n            xor2 = xor_values[j] ^ nums[i]\n            xor3 = nums[i] ^ nums[j]\n            max_xor = max(xor1, xor2, xor3)\n            min_xor = min(xor1, xor2, xor3)\n            ans = min(ans, max_xor - min_xor)\n    \n    return ans", "def min_bit_flips(start, goal):\n    xor_value = start ^ goal\n    flips = 0\n    while xor_value:\n        flips += xor_value & 1\n        xor_value >>= 1\n    return flips", "def valid_selections(s: str) -> int:\n    res = 0\n    for i in range(1, len(s) - 1):\n        if s[i - 1] != s[i] and s[i] != s[i + 1] and s[i - 1] != s[i + 1]:\n            res += 1\n    return res", "def sum_prefix_scores(s: str) -> int:\n    n = len(s)\n    sum_scores = 0\n    longest_common_prefix = 0\n    for i in range(n - 1, -1, -1):\n        if s[i] == s[n - 1 - longest_common_prefix]:\n            longest_common_prefix += 1\n        else:\n            longest_common_prefix = 0\n        sum_scores += longest_common_prefix\n    return sum_scores", "def largest_swap_permutations(num):\n    num_str = str(num)\n    even_digits = sorted([c for c in num_str if int(c) % 2 == 0], reverse=True)\n    odd_digits = sorted([c for c in num_str if int(c) % 2 == 1], reverse=True)\n\n    result = []\n    for c in num_str:\n        if int(c) % 2 == 0:\n            result.append(even_digits.pop(0))\n        else:\n            result.append(odd_digits.pop(0))\n\n    return int(''.join(result))", "def add_parentheses(expression: str) -> str:\n    return f\"({expression})\"", "def max_beauty(flowers, new_flowers, target, full, partial):\n    beauty = sum(full if f >= target else partial * f for f in flowers)\n    flowers.sort()\n\n    for i in range(len(flowers)):\n        needed = target - flowers[i]\n        if needed <= new_flowers:\n            beauty += full - partial * flowers[i]\n            flowers[i] = target\n            new_flowers -= needed\n\n    return beauty", "def evalTree(root: 'TreeNode') -> bool:\n    if not root.left and not root.right:\n        return root.val == 1\n    left = evalTree(root.left)\n    right = evalTree(root.right)\n\n    if root.val == 2:\n        return left or right\n    return left and right", "def last_passenger_time(buses, passengers, capacity):\n    buses.sort()\n    passengers.sort()\n\n    last_index = 0\n    for bus in buses:\n        cnt = 0\n        while last_index < len(passengers) and passengers[last_index] <= bus and cnt < capacity:\n            cnt += 1\n            last_index += 1\n\n    return buses[0] - 1 if last_index == 0 else passengers[last_index - 1] - 1", "def min_sum_of_squared_difference(nums1, nums2, k1, k2):\n    res = 0\n    for i in range(len(nums1)):\n        diff = abs(nums1[i] - nums2[i])\n        steps = min(k1 + k2, diff)\n        diff -= steps\n        k1 -= min(k1, steps)\n        res += diff * diff\n    return res", "def find_subarray_length(nums, threshold):\n    n = len(nums)\n    left = 0\n    right = 0\n    total = 0\n    max_length = -1\n\n    while right < n:\n        total += nums[right]\n        while total * (right - left + 1) < threshold * (right - left + 1):\n            total -= nums[left]\n            left += 1\n        max_length = max(max_length, right - left + 1)\n        right += 1\n\n    return max_length", "def min_seconds(amount: List[int]) -> int:\n    total = sum(amount)\n    largest_two = max(amount[0] + amount[1], amount[1] + amount[2], amount[0] + amount[2])\n    return (total + 1) // 2 - (largest_two + 1) // 2 + largest_two", "class SmallestInfiniteSet:\n    def __init__(self):\n        self.available = set(range(1, 1001))\n        self.counter = 1\n\n    def popSmallest(self):\n        smallest = self.counter\n        if self.counter in self.available:\n            self.available.remove(self.counter)\n        else:\n            self.counter += 1\n        return smallest\n\n    def addBack(self, num):\n        self.available.add(num)", "def canTransform(start: str, target: str) -> bool:\n    n = len(start)\n    p, q = 0, 0\n\n    while p < n and q < n:\n        while p < n and start[p] == '_': p += 1\n        while q < n and target[q] == '_': q += 1\n\n        if p == n or q == n: break\n\n        if start[p] != target[q]: return False\n\n        if start[p] == 'L' and p < q: return False\n        if start[p] == 'R' and p > q: return False\n\n        p += 1\n        q += 1\n\n    return p == n and q == n", "def numOfArrays(n: int, maxValue: int) -> int:\n    mod = 10**9 + 7\n    dp = [0] * (maxValue + 1)\n    \n    for i in range(1, maxValue + 1):\n        dp[i] = i\n        \n    for i in range(1, n):\n        for j in range(maxValue, 0, -1):\n            dp[j] = (dp[j] + dp[j - 1]) % mod\n            \n    return dp[maxValue]", "def minSwaps(nums):\n    n = len(nums)\n    minPos = 0\n    maxPos = 0\n    swaps = 0\n\n    for i in range(1, n):\n        if nums[i] <= nums[minPos]:\n            minPos = i\n        if nums[i] >= nums[maxPos]:\n            maxPos = i\n\n    swaps = minPos + (n - 1 - maxPos)\n    if minPos < maxPos:\n        swaps -= 1\n\n    return swaps", "def count_pairs_leftovers(nums):\n    counter = [0] * 101\n    pairs, leftovers = 0, 0\n\n    for n in nums:\n        counter[n] += 1\n\n    for count in counter:\n        pairs += count // 2\n        leftovers += count % 2\n\n    return [pairs, leftovers]", "def max_sum_numbers_with_equal_sum_of_digits(nums):\n    digit_sum_to_max = {}\n    ans = -1\n\n    for num in nums:\n        sum_of_digits = sum(map(int, str(num)))\n        \n        prev_max = digit_sum_to_max.get(sum_of_digits, 0)\n        if prev_max:\n            ans = max(ans, num + prev_max)\n        \n        digit_sum_to_max[sum_of_digits] = max(num, prev_max)\n\n    return ans", "from typing import List\n\ndef kthSmallestIndex(nums: List[str], queries: List[List[int]]) -> List[int]:\n    answer = []\n    indices = list(enumerate(map(int, nums)))\n    indices.sort(key=lambda x: (x[1], x[0]))\n\n    for k, trim in queries:\n        trimmed_indices = [(i, int(n[-trim:])) for i, n in enumerate(nums)]\n        trimmed_indices.sort(key=lambda x: (x[1], x[0]))\n        answer.append(trimmed_indices[k-1][0])\n\n    return answer", "def min_deletions(nums, nums_divide):\n    res = float('inf')\n    for num in nums:\n        cnt = 0\n        found = True\n        for d in nums_divide:\n            if d % num != 0:\n                found = False\n                break\n        if found:\n            for n in nums:\n                if n == num:\n                    cnt += 1\n            res = min(res, len(nums) - cnt)\n    return -1 if res == float('inf') else res", "def min_operations(current, correct):\n    current_mins = int(current[:2]) * 60 + int(current[3:])\n    correct_mins = int(correct[:2]) * 60 + int(correct[3:])\n    if current_mins > correct_mins:\n        correct_mins += 24 * 60\n\n    diff = correct_mins - current_mins\n    count = diff // 60 + (diff % 60) // 15 + ((diff % 60) % 15) // 5 + (((diff % 60) % 15) % 5)\n\n    return count", "def best_poker_hand(ranks, suits):\n    rank_count = {}\n    suit_count = {}\n    for rank, suit in zip(ranks, suits):\n        rank_count[rank] = rank_count.get(rank, 0) + 1\n        suit_count[suit] = suit_count.get(suit, 0) + 1\n    if len(suit_count) == 1:\n        return \"Flush \"\n    if len(rank_count) == 3:\n        return \"Three of a Kind \"\n    for value in rank_count.values():\n        if value == 2:\n            return \"Pair \"\n    return \"High Card \"", "def numberOfSubarraysWithZeroes(nums):\n    count = 0\n    zero_count = 0\n\n    for num in nums:\n        if num == 0:\n            zero_count += 1\n            count += zero_count\n        else:\n            zero_count = 0\n\n    return count", "class NumberContainers:\n    def __init__(self):\n        self.indices = {}\n        self.nums = {}\n\n    def change(self, index: int, number: int) -> None:\n        if index in self.indices:\n            old_number = self.indices[index]\n            self.nums[old_number].remove(index)\n            if not self.nums[old_number]:\n                del self.nums[old_number]\n        self.indices[index] = number\n        if number not in self.nums:\n            self.nums[number] = set()\n        self.nums[number].add(index)\n\n    def find(self, number: int) -> int:\n        if number in self.nums:\n            return min(self.nums[number])\n        return -1", "def shortest_unrollable_sequence(rolls, k):\n    count = [0] * (k + 1)\n    for roll in rolls:\n        count[roll] += 1\n    \n    len_ = 1\n    while True:\n        max_subsequences = 1\n        for i in range(1, k + 1):\n            max_subsequences *= count[i] + (1 if len_ == 1 else 0)\n        \n        if max_subsequences < len_ * len(rolls):\n            return len_\n        \n        len_ += 1", "def first_letter_to_appear_twice(s: str) -> str:\n    occurrences = [0] * 26\n    for c in s:\n        occurrences[ord(c) - ord('a')] += 1\n        if occurrences[ord(c) - ord('a')] == 2:\n            return c\n    return '?'", "def countEqualRowColumnPairs(grid: List[List[int]]) -> int:\n   n = len(grid)\n   ans = 0\n\n   for i in range(n):\n      for j in range(n):\n         equal = True\n         for k in range(n):\n             if grid[i][k] != grid[k][j]:\n                 equal = False\n                 break\n         if equal:\n             ans += 1\n\n   return ans", "from collections import defaultdict\n\nclass FoodRatings:\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\n        self.food_ratings = {food: rating for food, rating in zip(foods, ratings)}\n        self.highest_rated = defaultdict(str)\n        \n        for food, cuisine, rating in zip(foods, cuisines, ratings):\n            if (not self.highest_rated[cuisine] or\n                rating > self.food_ratings[self.highest_rated[cuisine]] or\n                (rating == self.food_ratings[self.highest_rated[cuisine]] and food < self.highest_rated[cuisine])):\n                self.highest_rated[cuisine] = food\n\n    def changeRating(self, food: str, newRating: int) -> None:\n        cuisine = [c for c, f in self.highest_rated.items() if f == food][0]\n        self.food_ratings[food] = newRating\n        for f, rating in self.food_ratings.items():\n            if (self.highest_rated[cuisine] == food or\n                (newRating > rating and cuisine == self.food_ratings[f]) or\n                (newRating == rating and food < f)):\n                self.highest_rated[cuisine] = food\n\n    def highestRated(self, cuisine: str) -> str:\n        return self.highest_rated[cuisine]", "from collections import Counter\n\ndef countExcellentPairs(nums, k):\n    frequency = Counter(nums)\n    count = 0\n    for num1, freq1 in frequency.items():\n        for num2, freq2 in frequency.items():\n            setBits = bin(num1 | num2).count('1') + bin(num1 & num2).count('1')\n            if setBits >= k:\n                count += freq1 * freq2 if num1 != num2 else freq1 * (freq1 - 1) // 2\n    return count", "def max_books(books):\n    n = len(books)\n    max_books = 0\n    \n    for l in range(n):\n        r = l + 1\n        books_taken = books[l]\n        min_taken = books[l]\n        max_books = max(max_books, books_taken)\n        \n        while r < n:\n            min_taken = min(min_taken, books[r])\n            books_taken += min_taken\n            max_books = max(max_books, books_taken)\n            \n            if min_taken <= 1:\n                break  # Can't decrease further\n            r += 1\n            \n    return max_books", "def minOperations(nums):\n    count = 0\n    nums.sort()\n    i = 0\n\n    while i < len(nums):\n        if nums[i] > 0:\n            target = nums[i]\n            while i < len(nums) and nums[i] == target:\n                i += 1\n            count += 1\n        else:\n            i += 1\n\n    return count", "def max_groups(grades):\n    grades.sort()\n\n    dp = [1] * len(grades)\n\n    for i in range(len(grades)):\n        for j in range(i):\n            if grades[i] + dp[j] * grades[j] > (i+1) * grades[j]:\n                dp[i] = dp[j] + 1\n\n    return dp[-1]", "def get_index_with_min_max_distance(edges, node1, node2):\n    dist1 = [-1] * len(edges)\n    dist2 = [-1] * len(edges)\n\n    dist1[node1] = 0\n    dist2[node2] = 0\n    for i in range(len(edges)):\n        if dist1[i] != -1 and edges[i] != -1:\n            if dist1[edges[i]] == -1:\n                dist1[edges[i]] = dist1[i] + 1\n            else:\n                dist1[edges[i]] = min(dist1[edges[i]], dist1[i] + 1)\n\n        if dist2[i] != -1 and edges[i] != -1:\n            if dist2[edges[i]] == -1:\n                dist2[edges[i]] = dist2[i] + 1\n            else:\n                dist2[edges[i]] = min(dist2[edges[i]], dist2[i] + 1)\n\n    ans = -1\n    min_max_dist = float(\"inf\")\n    for i in range(len(edges)):\n        if dist1[i] != -1 and dist2[i] != -1:\n            max_dist = max(dist1[i], dist2[i])\n            if max_dist < min_max_dist:\n                min_max_dist = max_dist\n                ans = i\n\n    return ans", "def findLongestCycle(edges):\n    n = len(edges)\n    visited = [False] * n\n    longest_cycle = -1\n\n    for i in range(n):\n        if not visited[i]:\n            length = 0\n            node = i\n\n            while not visited[node] and edges[node] != -1:\n                visited[node] = True\n                length += 1\n                node = edges[node]\n\n            if edges[node] == i:\n                longest_cycle = max(longest_cycle, length)\n\n    return longest_cycle", "def min_stop_costs(regular, express, express_cost):\n    n = len(regular)\n    costs = [0] * n\n    regular_sum, express_sum = 0, express_cost\n\n    for i in range(n):\n        regular_sum += regular[i]\n        express_sum += express[i]\n        costs[i] = min(regular_sum, express_sum + express_cost)\n\n    return costs", "def sum_weights(items1, items2):\n    weight_sums = {}\n    result = []\n\n    for value, weight in items1:\n        weight_sums[value] = weight_sums.get(value, 0) + weight\n    for value, weight in items2:\n        weight_sums[value] = weight_sums.get(value, 0) + weight\n\n    for value, weight in sorted(weight_sums.items()):\n        result.append([value, weight])\n\n    return result", "def bad_pairs(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if j - i != nums[j] - nums[i]:\n                count += 1\n    return count", "def min_days_to_complete_tasks(tasks, space):\n    task_last_complete = {}\n    days = 0\n\n    for task in tasks:\n        if task in task_last_complete:\n            passed_days = days - task_last_complete[task]\n            if passed_days < space:\n                days += space - passed_days\n        days += 1\n        task_last_complete[task] = days\n\n    return days", "def min_operations(nums):\n    operations = 0\n    for i in range(1, len(nums)):\n        if nums[i] <= nums[i - 1]:\n            diff = nums[i - 1] - nums[i] + 1\n            operations += math.ceil(math.log2(diff))\n            nums[i] += diff\n    return operations", "def count_arithmetic_triplets(nums, diff):\n    count = 0\n    mp = {}\n    for num in nums:\n        if num - diff in mp:\n            count += mp[num - diff]\n        mp[num] = mp.get(num, 0) + 1\n    return count", "from collections import defaultdict\n\ndef max_nodes_without_restricted(n, edges, restricted):\n    tree = defaultdict(list)\n    blocked_nodes = set(restricted)\n\n    for a, b in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n\n    max_nodes = [0]\n\n    def dfs(node, depth, parent):\n        if node in blocked_nodes:\n            return\n        max_nodes[0] = max(max_nodes[0], depth)\n        for child in tree[node]:\n            if child != parent:\n                dfs(child, depth + 1, node)\n\n    dfs(0, 1, -1)\n    return max_nodes[0]", "def valid_partition(nums):\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    for num, cnt in count.items():\n        if cnt == 2 or cnt == 3 or (num - 1 in count and num + 1 in count):\n            return True\n    return False", "def longest_ideal_string(s: str, k: int) -> int:\n    dp = [0] * 26\n\n    for c in s:\n        current = 1\n        for i in range(26):\n            if abs(i - (ord(c) - ord('a'))) <= k:\n                current = max(current, dp[i] + 1)\n        dp[ord(c) - ord('a')] = max(dp[ord(c) - ord('a')], current)\n\n    return max(dp)", "def smallest_max_number_grid(grid):\n    rows = [0] * len(grid)\n    cols = [0] * len(grid[0])\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            rows[i] = max(rows[i], grid[i][j])\n            cols[j] = max(cols[j], grid[i][j])\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            grid[i][j] = min(rows[i], cols[j])\n\n    return grid", "def largest_matrix(grid):\n    n = len(grid)\n    maxLocal = [[0] * (n - 2) for _ in range(n - 2)]\n\n    for i in range(1, n - 1):\n        for j in range(1, n - 1):\n            max_val = grid[i - 1][j - 1]\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    max_val = max(max_val, grid[i + x][j + y])\n            maxLocal[i - 1][j - 1] = max_val\n\n    return maxLocal", "def highest_edge_score_node(edges: List[int]) -> int:\n    scores = [0] * len(edges)\n    for i, edge in enumerate(edges):\n        scores[edge] += i\n    return scores.index(max(scores))", "def findSmallestNum(pattern: str) -> str:\n    num = \"123456789\"\n    i = 0\n    while i < len(pattern):\n        if pattern[i] == 'D':\n            j = i\n            while j < len(pattern) and pattern[j] == 'D':\n                j += 1\n            num = num[:i] + num[i:j+1][::-1] + num[j+1:]\n            i = j\n        else:\n            i += 1\n    return num[:len(pattern) + 1]", "def is_distinct(n):\n    unique_digits = set()\n    while n > 0:\n        digit = n % 10\n        if digit in unique_digits:\n            return False\n        unique_digits.add(digit)\n        n //= 10\n    return True\n\ndef count_special(n):\n    count = 0\n    for i in range(1, n + 1):\n        if is_distinct(i):\n            count += 1\n    return count", "def maxWeight(self, edges):\n    n = len(edges)\n    dp = [[0] * 2 for _ in range(n)]\n\n    def dfs(node):\n        for i in range(1, n):\n            if edges[i][0] == node:\n                dfs(i)\n                dp[node][0] += max(dp[i][0], dp[i][1])\n                dp[node][1] += dp[i][0]\n        dp[node][1] += edges[node][1]\n\n    dfs(0)\n    return max(dp[0][0], dp[0][1])", "def min_operations(blocks, k):\n    n = len(blocks)\n    res = k\n    w = b = 0\n    i = j = 0\n\n    while j < n:\n        if blocks[j] == 'W':\n            w += 1\n        while b > k or (b == k and blocks[i] == 'B'):\n            if blocks[i] == 'W':\n                w -= 1\n                i += 1\n            else:\n                b -= 1\n                i += 1\n        if b == k:\n            res = min(res, w)\n        else:\n            b += 1\n        j += 1\n    \n    return res", "def find_seconds_to_transform(s: str) -> int:\n    cnt_0, cnt_1 = 0, 0\n    for c in s:\n        if c == '0': cnt_0 += 1\n        else: cnt_1 += 1\n    return min(cnt_0, cnt_1)", "def shiftCharacters(s: str, shifts: List[List[int]]) -> str:\n    shift_values = [0] * len(s)\n    for shift in shifts:\n        start, end, direction = shift\n        value = 1 if direction == 1 else -1\n        shift_values[start] += value\n        if end + 1 < len(s):\n            shift_values[end + 1] -= value\n\n    for i in range(1, len(s)):\n        shift_values[i] += shift_values[i - 1]\n\n    return ''.join(chr((ord(s[i]) - ord('a') + shift_values[i]) % 26 + ord('a')) for i in range(len(s)))", "def max_seg_sum_after_queries(nums, removeQueries):\n    n = len(nums)\n    answer = [0] * n\n    removed = {-1, n}\n    \n    current_sum = 0\n    max_sum = 0\n    for x in nums:\n        if x > 0:\n            current_sum += x\n        else:\n            max_sum = max(max_sum, current_sum)\n            current_sum = 0\n    max_sum = max(max_sum, current_sum)\n    \n    for i, remove_idx in enumerate(removeQueries):\n        answer[i] = max_sum\n        nums[remove_idx] = -nums[remove_idx]\n        \n        left_idx = max(x for x in removed if x < remove_idx)\n        right_idx = min(x for x in removed if x > remove_idx)\n        \n        left_sum = 0\n        right_sum = 0\n        for j in range(right_idx - 1, -1, -1):\n            if nums[j] < 0:\n                left_sum -= nums[j]\n            else:\n                break\n        for j in range(left_idx + 1, n):\n            if nums[j] < 0:\n                right_sum -= nums[j]\n            else:\n                break\n                \n        max_sum -= max(0, left_sum - (-nums[remove_idx]))\n        max_sum -= max(0, right_sum - (-nums[remove_idx]))\n        max_sum += max(0, left_sum + right_sum - (-nums[remove_idx]))\n        \n        removed.add(remove_idx)\n    \n    return answer", "def min_training_hours(initial_energy, initial_experience, energy, experience):\n    n = len(energy)\n    ans = int(1e9)\n    for exp_gain in range(initial_energy + initial_experience + 1):\n        training_hours = exp_gain\n        energy_left = initial_energy - exp_gain\n        curr_experience = initial_experience + exp_gain\n        \n        for i in range(n):\n            while curr_experience <= experience[i] or energy_left <= energy[i]:\n                energy_left -= 1\n                training_hours += 1\n            energy_left -= energy[i]\n            curr_experience += experience[i]\n        ans = min(ans, training_hours)\n    return ans", "def root_sum_equal(root):\n    if not root:\n        return False\n    return root.val == root.left.val + root.right.val", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef time_to_infect(node, start, minutes):\n    if not node:\n        return 0\n    if node.val == start:\n        return minutes\n    return max(time_to_infect(node.left, start, minutes+1),\n               time_to_infect(node.right, start, minutes+1))\n\ndef total_infection_time(root, total_minutes=0):\n    if not root:\n        return total_minutes\n    time_needed = max(total_minutes,\n                      time_to_infect(root, root.val, 0),\n                      total_infection_time(root.left, total_minutes + 1),\n                      total_infection_time(root.right, total_minutes + 1))\n    return time_needed", "def kSum(nums, k):\n    sums = [0]\n    for num in nums:\n        if num > 0:\n            sums.extend([s + num for s in sums])\n            sums.sort(reverse=True)\n        else:\n            sums.append(num)\n\n    return sums[k - 1]", "def findMedian(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    low, high = 1, 1_000_000\n\n    while low < high:\n        mid = low + (high - low) // 2\n        count = sum(bisect_right(row, mid) for row in grid)\n\n        if count < (m * n) // 2 + 1:\n            low = mid + 1\n        else:\n            high = mid\n\n    return low", "from bisect import bisect\n\ndef maxSizeSubsequenceSumQueries(nums, queries):\n    nums.sort()\n    prefixSums = [0] * (len(nums) + 1)\n    for i, x in enumerate(nums):\n        prefixSums[i + 1] = prefixSums[i] + x\n\n    answer = []\n    for q in queries:\n        idx = bisect(prefixSums, q)\n        answer.append(idx - 1)\n\n    return answer", "def remove_stars(s: str) -> str:\n    result = []\n    for c in s:\n        if c == '*':\n            if result:\n                result.pop()\n        else:\n            result.append(c)\n    return ''.join(result)", "def min_minutes(garbage: list[str], travel: list[int]) -> int:\n    time_garbage = [0, 0, 0]\n    time_travel = [0, 0, 0]\n\n    for i, g in enumerate(garbage):\n        m, p, g = g.count('M'), g.count('P'), g.count('G')\n        time_garbage[0] += m\n        time_garbage[1] += p\n        time_garbage[2] += g\n        if i < len(garbage) - 1:\n            time_travel[0] += travel[i]\n            time_travel[1] += travel[i]\n            time_travel[2] += travel[i]\n    \n    return sum(time_garbage) + sum(time_travel)", "def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n    row, col = [0] * (k + 1), [0] * (k + 1)\n    for condition in row_conditions:\n        if row[condition[0]] >= row[condition[1]]:\n            return []\n        row[condition[1]] = row[condition[0]] + 1\n    for condition in col_conditions:\n        if col[condition[0]] >= col[condition[1]]:\n            return []\n        col[condition[1]] = col[condition[0]] + 1\n    matrix = [[0] * k for _ in range(k)]\n    for i in range(1, k + 1):\n        matrix[row[i]][col[i]] = i\n    return matrix", "def num_strictly_increasing_subarrays(nums):\n    n = len(nums)\n    count = 0\n    sum = 0\n    for i in range(1, n):\n        if nums[i] > nums[i - 1]:\n            count += 1\n        else:\n            count = 0\n        sum += count\n    return sum + n", "def equal_sum_subarrays(nums):\n    sums = set()\n    for i in range(1, len(nums)):\n        current_sum = nums[i] + nums[i - 1]\n        if current_sum in sums:\n            return True\n        sums.add(current_sum)\n    return False", "def is_palindrome(s: str) -> bool:\n    return s == s[::-1]\n\ndef to_base_str(n: int, base: int) -> str:\n    s = []\n    while n > 0:\n        s.append(str(n % base))\n        n //= base\n    return \"\".join(reversed(s))\n\ndef is_strictly_palindromic(n: int) -> bool:\n    for b in range(2, n - 1):\n        if not is_palindrome(to_base_str(n, b)):\n            return False\n    return True", "def max_covered_rows(matrix, num_select):\n    m, n = len(matrix), len(matrix[0])\n    max_covered = 0\n    for i in range(1 << n):\n        if bin(i).count('1') == num_select:\n            covered = 0\n            for row in range(m):\n                for col in range(n):\n                    if matrix[row][col] == 1 and i & (1 << col):\n                        covered += 1\n                        break\n            max_covered = max(max_covered, covered)\n    return max_covered", "def max_consecutive_robots(charge_times, running_costs, budget):\n    n = len(charge_times)\n    max_robots = 0\n    for i in range(n):\n        max_charge = 0\n        running_sum = 0\n        for j in range(i, n):\n            max_charge = max(max_charge, charge_times[j])\n            running_sum += running_costs[j]\n            cost = max_charge + running_sum * (j - i + 1)\n            if cost <= budget:\n                max_robots = max(max_robots, j - i + 1)\n            else:\n                break\n    return max_robots", "def well_spaced_string(s: str, distance: List[int]) -> bool:\n    first = {}\n    for i, c in enumerate(s):\n        if c not in first:\n            first[c] = i\n        else:\n            if distance[ord(c) - ord('a')] != i - first[c] - 1:\n                return False\n    return True", "MOD = 10**9 + 7\nMAX = 1001\n\ndef ways(startPos, endPos, k, dp):\n    if k == 0: return 1 if startPos == endPos else 0\n    if startPos < 0 or endPos < 0 or startPos >= MAX or endPos >= MAX: return 0\n    \n    if dp[startPos][k] != -1: return dp[startPos][k]\n    \n    left = ways(startPos - 1, endPos, k - 1, dp)\n    right = ways(startPos + 1, endPos, k - 1, dp)\n    \n    dp[startPos][k] = (left + right) % MOD\n    return dp[startPos][k]\n\ndef numberOfWays(startPos, endPos, k):\n    dp = [[-1 for _ in range(k + 1)] for _ in range(MAX)]\n    return ways(startPos, endPos, k, dp)", "def longestNiceSubarray(nums):\n    n = len(nums)\n    max_len = 1\n    for i in range(n):\n        mask = 0\n        for j in range(i, n):\n            mask |= nums[j]\n            if mask & (mask - 1) == 0:\n                max_len = max(max_len, j - i + 1)\n    return max_len", "import heapq\n\ndef most_visited_room(n, meetings):\n    meetings.sort()\n    pq = []\n    rooms = [0] * n\n    \n    for start, end in meetings:\n        while pq and pq[0][0] <= start:\n            _, room = heapq.heappop(pq)\n            rooms[room] += 1\n        heapq.heappush(pq, (end, len(pq) % n))\n    \n    return rooms.index(max(rooms))", "def min_days(power):\n    n = len(power)  \n    ans = int(1e9)\n    dp = [int(1e9)] * (1 << n)\n    dp[0] = 0\n     \n    sorted_power = sorted(power)\n\n    for i in range(1 << n): \n        power_sum = sum(sorted_power[j] for j in range(n) if i & (1 << j)) \n        gain = 1 + bin(i).count('1')\n\n        for j in range(n):\n            if not i & (1 << j) and gain > sorted_power[j]:\n                dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + 1)\n\n    return dp[(1 << n) - 1]", "def most_frequent_even(nums):\n    count = {}\n    for num in nums:\n        if num % 2 == 0:\n            count[num] = count.get(num, 0) + 1\n    max_count = float('-inf')\n    most_frequent = -1\n    for num, freq in count.items():\n        if freq > max_count or (freq == max_count and num < most_frequent):\n            max_count = freq\n            most_frequent = num\n    return most_frequent", "def min_substrs(s: str) -> int:\n    seen = set()\n    count = 0\n    for c in s:\n        if c in seen:\n            count += 1\n            seen.clear()\n        seen.add(c)\n    return count + int(bool(seen))", "import heapq\n\ndef min_groups(intervals):\n    intervals.sort()\n    pq = []\n    for interval in intervals:\n        if pq and pq[0] < interval[0]:\n            heapq.heappop(pq)\n        heapq.heappush(pq, interval[1])\n    return len(pq)", "def longestSubsequence(nums, k):\n    n = len(nums)\n    dp = {}\n    ans = 0\n\n    for num in nums:\n        temp = 0\n        keys = [key for key in dp if num - k <= key]\n        if keys:\n            temp = dp[max(keys)]\n\n        dp[num] = max(dp.get(num, 0), temp + 1)\n        ans = max(ans, dp[num])\n\n    return ans", "class SQL:\n    def __init__(self, names: List[str], columns: List[int]):\n        self.tables = {name: Table(columns[i]) for i, name in enumerate(names)}\n\n    def insertRow(self, name: str, row: List[str]) -> None:\n        self.tables[name].insertRow(row)\n\n    def deleteRow(self, name: str, rowId: int) -> None:\n        self.tables[name].deleteRow(rowId)\n\n    def selectCell(self, name: str, rowId: int, columnId: int) -> str:\n        return self.tables[name].selectCell(rowId, columnId)\n\n\nclass Table:\n    def __init__(self, columns: int):\n        self.next_id = 1\n        self.rows = []\n        self.num_columns = columns\n\n    def insertRow(self, row: List[str]) -> None:\n        self.rows.append([self.next_id, row])\n        self.next_id += 1\n\n    def deleteRow(self, rowId: int) -> None:\n        self.rows = [row for row in self.rows if row[0] != rowId]\n\n    def selectCell(self, rowId: int, columnId: int) -> str:\n        for row in self.rows:\n            if row[0] == rowId:\n                return row[1][columnId - 1]", "def days_together(arrive_alice, leave_alice, arrive_bob, leave_bob):\n    days_in_month = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    def date_to_days(date):\n        month, day = map(int, date.split('-'))\n        return sum(days_in_month[:month]) + day\n\n    arrive_days_alice = date_to_days(arrive_alice)\n    leave_days_alice = date_to_days(leave_alice)\n    arrive_days_bob = date_to_days(arrive_bob)\n    leave_days_bob = date_to_days(leave_bob)\n\n    common_start_date = max(arrive_days_alice, arrive_days_bob)\n    common_end_date = min(leave_days_alice, leave_days_bob)\n\n    return max(0, common_end_date - common_start_date + 1)", "def max_matchings(players, trainers):\n    players.sort()\n    trainers.sort()\n\n    player_index, trainer_index, match_count = 0, 0, 0\n    while (player_index < len(players)) and (trainer_index < len(trainers)):\n        if players[player_index] <= trainers[trainer_index]:\n            match_count += 1\n            player_index += 1\n            trainer_index += 1\n        else:\n            trainer_index += 1\n\n    return match_count", "def minSizeMaxBitwiseOR(nums):\n    n = len(nums)\n    answer = [0] * n\n    orSum = 0\n\n    i, j = 0, 0\n    while i < n:\n        orSum |= nums[i]\n        while (orSum | nums[j]) == orSum:\n            orSum ^= nums[j]\n            j += 1\n\n        answer[i] = i - j + 2\n        i += 1\n\n    return answer", "def min_money(transactions):\n    min_money_needed = 0\n    for transaction in transactions:\n        min_money_needed = max(min_money_needed, transaction[0] - transaction[1])\n    return min_money_needed", "def smallest_multiple(n):\n    return n if n % 2 == 0 else n * 2", "def longest_alphabetical_continuous_substring(s: str) -> int:\n    max_length = current_length = 1\n    for i in range(1, len(s)):\n        if ord(s[i]) == ord(s[i - 1]) + 1:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 1\n    return max(max_length, current_length)", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef reverse_odd_levels(node, level):\n    if node is None: return\n    if level % 2 == 1:\n        node.left, node.right = node.right, node.left\n    reverse_odd_levels(node.left, level + 1)\n    reverse_odd_levels(node.right, level + 1)\n\ndef reverse_odd_level_nodes(root):\n    reverse_odd_levels(root, 0)\n    return root", "from collections import defaultdict\n\ndef prefix_score_sum(words):\n    result = [0] * len(words)\n    prefix_count = defaultdict(int)\n    \n    for word in words:\n        prefix = \"\"\n        for c in word:\n            prefix += c\n            prefix_count[prefix] += 1\n    \n    for i, word in enumerate(words):\n        prefix = \"\"\n        for c in word:\n            prefix += c\n            result[i] += prefix_count[prefix]\n    \n    return result", "def smallest_fair_number(n):\n    while True:\n        k = n\n        even = 0\n        odd = 0\n        while k > 0:\n            if k % 2 == 0:\n                even += 1\n            else:\n                odd += 1\n            k //= 10\n        if even == odd:\n            return n\n        n += 1", "def sort_names_by_height(names, heights):\n    name_height_pairs = sorted(zip(heights, names), reverse=True)\n    sorted_names = [pair[1] for pair in name_height_pairs]\n    return sorted_names", "def longestSubarray(nums):\n    max_and = 0\n    for i in range(len(nums)):\n        temp_and = nums[i]\n        for j in range(i + 1, len(nums)):\n            temp_and &= nums[j]\n            max_and = max(max_and, temp_and)\n    \n    longest_subarray = 0\n    current_length = 0\n    for i in range(len(nums)):\n        temp_and = nums[i]\n        current_length = 1 if temp_and == max_and else 0\n        for j in range(i + 1, len(nums)):\n            temp_and &= nums[j];\n            if temp_and == max_and:\n                current_length += 1\n            else:\n                break\n        longest_subarray = max(longest_subarray, current_length)\n    return longest_subarray", "def find_good_indices(nums, k):\n    good_indices = []\n    for i in range(k, len(nums) - k):\n        left_non_inc = all(nums[i - j - 1] >= nums[i - j - 2] for j in range(k - 1))\n        right_non_dec = all(nums[i + j + 1] >= nums[i + j + 2] for j in range(k - 1))\n\n        if left_non_inc and right_non_dec:\n            good_indices.append(i)\n\n    return good_indices", "from collections import defaultdict\n\ndef dfs(node, parent, adj, vals, cur_max, count):\n    if vals[node] >= cur_max:\n        if vals[node] > cur_max:\n            count[0] += 1\n            cur_max = vals[node]\n        for next in adj[node]:\n            if next != parent:\n                dfs(next, node, adj, vals, cur_max, count)\n\ndef number_of_good_paths(vals, edges):\n    n = len(vals)\n    adj = defaultdict(list)\n    for edge in edges:\n        adj[edge[0]].append(edge[1])\n        adj[edge[1]].append(edge[0])\n    count = [0]\n    for i in range(n):\n        dfs(i, -1, adj, vals, -1, count)\n    return count[0]", "def minOperations(nums):\n    n = len(nums)\n    i, j = 0, n - 1\n    operations = 0\n\n    while i < j:\n        if nums[i] == nums[j]:\n            i += 1\n            j -= 1\n        elif nums[i] < nums[j]:\n            nums[i + 1] += nums[i]\n            i += 1\n            operations += 1\n        else:\n            nums[j - 1] += nums[j]\n            j -= 1\n            operations += 1\n\n    return operations", "def can_equal_frequency(word: str) -> bool:\n    freq = {}\n    for c in word:\n        freq[c] = freq.get(c, 0) + 1\n\n    count_freq = {}\n    for f in freq.values():\n        count_freq[f] = count_freq.get(f, 0) + 1\n\n    if len(count_freq) != 2:\n        return False\n\n    a, acount = next(iter(count_freq.items()))\n    b, bcount = next(reversed(list(count_freq.items())))\n\n    return (acount == 1 and (a - 1 == b or a == 1)) or (bcount == 1 and (b - 1 == a or b == 1))", "class LUPrefix:\n    def __init__(self, n: int):\n        self.max_prefix_length = 0\n        self.next_video = 1\n        self.uploaded = [False] * (n + 1)\n\n    def upload(self, video: int) -> None:\n        self.uploaded[video] = True\n        if video == self.next_video:\n            while self.uploaded[self.next_video]:\n                self.next_video += 1\n\n    def longest(self) -> int:\n        return self.next_video - 1", "def get_xor(nums1, nums2):\n    xor_result = 0\n    for num1 in nums1:\n        for num2 in nums2:\n            xor_result ^= (num1 ^ num2)\n    return xor_result", "def count_pairs(nums1, nums2, diff):\n    n = len(nums1)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff:\n                count += 1\n    return count", "def common_factors(a: int, b: int) -> int:\n    from math import gcd\n\n    g = gcd(a, b)\n    count = 0\n    for i in range(1, int(g**0.5) + 1):\n        if g % i == 0:\n            count += 1\n            if i * i != g:\n                count += 1\n    return count", "def max_hourglass_sum(grid):\n    m, n = len(grid), len(grid[0])\n    max_sum = float('-inf')\n    for i in range(1, m - 1):\n        for j in range(1, n - 1):\n            sum = grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1] \\\n                  + grid[i][j] \\\n                  + grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1]\n            max_sum = max(max_sum, sum)\n    return max_sum", "def minSetXor(num1: int, num2: int) -> int:\n    set_count = bin(num2).count('1')\n    x = 0\n    for i in range(32):\n        if set_count <= 0:\n            break\n        if num2 & (1 << i):\n            x |= (1 << i)\n            set_count -= 1\n    return x ^ num1", "def maxOperations(s: str) -> int:\n    count = 0\n    while s:\n        for i in range(len(s) // 2, 0, -1):\n            if s[:i] == s[i:2*i]:\n                s = s[i:]\n                count += 1\n                break\n            elif i == 1:\n                s = s[1:]\n                count += 1\n    return count", "def maxTastiness(price, tastiness, maxAmount, maxCoupons):\n    n = len(price)\n    dp = [[[0] * (maxCoupons + 1) for _ in range(maxAmount + 1)] for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        fruit_price = price[i - 1]\n        fruit_tastiness = tastiness[i - 1]\n        half_fruit_price = fruit_price // 2\n        \n        for j in range(maxAmount + 1):\n            for k in range(maxCoupons + 1):\n                dp[i][j][k] = dp[i - 1][j][k]\n                if j >= fruit_price:\n                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - fruit_price][k] + fruit_tastiness)\n                if k > 0 and j >= half_fruit_price:\n                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - half_fruit_price][k - 1] + fruit_tastiness)\n\n    return dp[n][maxAmount][maxCoupons]", "def worker_with_longest_task(n, logs):\n    result = 0\n    max_time = logs[0][1] - 0\n\n    for i in range(1, len(logs)):\n        time = logs[i][1] - logs[i-1][1]\n        if time > max_time:\n            max_time = time\n            result = logs[i][0]\n\n    return result", "def findArray(pref):\n    arr = [pref[0]]\n    for i in range(1, len(pref)):\n        arr.append(pref[i] ^ pref[i - 1])\n    return arr", "def robot_sort(s):\n    t = []\n    for c in s:\n        while t and t[-1] <= c:\n            t.pop()\n        t.append(c)\n    return ''.join(t)", "def ways(grid, m, n, i, j, k, sum, dp):\n    if i == m - 1 and j == n - 1:\n        return 1 if (sum + grid[i][j]) % k == 0 else 0\n    if dp[i][j][sum] == -1:\n        ans = 0\n        if i + 1 < m:\n            ans = (ans + ways(grid, m, n, i + 1, j, k, (sum + grid[i][j]) % k, dp)) % 1000000007\n        if j + 1 < n:\n            ans = (ans + ways(grid, m, n, i, j + 1, k, (sum + grid[i][j]) % k, dp)) % 1000000007\n        dp[i][j][sum] = ans\n    return dp[i][j][sum]\n\ndef waysToReachDivisibleSum(grid, k):\n    m, n = len(grid), len(grid[0])\n    dp = [[[-1] * k for _ in range(n)] for _ in range(m)]\n    return ways(grid, m, n, 0, 0, k, 0, dp)", "def min_arrays(nums):\n    def gcd(a, b):\n        return a if b == 0 else gcd(b, a % b)\n\n    total_gcd = nums[0]\n    for num in nums[1:]:\n        total_gcd = gcd(total_gcd, num)\n    \n    return 2 if total_gcd == 1 else 1", "def count_valid_times(time: str) -> int:\n    count = 1\n    if time[0] == '?':\n        count *= 3 if time[1] == '?' or time[1] < '4' else 2\n    if time[1] == '?':\n        count *= 4 if time[0] == '2' else 10\n    if time[3] == '?':\n        count *= 6\n    if time[4] == '?':\n        count *= 10\n    return count", "def getPowers(n):\n    powers = []\n    while n > 0:\n        powers.append(n & (-n))\n        n -= n & (-n)\n    return powers\n\ndef productOfPowers(n, queries):\n    powers = getPowers(n)\n    answers = []\n\n    mod = 10**9 + 7\n\n    for query in queries:\n        product = 1\n        for i in range(query[0], query[1] + 1):\n            product = (product * powers[i]) % mod\n        answers.append(product)\n\n    return answers", "def find_min_maximum_value(nums):\n    result = nums[0]\n    total_sum = nums[0]\n    for i in range(1, len(nums)):\n        total_sum += nums[i]\n        result = max(result, (total_sum + i) // (i + 1))\n    return result", "from collections import defaultdict\n\ndef dfs(node, parent, nums, graph, total, result):\n    total_sum = nums[node]\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            total_sum += dfs(neighbor, node, nums, graph, total, result)\n    if total_sum == total // 2:\n        result.append(1)\n        return 0\n    return total_sum\n\ndef delete_edges_to_balance_tree(nums, edges):\n    n = len(nums)\n    graph = defaultdict(list)\n    for e in edges:\n        graph[e[0]].append(e[1])\n        graph[e[1]].append(e[0])\n\n    total = sum(nums)\n    if total % 2 != 0:\n        return 0  # It is impossible to split the tree fairly.\n\n    result = []\n    dfs(0, -1, nums, graph, total, result)\n    return len(result) - 1", "def find_K(nums):\n    s = set(nums)\n    k = -1\n    for num in nums:\n        if -num in s:\n            k = max(k, abs(num))\n    return k", "def distinct_integers_after_reversing_and_adding(nums):\n    distinct = set(nums)\n    for num in nums:\n        reversed_num = int(str(num)[::-1])\n        distinct.add(reversed_num)\n    return len(distinct)", "def sum_with_reverse(num: int) -> bool:\n    for i in range(num + 1):\n        reverse = int(str(i)[::-1])\n        if i + reverse == num:\n            return True\n    return False", "def fixed_bound_subarrays(nums, minK, maxK):\n    count, min_index, max_index = 0, -1, -1\n    for i, num in enumerate(nums):\n        if num==minK:\n            min_index=i\n        elif num==maxK:\n            max_index=i\n        \n        count += min(min_index, max_index) + 1\n    return count", "def flip_trees(n, queries):\n    flipped_nodes = {}\n    for query in queries:\n        flipped_nodes[query] = not flipped_nodes.get(query, False)\n        while query > 1:\n            query //= 2\n            flipped_nodes[query] = not flipped_nodes.get(query, False)\n\n    count = 0\n    for value in flipped_nodes.values():\n        if value:\n            count += 1\n\n    return count", "def has_event_conflict(start1: str, end1: str, start2: str, end2: str) -> bool:\n    start_hour1, start_min1 = map(int, start1.split(\":\"))\n    start_hour2, start_min2 = map(int, start2.split(\":\"))\n    end_hour1, end_min1 = map(int, end1.split(\":\"))\n    end_hour2, end_min2 = map(int, end2.split(\":\"))\n\n    total_min1_start = start_hour1 * 60 + start_min1\n    total_min1_end = end_hour1 * 60 + end_min1\n    total_min2_start = start_hour2 * 60 + start_min2\n    total_min2_end = end_hour2 * 60 + end_min2\n\n    return not (total_min1_end <= total_min2_start or total_min1_start >= total_min2_end)", "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef count_GCD_subarrays(nums, k):\n    count = 0\n\n    for i in range(len(nums)):\n        gcd_so_far = 0\n        for j in range(i, len(nums)):\n            gcd_so_far = gcd(gcd_so_far, nums[j])\n            if gcd_so_far == k:\n                count += 1\n\n    return count", "def minCost(nums, cost):\n    ans = float(\"inf\")\n    base = min(nums)\n    \n    for target in range(base, base + 2):\n        local_res = 0\n        for i in range(len(nums)):\n            local_res += abs(nums[i] - target) * cost[i]\n        ans = min(ans, local_res)\n    \n    return ans", "def minOperations(nums, target):\n    n = len(nums)\n    sum_nums = sum(nums)\n    sum_target = sum(target)\n    diff = (sum_target - sum_nums) // 2\n    cnt = 0\n    for i in range(n):\n        if nums[i] > target[i]:\n            cnt += (nums[i] - target[i] - diff) // 2\n    return cnt", "def distinctStrings(s, k):\n    n = len(s)\n    cnt = 0\n    st = set()\n\n    for i in range(n - k + 1):\n        temp = s[:i] + s[i + k:]\n        if temp not in st:\n            st.add(temp)\n            cnt = (cnt + 1) % 1000000007\n\n    return cnt + 1 # Add 1 for the original string", "def stringWithDifferentDifference(words):\n    def get_difference_array(word):\n        return [ord(word[i+1]) - ord(word[i]) for i in range(len(word) - 1)]\n\n    diffArrays = [get_difference_array(word) for word in words]\n    \n    oddArrayIndex = -1\n    for i in range(1, len(diffArrays)):\n        matchCount = sum(diffArrays[0][j] == diffArrays[i][j] for j in range(len(diffArrays[i])))\n        if matchCount == 0:\n            oddArrayIndex = i\n            break\n\n    return words[oddArrayIndex]", "def count_differences(a, b):\n    return sum(c1 != c2 for c1, c2 in zip(a, b))\n\ndef find_matching_words(queries, dictionary):\n    result = []\n    for query in queries:\n        for dict_word in dictionary:\n            if count_differences(query, dict_word) <= 2:\n                result.append(query)\n                break\n    return result", "def minSeededValue(nums, space):\n    count = {}\n    for num in nums:\n        count[num % space] = count.get(num % space, 0) + 1\n    return max(count, key=lambda x: (count[x], -x))", "def find_second_greater(nums):\n    n = len(nums)\n    answer = [-1] * n\n    for i in range(n):\n        k = -1\n        for j in range(i + 1, n):\n            if nums[j] > nums[i]:\n                if k == -1:\n                    k = j\n                else:\n                    answer[i] = nums[j]\n                    break\n    return answer", "def average_even_divisible_by_three(nums):\n    total = 0\n    count = 0\n    for num in nums:\n        if num % 2 == 0 and num % 3 == 0:\n            total += num\n            count += 1\n    return total // count if count > 0 else 0", "from collections import defaultdict\n\ndef highest_popularity(creators, ids, views):\n    popularity = defaultdict(int)\n    most_viewed = {}\n\n    for i in range(len(creators)):\n        popularity[creators[i]] += views[i]\n        if creators[i] not in most_viewed or views[i] > most_viewed[creators[i]][1] or (views[i] == most_viewed[creators[i]][1] and ids[i] < most_viewed[creators[i]][0]):\n            most_viewed[creators[i]] = (ids[i], views[i])\n\n    max_popularity = max(popularity.values())\n\n    return [[creator, most_viewed[creator][0]] for creator, pop in popularity.items() if pop == max_popularity]", "def digit_sum(n):\n    return sum(int(digit) for digit in str(n))\n\ndef minimum_beautiful(n, target):\n    x = 0\n    while digit_sum(n + x) > target:\n        x += 1\n    return x", "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x: int):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def removeSubtrees(self, root: TreeNode, queries: List[int]) -> List[int]:\n        def removeSubtree(node: TreeNode, val: int):\n            if not node: return\n\n            if node.left and node.left.val == val:\n                node.left = None\n            else:\n                removeSubtree(node.left, val)\n\n            if node.right and node.right.val == val:\n                node.right = None\n            else:\n                removeSubtree(node.right, val)\n\n        def findHeight(node: TreeNode) -> int:\n            if not node: return -1\n\n            return 1 + max(findHeight(node.left), findHeight(node.right))\n\n        answer = []\n        for query in queries:\n            removeSubtree(root, query)\n            answer.append(findHeight(root))\n\n        return answer", "def min_operations(nums):\n    n = len(nums)\n    idx0 = -1\n\n    for i in range(n):\n        if nums[i] == 0:\n            idx0 = i\n            break\n\n    cnt1 = 0\n    cnt2 = 0\n\n    for i in range(1, n):\n        if abs(nums[i] - nums[i - 1]) != 1:\n            cnt1 += abs(nums[i] - nums[i - 1]) - 1\n\n    for i in range(idx0 + 1, n):\n        if nums[i] < nums[i - 1]:\n            cnt2 += 1\n\n    return min(cnt1, cnt2)", "def performOps(nums):\n    n = len(nums)\n    for i in range(n - 1):\n        if nums[i] == nums[i + 1]:\n            nums[i] *= 2\n            nums[i + 1] = 0\n    nonZeroIndex = 0\n    for i in range(n):\n        if nums[i] != 0:\n            nums[nonZeroIndex] = nums[i]\n            nonZeroIndex += 1\n    while(nonZeroIndex < n):\n        nums[nonZeroIndex] = 0\n        nonZeroIndex += 1\n    return nums", "def maxSubarraySumWithDistinctElements(nums: List[int], k: int) -> int:\n    max_sum = 0\n    window_sum = 0\n    freq_map = collections.defaultdict(int)\n    \n    for i, num in enumerate(nums):\n        freq_map[num] += 1\n        window_sum += num\n        if i >= k:\n            freq_map[nums[i - k]] -= 1\n            window_sum -= nums[i - k]\n        if i >= k - 1:\n            is_distinct = all(value <= 1 for value in freq_map.values())\n            if is_distinct:\n                max_sum = max(max_sum, window_sum)\n    \n    return max_sum", "def hireWorkers(costs, k, candidates):\n    n = len(costs)\n    workers = sorted([(cost, i) for i, cost in enumerate(costs)])\n\n    cost = 0\n    for i in range(k):\n        if min(workers[i][1], n - workers[i][1] - 1) < candidates:\n            cost += workers[i][0]\n\n    return cost", "def min_total_distance(robot: List[int], factory: List[List[int]]) -> int:\n    robot.sort()\n    factory.sort()\n\n    res = 0\n    idx = 0\n    for f_pos, f_limit in factory:\n        while f_limit > 0 and idx < len(robot):\n            res += abs(f_pos - robot[idx])\n            idx += 1\n            f_limit -= 1\n    \n    return res", "from math import gcd\n\ndef min_valid_subarrays(nums):\n    count = 0\n    while nums:\n        for i in range(len(nums)):\n            if gcd(nums[i], nums[-1]) > 1:\n                break\n        else:\n            count += 1\n            nums.pop()\n    return count if count > 0 else -1", "def distinctAverages(nums):\n    averages = set()\n    nums.sort()\n    n = len(nums)\n    for i in range(n // 2):\n        averages.add((nums[i] + nums[n - 1 - i]) / 2.0)\n    return len(averages)", "def modPow(x, n, mod):\n    res = 1\n    while n > 0:\n        if n % 2 == 1:\n            res = (res * x) % mod\n        x = (x * x) % mod\n        n //= 2\n    return res\n\ndef goodStrings(low, high, zero, one):\n    mod = 1000000007\n    good_strs = ((modPow(2, high, mod) - modPow(2, low - 1, mod) + 1) * (zero + 1)) % mod\n    return (good_strs * (one + 1)) % mod", "from collections import defaultdict\n\ndef dfs(node, parent, bob, time, alice_income, res, amount, tree):\n    if time < bob or amount[node] >= 0:\n        alice_income += amount[node]\n    else:\n        alice_income += amount[node] // 2\n    amount[node] = 0\n    is_leaf = True\n    for child in tree[node]:\n        if child != parent:\n            is_leaf = False\n            dfs(child, node, bob, time + 1, alice_income, res, amount, tree)\n    if is_leaf:\n        res[0] = max(res[0], alice_income)\n\ndef maxNetIncome(edges, bob, amount):\n    tree = defaultdict(list)\n    for edge in edges:\n        tree[edge[0]].append(edge[1])\n        tree[edge[1]].append(edge[0])\n    res = [-100000]\n    dfs(0, -1, bob, 0, 0, res, amount, tree)\n    return res[0]", "def split_message(message: str, limit: int) -> list[str]:\n    n = len(message)\n    a = (limit - 3) * (n // (limit - 3)) - n\n    b = n // (limit - 3)\n    if (n + b + a) % (limit - 2) != 0:\n        return []\n    num_parts = (n + b + a) // (limit - 2)\n    result = []\n    i = k = cnt = 0\n    while i < n or k < num_parts:\n        temp = []\n        while cnt < limit - 3:\n            cnt += 1\n            temp.append(message[i])\n            i += 1\n            if i == n: break\n        cnt = 0\n        temp.append(str(k+1) + \"/\" + str(num_parts) + \" \")\n        k += 1\n        result.append(\"\".join(temp))\n    return result", "def convert_temperature(celsius):\n    kelvin = celsius + 273.15\n    fahrenheit = celsius * 1.8 + 32\n    return [kelvin, fahrenheit]", "def count_lcm_subarrays(nums: List[int], k: int) -> int:\n    def lcm(a, b):\n        temp = a\n        while temp % b != 0:\n            temp += a\n        return temp\n\n    count = 0\n    for i in range(len(nums)):\n        curr_lcm = nums[i]\n        for j in range(i, len(nums)):\n            curr_lcm = lcm(curr_lcm, nums[j])\n            if curr_lcm == k:\n                count += 1\n\n    return count", "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef minSwaps(root: TreeNode) -> int:\n    count = 0\n    que = deque([(root, 0)])\n\n    level_vals = []\n    prev_depth = -1\n\n    while que:\n        node, depth = que.popleft()\n\n        if prev_depth != depth:\n            level_vals.sort()\n            for i in range(1, len(level_vals)):\n                count += abs(level_vals[i] - level_vals[i-1]) - 1\n            prev_depth = depth\n            level_vals.clear()\n        level_vals.append(node.val)\n\n        if node.left:\n            que.append((node.left, depth + 1))\n        if node.right:\n            que.append((node.right, depth + 1))\n\n    level_vals.sort()\n    for i in range(1, len(level_vals)):\n        count += abs(level_vals[i] - level_vals[i-1]) - 1\n\n    return count", "def maxPalindromesSubstrings(s, k):\n    n = len(s)\n    if n < k:\n        return 0\n    count = 0\n    dp = [[False] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if i == j:\n                dp[i][j] = True\n            elif s[i] == s[j]:\n                dp[i][j] = i + 1 > j - 1 or dp[i + 1][j - 1]\n            else:\n                dp[i][j] = False\n            if j - i + 1 >= k and dp[i][j]:\n                count += 1\n                i = j\n                break\n    return count", "from heapq import heappush, heappop\n\ndef minTotalCost(n, roads, appleCost, k):\n    graph = [[] for _ in range(n+1)]\n    for u, v, cost in roads:\n        graph[u].append((v, cost))\n        graph[v].append((u, cost))\n\n    answer = [0] * n\n    for start in range(1, n+1):\n        pq = [(0, start)]\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n\n        while pq:\n            d, u = heappop(pq)\n\n            if d > dist[u]:\n                continue\n\n            for v, cost in graph[u]:\n                c = d + cost + (0 if u == start else cost * k) + appleCost[v - 1]\n                if c < dist[v]:\n                    dist[v] = c\n                    heappush(pq, (c, v))\n\n        answer[start-1] = dist[start]\n    return answer", "def countTriplets(nums):\n    count = 0\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\n                    count += 1\n    \n    return count", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef findMinMax(root, queries):\n    if not root:\n        return []\n\n    ans = [[-1, -1] for _ in range(len(queries))]\n    for i in range(len(queries)):\n        node = root\n        query = queries[i]\n        while node:\n            if node.val < query:\n                ans[i][0] = node.val\n                node = node.right\n            else:\n                ans[i][1] = node.val\n                if node.val == query:\n                    ans[i][0] = query\n                    break\n                node = node.left\n    return ans", "from collections import defaultdict, deque\n\n\ndef min_fuel(roads, seats):\n    n = len(roads) + 1\n    graph = defaultdict(list)\n    for road in roads:\n        graph[road[0]].append(road[1])\n        graph[road[1]].append(road[0])\n\n    distance = [-1] * n\n    q = deque([0])\n    distance[0] = 0\n\n    while q:\n        city = q.popleft()\n        for neighbor in graph[city]:\n            if distance[neighbor] == -1:\n                distance[neighbor] = distance[city] + 1\n                q.append(neighbor)\n\n    total_fuel = 0\n    for city in range(1, n):\n        total_fuel += (distance[city] - 1) // (seats - 1) + 1\n    return total_fuel", "def numBeautifulPartitions(s: str, k: int, minLength: int) -> int:\n    MOD = 10**9 + 7\n    primes = {'2', '3', '5', '7'}\n    n = len(s)\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            for l in range(minLength, i + 1):\n                if i - l >= j - 1 and s[i - l] in primes and s[i - 1] not in primes:\n                    dp[i][j] += dp[i - l][j - 1]\n                    if dp[i][j] >= MOD:\n                        dp[i][j] -= MOD\n                        \n    return dp[n][k]", "from collections import defaultdict\n\ndef maxXorSubtree(n, edges, values):\n    tree = defaultdict(list)\n\n    for edge in edges:\n        tree[edge[0]].append(edge[1])\n        tree[edge[1]].append(edge[0])\n\n    first_max = [0]\n    root_sum = dfs(0, -1, tree, values, first_max)\n\n    return root_sum ^ first_max[0]\n\ndef dfs(node, parent, tree, values, first_max):\n    current_sum = values[node]\n\n    for child in tree[node]:\n        if child != parent:\n            current_sum ^= dfs(child, node, tree, values, first_max)\n\n    first_max[0] = max(first_max[0], current_sum)\n\n    return current_sum", "def min_cuts(n):\n    if n % 2 == 0:\n        return n // 2\n    else:\n        return n", "def create_difference_matrix(grid):\n    m, n = len(grid), len(grid[0])\n    ones_row, ones_col = [0] * m, [0] * n\n    diff = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            ones_row[i] += grid[i][j]\n            ones_col[j] += grid[i][j]\n\n    for i in range(m):\n        for j in range(n):\n            diff[i][j] = ones_row[i] + ones_col[j] - (n - ones_row[i]) - (m - ones_col[j])\n\n    return diff", "def min_penalty(customers: str) -> int:\n    n = len(customers)\n    open_penalty, closed_penalty = 0, 0\n\n    for c in customers:\n        if c == 'N':\n            open_penalty += 1\n        else:\n            closed_penalty += 1\n\n    result = closed_penalty\n    penalty = closed_penalty\n\n    for c in customers:\n        if c == 'N':\n            penalty -= 1\n        else:\n            penalty += 1\n\n        result = min(result, penalty)\n\n    return result", "def palindrome_subsequence(s):\n    n = len(s)\n    mod = 1000000007\n    dp = [[0] * n for _ in range(10)]\n    for i in range(n): dp[int(s[i])][i] = 1\n    for len_ in range(1, 5):\n        for d in range(10):\n            for i, j in zip(range(n - len_), range(len_, n)):\n                dp[d][j] = (dp[d][j - 1] + (1 if s[j] == str(d) else 0)) % mod\n    ans = 0\n    for d1 in range(10):\n        for d2 in range(10):\n            ans += dp[d1][n - 5] * dp[d2][n - 1] % mod\n    return ans % mod", "def find_pivot(n: int) -> int:\n    total = n * (n + 1) // 2\n    left_sum = 0\n    for x in range(1, n + 1):\n        left_sum += x\n        if 2 * left_sum == total:\n            return x\n    return -1", "def min_addition(s: str, t: str) -> int:\n    s_len = len(s)\n    t_len = len(t)\n    i, j = 0, 0\n    while i < s_len and j < t_len:\n        if s[i] == t[j]:\n            j += 1\n        i += 1\n    return t_len - j", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef removeNodes(head):\n    if not head: return None\n    maxNode = head\n    currentNode = head\n    prevNode = None\n\n    while currentNode and currentNode.next:\n        if currentNode.next.val > maxNode.val:\n            if prevNode: prevNode.next = currentNode.next\n            else: head = currentNode.next\n            maxNode = currentNode.next\n        else:\n            prevNode = currentNode\n        currentNode = currentNode.next\n    maxNode.next = removeNodes(maxNode.next)\n    return head", "def count_subarrays_with_median(nums, k):\n    ans = 0\n    for left in range(len(nums)):\n        count = 0\n        subarray = []\n        for right in range(left, len(nums)):\n            count += nums[right] == k\n            subarray.insert((nums[right], nums[right]), nums[right:index + 1])\n            if len(subarray) % 2 and subarray[len(subarray) // 2] == k:\n                ans += count\n    return ans", "def ratio_substring_count(s: str, num1: int, num2: int) -> int:\n    count0, count1 = 0, 0\n    frequency = {0: 1}\n    result = 0\n\n    for c in s:\n        if c == '0':\n            count0 += 1\n        else:\n            count1 += 1\n\n        curr_diff = count0 * num2 - count1 * num1\n        result += frequency.get(curr_diff, 0)\n        frequency[curr_diff] = frequency.get(curr_diff, 0) + 1\n\n    return result", "def is_circular(sentence: str) -> bool:\n    words = sentence.split()\n    for i in range(1, len(words)):\n        if words[i - 1][-1] != words[i][0]:\n            return False\n    return words[-1][-1] == words[0][0]", "def maximumChemistry(skill):\n    total_sum = sum(skill)\n    target_sum = total_sum // 2\n    if total_sum % 2 == 1:\n        return -1\n\n    dp = {0: 1}\n    max_chemistry = 0\n\n    for s in skill:\n        for i in range(target_sum - s, -1, -1):\n            if i in dp:\n                dp[i + s] = dp.get(i + s, 0) + dp[i]\n                if i + s == target_sum:\n                    max_chemistry += dp[i] * s\n\n    return max_chemistry if max_chemistry > 0 else -1", "from heapq import heappush, heappop\nfrom collections import defaultdict\n\ndef minimumScore(n, roads):\n    adj = defaultdict(list)\n    for road in roads:\n        adj[road[0]].append((road[1], road[2]))\n        adj[road[1]].append((road[0], road[2]))\n\n    INF = int(1e9)\n    pq = [(0, 1)]\n\n    minDist = [INF] * (n + 1)\n    while pq:\n        curDist, curCity = heappop(pq)\n\n        if curCity == n:\n            return curDist\n\n        if curDist < minDist[curCity]:\n            minDist[curCity] = curDist\n            for nextCity, nextDist in adj[curCity]:\n                candidate_dist = max(curDist, nextDist)\n                if candidate_dist < minDist[nextCity]:\n                    heappush(pq, (candidate_dist, nextCity))\n\n    return -1", "from collections import defaultdict, deque\n\ndef maxGroups(n, edges):\n    graph = defaultdict(list)\n    color = [0] * (n + 1)\n\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n\n    max_group = 0\n    for i in range(1, n + 1):\n        if color[i] == 0:\n            q = deque([i])\n            color[i] = 1\n            while q:\n                node = q.popleft()\n                max_group = max(max_group, color[node])\n                for neighbor in graph[node]:\n                    if color[neighbor] == 0:\n                        color[neighbor] = color[node] + 1\n                        q.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return -1\n                        \n    return max_group", "def numberOfEvenSubarrays(nums):\n    n = len(nums)\n    evenCount, oddCount, result = 0, 0, 0\n\n    for num in nums:\n        if num % 2 == 0:\n            evenCount += 1\n            result += evenCount\n        else:\n            evenCount, oddCount = oddCount, evenCount\n            oddCount += 1\n            result += oddCount\n\n    return result", "def maxValue(strs) -> int:\n    max_value = 0\n    for str in strs:\n        if str.isdigit():\n            value = int(str)\n        else:\n            value = len(str)\n        max_value = max(max_value, value)\n    return max_value", "def max_star_sum(vals, edges, k):\n    adj = [[] for _ in range(len(vals))]\n\n    for edge in edges:\n        adj[edge[0]].append(vals[edge[1]])\n        adj[edge[1]].append(vals[edge[0]])\n\n    ans = float(\"-inf\")\n    for i in range(len(vals)):\n        adj[i].sort(reverse=True)\n        ans = max(ans, vals[i] + sum(adj[i][:k]))\n\n    return ans", "def minimum_path_cost(stones):\n    n = len(stones)\n    max_cost = stones[n-1]\n    for i in range(1, n-1):\n        max_cost = min(max_cost, max(stones[i], stones[n-1]-stones[i]))\n    return max_cost", "def min_cost(nums1: List[int], nums2: List[int]) -> int:\n    value_to_indices = {}\n    for i, val in enumerate(nums1):\n        value_to_indices.setdefault(val, []).append(i)\n\n    result = 0\n    for val in nums2:\n        if not value_to_indices[val]:\n            return -1\n        result += value_to_indices[val].pop()\n\n    return result", "def maxValueAfterOperations(grid):\n    ans = 0\n    while grid:\n        maxVal = 0\n        maxRow = -1\n\n        for i, row in enumerate(grid):\n            rowMax = max(row)\n            if rowMax > maxVal:\n                maxVal = rowMax\n                maxRow = i\n            grid[i] = [e for e in row if e != rowMax]\n\n        ans += maxVal\n        if not grid[maxRow]:\n            grid.pop(maxRow)\n\n    return ans", "def longest_square_streak(nums):\n    num_set = set(nums)\n    longest_streak = -1\n\n    for num in num_set:\n        streak = 1\n\n        while int(num ** 0.5) in num_set:\n            streak += 1\n            num = int(num ** 0.5)\n        \n        longest_streak = max(longest_streak, streak)\n\n    return longest_streak if longest_streak >= 2 else -1", "class Allocator:\n    def __init__(self, n: int):\n        self.mem = [0] * n\n\n    def allocate(self, size: int, mID: int) -> int:\n        start, count = -1, 0\n        for i in range(len(self.mem) + 1):\n            if i < len(self.mem) and self.mem[i] == 0:\n                if start == -1:\n                    start = i\n                count += 1\n            else:\n                if count >= size:\n                    for j in range(start, start + size):\n                        self.mem[j] = mID\n                    return start\n                start, count = -1, 0\n        return -1\n\n    def free(self, mID: int) -> int:\n        count = 0\n        for i in range(len(self.mem)):\n            if self.mem[i] == mID:\n                count += 1\n                self.mem[i] = 0\n        return count", "from typing import List\n\ndef maxPoints(grid: List[List[int]], queries: List[int]) -> List[int]:\n    m, n = len(grid), len(grid[0])\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n\n    def dfs(x: int, y: int, q: int, visited: set) -> int:\n        if 0 <= x < m and 0 <= y < n and grid[x][y] < q and (x, y) not in visited:\n            visited.add((x, y))\n            points = 1\n            for i in range(4):\n                nx, ny = x + dx[i], y + dy[i]\n                points += dfs(nx, ny, q, visited)\n            return points\n        return 0\n\n    return [dfs(0, 0, query, set()) for query in queries]", "def subsequence_or_sum(nums):\n    result = 0\n    for num in nums:\n        result |= num\n    return result", "def count_similar_pairs(words):\n    count = 0\n    for i in range(len(words)):\n        for j in range(i + 1, len(words)):\n            set1 = set(words[i])\n            set2 = set(words[j])\n            if set1 == set2:\n                count += 1\n    return count", "def smallestFactorization(n):\n    if n <= 3:\n        return n\n    result, factor = 0, 1\n    for i in range(2, 6):\n        while n % i == 0:\n            result += factor * i\n            factor *= 10\n            n //= i\n    return result if n == 1 else n", "from collections import defaultdict\n\ndef possible_degree_even(n, edges):\n    degrees = defaultdict(int)\n    for a, b in edges:\n        degrees[a] += 1\n        degrees[b] += 1\n\n    odd_degrees = sum(1 for d in range(1, n + 1) if degrees[d] % 2 != 0)\n    return odd_degrees == 0 or odd_degrees == 2", "def length_of_cycle(n, queries):\n    result = []\n    for A, B in queries:\n        depth_A, depth_B = 0, 0\n        while A != B:\n            if A < B:\n                A, B = B, A\n            A >>= 1\n            depth_A += 1\n        result.append(depth_A + depth_B)\n    return result", "def isValidPath(grid, row, col, zeros, ones):\n    if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]):\n        return False\n    if grid[row][col] == 1:\n        ones += 1\n    else:\n        zeros += 1\n    if row == len(grid) - 1 and col == len(grid[0]) - 1:\n        return zeros == ones\n    return (isValidPath(grid, row + 1, col, zeros, ones)\n            or isValidPath(grid, row, col + 1, zeros, ones))\n\ndef equalPath(grid):\n    return isValidPath(grid, 0, 0, 0, 0)", "def max_captured_forts(forts):\n    n = len(forts)\n    max_capture = 0\n    for i in range(n):\n        if forts[i] == 1:\n            for j in range(i+1, n):\n                if forts[j] != -1:\n                    capture = sum(1 for k in range(i+1, j) if forts[k] == 0)\n                    if forts[j] == 1:\n                        max_capture = max(max_capture, capture)\n    return max_capture", "def top_k_students(positive_feedback, negative_feedback, report, student_id, k):\n    points = {}\n    for i in range(len(report)):\n        pos_count, neg_count = 0, 0\n        for pos in positive_feedback:\n            pos_index = report[i].find(pos)\n            while pos_index != -1:\n                pos_count += 1\n                pos_index = report[i].find(pos, pos_index + len(pos))\n        for neg in negative_feedback:\n            neg_index = report[i].find(neg)\n            while neg_index != -1:\n                neg_count += 1\n                neg_index = report[i].find(neg, neg_index + len(neg))\n        \n        points[student_id[i]] = points.get(student_id[i], 0) + 3 * pos_count - neg_count\n\n    students = sorted(student_id, key=lambda x: (-points[x], x))\n    return students[:k]", "def minimum_possible_max(divisor1, divisor2, unique_cnt1, unique_cnt2):\n    return (divisor1 - 1) * unique_cnt1 + (divisor2 - 1) * unique_cnt2 + 1", "def shortest_distance(words, target, startIndex):\n    n = len(words)\n    left, right, i = 0, 0, startIndex\n    while True:\n        if words[i] == target:\n            return min(left, right)\n        left += 1\n        right += 1\n        i = (i + 1) % n\n        if left == n:\n            break\n    return -1", "def min_minutes(s: str, k: int) -> int:\n    n = len(s)\n    left_counts = [0] * 3\n    right_counts = [0] * 3\n    for c in s:\n        right_counts[ord(c) - ord('a')] += 1\n\n    ans, total = n, 0\n    l, r = 0, n - 1\n    while l < r:\n        while l < r and left_counts[ord(s[l]) - ord('a')] < k and right_counts[ord(s[r]) - ord('a')] < k:\n            need_left = max(0, k - left_counts[ord(s[l]) - ord('a')])\n            need_right = max(0, k - right_counts[ord(s[r]) - ord('a')])\n            if need_left <= need_right:\n                total += need_left\n                l += 1\n                left_counts[ord(s[l]) - ord('a')] += 1\n                right_counts[ord(s[l]) - ord('a')] -= 1\n            else:\n                total += need_right\n                r -= 1\n                right_counts[ord(s[r]) - ord('a')] -= 1\n                left_counts[ord(s[r]) - ord('a')] += 1\n        ans = min(ans, total)\n        if l + 1 < n:\n            total -= left_counts[ord(s[l]) - ord('a')]\n            left_counts[ord(s[l]) - ord('a')] -= 1\n            right_counts[ord(s[l + 1]) - ord('a')] += 1\n            l += 1\n        else:\n            break\n    if all(cnt >= k for cnt in left_counts): \n        return ans\n    return -1", "def max_tastiness(price, k):\n    price.sort()\n    max_tastiness = 0\n    for i in range(len(price) - k + 1):\n        min_diff = float('inf')\n        for j in range(i, i + k - 1):\n            min_diff = min(min_diff, price[j + 1] - price[j])\n        max_tastiness = max(max_tastiness, min_diff)\n\n    return max_tastiness", "def countPartitions(nums, k):\n    total_sum = sum(nums)\n    n = len(nums)\n    mod = 1000000007\n\n    if total_sum < k * 2:\n        return 0\n\n    dp = [1] * (n + 1)\n\n    for i in range(1, k):\n        for j in range(n - 1, 0, -1):\n            dp[j] = (dp[j] * j + dp[j - 1]) % mod\n\n    result = 0\n\n    for i in range(n - 1):\n        total_sum -= nums[i]\n        if total_sum >= k:\n            result = (result + dp[i + 1]) % mod\n\n    return result", "def kBigIndices(nums, k):\n    n = len(nums)\n    left, right = [0] * n, [0] * n\n\n    for i in range(1, n):\n        if nums[i] > nums[i - 1]:\n            left[i] = left[i - 1] + 1\n\n        j = n - i - 1\n        if nums[j] < nums[j + 1]:\n            right[j] = right[j + 1] + 1\n\n    return sum(1 for i in range(n) if left[i] >= k and right[i] >= k)", "def digits_dividing_num(num):\n    count = 0\n    temp = num\n    while temp > 0:\n        digit = temp % 10\n        if num % digit == 0:\n            count += 1\n        temp //= 10\n    return count", "def count_distinct_prime_factors(nums):\n    prime_factors = set()\n    for n in nums:\n        for divisor in range(2, int(n**0.5) + 1):\n            if n % divisor == 0:\n                prime_factors.add(divisor)\n                prime_factors.add(n // divisor)\n    return len(prime_factors)", "def min_partitions(s: str, k: int) -> int:\n    n = len(s)\n    count = 0\n    idx = 0\n\n    while idx < n:\n        currentValue = 0\n        while idx < n and currentValue * 10 + int(s[idx]) <= k:\n            currentValue = currentValue * 10 + int(s[idx])\n            idx += 1\n\n        if currentValue == 0:\n            return -1\n        count += 1\n\n    return count", "def is_prime(n):\n    if n <= 1:\n        return False\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 1\n    return True\n\ndef closest_prime_pair(left, right):\n    min_dist = right - left + 1\n    ans = [-1, -1]\n    for i in range(left, right + 1):\n        if is_prime(i):\n            for j in range(i + 1, right + 1):\n                if is_prime(j) and j - i < min_dist:\n                    min_dist = j - i\n                    ans = [i, j]\n    return ans", "def maxFrequencyScore(nums, k):\n    n = len(nums)\n    right = 0\n    count = 0\n    max_score = 0\n    score = 0\n    freq_map = {}\n\n    for left in range(n):\n        while right < n and count < k:\n            score = (score + nums[right] * freq_map.get(nums[right], 0)) % 1000000007\n            freq_map[nums[right]] = freq_map.get(nums[right], 0) + 1\n            count += 1\n            right += 1\n\n        max_score = max(max_score, score)\n\n        if count == k:\n            score -= nums[left] * (freq_map[nums[left]] - 1)\n            freq_map[nums[left]] -= 1\n            count -= 1\n\n    return max_score", "def boxCategory(length: int, width: int, height: int, mass: int) -> str:\n    bulky = length >= 10000 or width >= 10000 or height >= 10000 or int(length) * width * height >= 1000000000\n    heavy = mass >= 100\n    \n    if bulky and heavy:\n        return \"Both \"\n    if bulky:\n        return \"Bulky \"\n    if heavy:\n        return \"Heavy \"\n    return \"Neither \"", "from collections import deque\n\nclass DataStream:\n    def __init__(self, value: int, k: int):\n        self.value = value\n        self.k = k\n        self.stream = deque()\n\n    def consec(self, num: int) -> bool:\n        self.stream.append(num)\n        if len(self.stream) > self.k:\n            self.stream.popleft()\n\n        return len(self.stream) == self.k and self.stream.count(self.value) == self.k", "def xor_beauty(nums):\n    n = len(nums)\n    maxXOR = 1024\n    counter = [0] * maxXOR\n    \n    for num in nums:\n        counter[num % maxXOR] += 1\n        \n    xor_beauty = 0\n    for i in range(maxXOR):\n        for j in range(i, maxXOR):\n            k = (i | j) & (~(i ^ j))\n            if k < maxXOR and k >= j:\n                count = counter[i] * counter[j] * (1 if i == j else 2)\n                if k != i and k != j:\n                    count *= counter[k]\n                xor_beauty ^= count\n                \n    return xor_beauty", "def max_min_power(stations, r, k):\n    n = len(stations)\n    total_power = [0] * n\n    for i in range(n):\n        for j in range(max(0, i - r), min(n, i + r + 1)):\n            total_power[j] += stations[i]\n\n    sumk = 0\n    min_power = float('inf')\n    for i in range(r, n - r):\n        sumk += stations[i]\n        min_power = min(min_power, total_power[i])\n\n    for j in range(2 * r):\n        i = n - 2 * r - 1 - j\n        sumk -= stations[i + r + 1]\n        min_power -= stations[j]\n        min_power += sumk\n        min_power += k\n        min_power = min(min_power, total_power[j])\n\n    return min_power", "def max_positive_negative_count(nums):\n    pos = next((i for i, x in enumerate(nums) if x >= 0), len(nums))\n    neg = len(nums) - pos\n    return max(pos, neg)", "import heapq\n\ndef max_score(nums, k):\n    pq = [-x for x in nums]\n    heapq.heapify(pq)\n    score = 0\n\n    for _ in range(k):\n        cur = -heapq.heappop(pq)\n        score += cur\n        heapq.heappush(pq, -cur // 3)\n\n    return score", "def compare(w1,w2):\n    counts_w1 = [0]*26\n    counts_w2 = [0]*26\n    for c in w1: counts_w1[ord(c)-ord('a')] += 1\n    for c in w2: counts_w2[ord(c)-ord('a')] += 1\n    for i in range(26):\n        if counts_w1[i] and counts_w2[i]: return True\n    return False\n\ndef swap_equal_distinct(word1, word2):\n    exch = compare(word1, word2)\n    return exch and len(word1) == len(word2)", "from heapq import heappush, heappop\n\ndef getLastMoment(n, k, time):\n    left = [(time[j][0] + time[j][2], j) for j in range(k)]\n    right = []\n\n    while n:\n        while right and right[0][0] <= left[0][0]:\n            right_top = heappop(right)\n            heappush(left, (right_top[0] + time[right_top[1]][0] + time[right_top[1]][2], right_top[1]))\n        left_top = heappop(left)\n        time[left_top[1]][2] += time[left_top[1]][3] + time[left_top[1]][0] + time[left_top[1]][1]\n        heappush(right, (left_top[0] + time[left_top[1]][1], left_top[1]))\n        n -= 1\n\n    lastMoment = -1\n    while right:\n        right_top = heappop(right)\n        lastMoment = max(lastMoment, time[right_top[1]][2])\n    return lastMoment", "def countGoodStrings(minLength, maxLength, oneGroup, zeroGroup):\n    mod = 1000000007\n    maxCount = maxLength // oneGroup + maxLength // zeroGroup\n\n    dp = [0] * (maxCount + 1)\n    dp[0] = 1\n\n    for i in range(1, maxCount + 1):\n        dp[i] = dp[i - 1] * (1 if i % oneGroup == 0 or i % zeroGroup == 0 else 0) % mod\n\n    ans = 0\n    for i in range(maxCount + 1):\n        ans = (ans + dp[minLength // oneGroup + minLength // zeroGroup - i]\n               - (0 if minLength - 1 // oneGroup + minLength - 1 // zeroGroup - i < 0 else\n                  dp[(minLength - 1) // oneGroup + (minLength - 1) // zeroGroup - i])) % mod\n\n    return ans", "def time_crossing_the_door(arrival, state):\n    n = len(arrival)\n    answer = [0] * n\n    door_seen_time = [-1, -1]\n    i, t = 0, 0\n    while i < n:\n        while t < arrival[i]:\n            t += 1\n        direction = 1 if door_seen_time[1] != t - 1 else 0\n        if state[i] == direction:\n            door_seen_time[state[i]] = t\n        else:\n            while i + 1 < n and arrival[i + 1] == t and state[i + 1] != direction:\n                i += 1\n            if i + 1 < n and arrival[i + 1] == t and state[i + 1] == direction:\n                door_seen_time[state[i + 1]] = t\n                i += 1\n            else:\n                t -= 1\n                i -= 1\n        answer[i] = door_seen_time[state[i]]\n        i += 1\n        t += 1\n    return answer", "def difference_between_element_and_digit_sum(nums):\n    element_sum = sum(nums)\n    digit_sum = sum(sum(int(digit) for digit in str(num)) for num in nums)\n    return abs(element_sum - digit_sum)", "def apply_queries(n, queries):\n    mat = [[0] * n for _ in range(n)]\n\n    for query in queries:\n        for i in range(query[0], query[2] + 1):\n            for j in range(query[1], query[3] + 1):\n                mat[i][j] += 1\n\n    return mat", "def goodSubarrays(nums, k):\n    count = {0: 1}\n    result = 0\n    prefix_sum = 0\n\n    for num in nums:\n        prefix_sum += num - 1\n        if prefix_sum - k in count:\n            result += count[prefix_sum - k]\n        count[prefix_sum] = count.get(prefix_sum, 0) + 1\n\n    return result", "from typing import List\n\ndef dfs(u, p, adj, price, dp):\n    dp[u] = [[price[u], 0], [price[u], 0]]\n\n    for v in adj[u]:\n        if v == p:\n            continue\n        dfs(v, u, adj, price, dp)\n        tmpF = sorted([dp[v][0][0] + price[u] - dp[v][1][0], dp[v][0][1]])\n        tmpS = sorted([dp[v][1][0] + price[u] - dp[v][0][0], dp[v][1][1]])\n\n        dp[u][0] = tmpF\n        dp[u][1] = tmpS\n\ndef getMaxCost(n: int, edges: List[List[int]], price: List[int]) -> int:\n    adj = [[] for _ in range(n)]\n    dp = [None] * n\n\n    for e in edges:\n        adj[e[0]].append(e[1])\n        adj[e[1]].append(e[0])\n\n    dfs(0, -1, adj, price, dp)\n\n    ans = 0\n    for i in range(n):\n        ans = max(ans, dp[i][0][1] - dp[i][1][1])\n\n    return ans", "def numberOfGoodSubsequences(s: str) -> int:\n    count = [0] * 26\n    ans = 0\n    MOD = 1000000007\n    \n    for c in s:\n        count[ord(c) - ord('a')] += 1\n        \n    for val in count:\n        ans = (ans + (1 << val) - 1) % MOD\n        \n    return ans", "def min_common_number(nums1, nums2):\n    i, j = 0, 0\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] == nums2[j]:\n            return nums1[i]\n        elif nums1[i] < nums2[j]:\n            i += 1\n        else:\n            j += 1\n    return -1", "def min_changes(nums1, nums2, k):\n    n = len(nums1)\n    operations = 0\n    for i in range(n):\n        diff = abs(nums1[i] - nums2[i])\n        if diff % k != 0:\n            return -1\n        operations += diff // k\n    return operations", "def maxScore(nums1, nums2, k):\n    n = len(nums1)\n    res = 0\n    sum_n1 = 0\n    min_n2 = nums2[0]\n    i, j = 0, 0\n    while j < n:\n        sum_n1 += nums1[j]\n        min_n2 = min(min_n2, nums2[j])\n        if j - i + 1 > k:\n            sum_n1 -= nums1[i]\n            i += 1\n        if j + 1 >= k:\n            res = max(res, sum_n1 * min_n2)\n        j += 1\n    return res", "def canReach(targetX, targetY):\n    while targetX > 1 and targetY > 1:\n        if targetX < targetY:\n            targetX, targetY = targetY, targetX\n        targetX -= targetY\n    return targetX == 1 or targetY == 1", "def sum_of_digits(n: int) -> int:\n    total = 0\n    positive = True\n\n    while n > 0:\n        digit = n % 10\n        n //= 10\n\n        if positive:\n            total += digit\n        else:\n            total -= digit\n\n        positive = not positive\n\n    return total", "def sort_students(score, k):\n    score.sort(key=lambda x: x[k], reverse=True)\n    return score", "def can_make_equal(s: str, target: str) -> bool:\n    s_count_ones = s.count('1')\n    target_count_ones = target.count('1')\n    return s_count_ones >= target_count_ones", "def minCost(nums: List[int], k: int) -> int:\n    n = len(nums)\n    count = [0] * 1001\n    dp = [0] * (n + 1)\n\n    i = 0\n    for j in range(n):\n        count[nums[j]] += 1\n        \n        if count[nums[j]] == 2:\n            dp[j + 1] = dp[i] + k + (j - i + 1)\n        elif count[nums[j]] > 2:\n            dp[j + 1] = min(dp[j], dp[j - 1] + 1)\n        else:\n            dp[j + 1] = dp[j] + 1\n\n        while i <= j and count[nums[i]] >= 2:\n            count[nums[i]] -= 1\n            i += 1\n\n    return dp[n] + n * k", "def maxValue(items, capacity):\n    items.sort(key=lambda x: x[0] / x[1], reverse=True)\n\n    maxTotalPrice = 0\n    for item in items:\n        if capacity >= item[1]:\n            capacity -= item[1]\n            maxTotalPrice += item[0]\n        else:\n            maxTotalPrice += item[0] * capacity / item[1]\n            break\n\n    return maxTotalPrice", "def distinct_numbers(n):\n    return n - 1", "def ways_to_collide(n):\n    MOD = 10**9 + 7\n    return (pow(2, n, MOD) - n - 1 + MOD) % MOD", "def maximize_score(weights, k):\n    n = len(weights)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + weights[i]\n\n    dp = [[-1000000000] * (k + 1) for _ in range(n)]\n\n    for i in range(n):\n        dp[i][1] = prefix_sum[i + 1]\n        if i > 0:\n            dp[i][i + 1] = prefix_sum[i + 1] - prefix_sum[1]\n        for j in range(2, min(i + 1, k) + 1):\n            for q in range(1, i - j + 3):\n                dp[i][j] = max(dp[i][j], dp[i - q][j - 1] + weights[i] + weights[i - q])\n\n    return dp[n - 1][k] - dp[n - 1][1]", "def separate_digits(nums):\n    answer = []\n    for num in nums:\n        digits = [int(d) for d in str(num)]\n        answer.extend(digits)\n    return answer", "def max_chosen_integers(banned, n, max_sum):\n    banned_set = set(banned)\n    count = 0\n    total_sum = 0\n    for i in range(n, 0, -1):\n        if i not in banned_set and max_sum - total_sum >= i:\n            total_sum += i\n            count += 1\n    return count", "from bisect import bisect_left, bisect_right\n\ndef max_prizes(prize_positions, k):\n    n = len(prize_positions)\n    ans = 0\n    for i in range(n):\n        left_segment_end = prize_positions[i] + k\n        right_segment_start = bisect_right(prize_positions, left_segment_end)\n        right_segment_end = prize_positions[right_segment_start] + k\n        ans = max(ans, bisect_right(prize_positions, right_segment_end) - bisect_left(prize_positions, prize_positions[i]))\n    return ans", "def canReach(grid, row, col):\n    if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] == 0:\n        return False\n\n    if row == len(grid) - 1 and col == len(grid[0]) - 1:\n        return True\n\n    grid[row][col] = 0\n\n    return canReach(grid, row + 1, col) or canReach(grid, row, col + 1)\n\ndef canDisconnect(grid):\n    reachableCount = 0\n\n    for row in range(1, len(grid)):\n        for col in range(1, len(grid[0])):\n            if grid[row][col] == 1 and (canReach(grid, row - 1, col) or canReach(grid, row, col - 1)):\n                reachableCount += 1\n                if reachableCount > 1:\n                    return True\n\n    return reachableCount <= 1", "def max_chosen_integers(banned, n, max_sum):\n    banned_set = set(banned)\n    chosen_integers = 0\n    chosen_sum = 0\n\n    for i in range(n, 0, -1):\n        if i not in banned_set and chosen_sum < max_sum:\n            if chosen_sum + i <= max_sum:\n                chosen_sum += i\n                chosen_integers += 1\n            else:\n                break\n\n    return chosen_integers", "import math\n\ndef giftsRemaining(gifts, k):\n    for i in range(k):\n        gifts.sort()\n        max_index = len(gifts) - 1\n        gifts[max_index] -= int(math.sqrt(gifts[max_index]))\n    return sum(gifts)", "def is_vowel(c: str) -> bool:\n    return c in \"aeiou\"\n\ndef count_vowel_strings(words: List[str], queries: List[List[int]]) -> List[int]:\n    ans = []\n    for query in queries:\n        count = 0\n        for i in range(query[0], query[1] + 1):\n            if is_vowel(words[i][0]) and is_vowel(words[i][-1]):\n                count += 1\n        ans.append(count)\n    return ans", "def minimumCapability(nums, k):\n    n, l, r = len(nums), 1, 10**9\n    while l < r:\n        mid = l + (r - l) // 2\n        i, cnt = 0, 0\n        for j in range(n):\n            if nums[j] <= mid:\n                cnt += 1\n                i = j + 2\n                while i + 1 < n and (i == j + 1 or nums[i] > mid):\n                    i += 1\n        if cnt < k:\n            l = mid + 1\n        else:\n            r = mid\n    return l", "def min_cost_to_equal_baskets(basket1, basket2):\n    diff_count = {}\n    for i in range(len(basket1)):\n        diff = basket1[i] - basket2[i]\n        diff_count[diff] = diff_count.get(diff, 0) + 1\n\n    min_cost = float('inf')\n    for diff, count in diff_count.items():\n        if count == diff_count.get(-diff, 0):\n            cost = sum(min(basket1[i], basket2[i]) for i in range(len(basket1)) if basket1[i] - basket2[i] == diff)\n            min_cost = min(min_cost, cost)\n\n    return -1 if min_cost == float('inf') else min_cost // 2", "def concatenationValue(nums):\n    value = 0\n    while nums:\n        n = len(nums)\n        if n == 1:\n            value += nums[0]\n            nums.pop()\n        else:\n            value += int(str(nums[0]) + str(nums[-1]))\n            nums.pop(0)\n            nums.pop()\n    return value", "def count_fair_pairs(nums, lower, upper):\n    n = len(nums)\n    fair_pairs = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if lower <= nums[i] + nums[j] <= upper:\n                fair_pairs += 1\n    return fair_pairs", "from math import log2\ndef shortestSubstringQueries(s, queries):\n    n = len(s)\n    dp = {}\n    val = 0\n    mask = 0\n\n    for i in range(n):\n        mask |= 1 << int(s[i])\n        val = (val << 1) | int(s[i])\n\n        for j in range(10):\n            if i + 1 - (1 << j) >= 0:\n                newVal = val & ((1 << (j + 1)) - 1)\n                if newVal not in dp:\n                    dp[newVal] = i + 1 - (1 << j)\n\n    ans = []\n    for query in queries:\n        target = query[0] ^ query[1]\n        if target in dp:\n            ans.append([dp[target], dp[target] + int(log2(target))])\n        else:\n            ans.append([-1, -1])\n\n    return ans", "def minScore(s, t):\n    m, n = len(s), len(t)\n    dp = [[1e6]*(n+1) for _ in range(m+1)]\n    dp[0][0] = 0\n    for i in range(m):\n        for j in range(n):\n            if s[i] == t[j]:\n                dp[i+1][j+1] = min(dp[i+1][j+1], dp[i][j])\n            else:\n                dp[i+1][j] = min(dp[i+1][j], dp[i][j] + 1)\n    ans = 1e6\n    for i in range(m):\n        ans = min(ans, dp[i+1][n])\n    return int(ans)", "def diffMaxMin(num):\n    max_remap = 1\n    min_remap = 9\n    num_str = str(num)\n    \n    for c in num_str:\n        digit = int(c)\n        max_remap = max(max_remap, 9 - digit)\n        if digit != 0:\n            min_remap = min(min_remap, digit)\n\n    max_value = num + max_remap * (len(num_str) - num_str.count(str(9 - max_remap)))\n    min_value = num - min_remap * num_str.count(str(min_remap))\n    return max_value - min_value", "def min_score_after_change(nums):\n    n = len(nums)\n    first_min, second_min, last_max, second_last_max = nums[0], nums[1], nums[-1], nums[-2]\n\n    for i in range(1, n - 1):\n        first_min = min(first_min, nums[i])\n        second_min = min(second_min, nums[i + 1])\n        last_max = max(last_max, nums[i])\n        second_last_max = max(second_last_max, nums[i - 1])\n\n    low = min(min(first_min, last_max), min(second_min, second_last_max))\n    high = max(max(first_min, last_max), max(second_min, second_last_max))\n\n    return high - low", "def min_non_expressible_integer(nums):\n    result = 1\n    nums.sort()\n    for num in nums:\n        if num > result:\n            break\n        result += num\n    return result", "def solve(nums1, nums2, queries):\n    res = []\n    for q in queries:\n        if q[0] == 1:\n            for i in range(q[1], q[2] + 1):\n                nums1[i] ^= 1\n        elif q[0] == 2:\n            for i in range(len(nums1)):\n                nums2[i] += nums1[i] * q[1]\n        elif q[0] == 3:\n            res.append(sum(nums2))\n    return res", "def merge_nums(nums1, nums2):\n    merged_map = {}\n    merged = []\n\n    for id_val_pair in nums1:\n        id_, val_ = id_val_pair\n        if id_ not in merged_map:\n            merged_map[id_] = val_\n        else:\n            merged_map[id_] += val_\n\n    for id_val_pair in nums2:\n        id_, val_ = id_val_pair\n        if id_ not in merged_map:\n            merged_map[id_] = val_\n        else:\n            merged_map[id_] += val_\n\n    for id_, val_ in merged_map.items():\n        merged.append([id_, val_])\n    \n    return merged", "def minOperations(n: int) -> int:\n    operations = 0\n    while n:\n        operations += n % 2\n        n //= 2\n    return operations", "def countSquareFreeSubsets(nums):\n    from collections import Counter\n    counter = Counter(nums)\n    MOD = 10**9 + 7\n\n    dp = [[0] * 1001 for _ in range(61)]\n    dp[0][0] = 1\n    idx = 0\n    for num, freq in counter.items():\n        idx += 1\n        for sq in range(61):\n            for ns in range(1001 - freq):\n                dp[idx][ns + freq] += dp[idx - 1][ns] * ((1 << freq) - 1) % MOD\n                dp[idx][ns + freq] %= MOD\n                dp[idx][ns] += dp[idx - 1][ns]\n                dp[idx][ns] %= MOD\n\n                if (sq // num) % 2 == 1:\n                    dp[idx][ns + freq] -= dp[idx - 1][ns] * ((1 << (freq - 1)) - 1) % MOD\n                    if dp[idx][ns + freq] < 0:\n                        dp[idx][ns + freq] += MOD\n    return dp[idx][0]", "def smallestWordForLCP(lcp):\n    n = len(lcp)\n    word = ['a'] * n\n    for i in range(1, n):\n        for j in range(1, n):\n            if lcp[i][j] > min(lcp[i - 1][j], lcp[i][j - 1]):\n                word[i + lcp[i][j] - 1] = max(word[i + lcp[i][j] - 1], chr(ord(word[i - 1]) + 1))\n            elif lcp[i][j] < min(lcp[i - 1][j], lcp[i][j - 1]):\n                return \"\"\n    return \"\".join(word)", "def get_answer(nums):\n    n = len(nums)\n    left_sum, right_sum, answer = [0] * n, [0] * n, [0] * n\n\n    for i in range(1, n):\n        left_sum[i] = left_sum[i - 1] + nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_sum[i] = right_sum[i + 1] + nums[i + 1]\n\n    for i in range(n):\n        answer[i] = abs(left_sum[i] - right_sum[i])\n\n    return answer", "def divisibility_array(word: str, m: int) -> list[int]:\n    div = []\n    value = 0\n    for c in word:\n        value = (value * 10 + int(c)) % m\n        div.append(1 if value == 0 else 0)\n    return div", "from collections import deque\n\ndef minTime(grid: list[list[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    visited = [[1000000] * n for _ in range(m)]\n\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n\n    visited[0][0] = 0\n\n    q = deque([(0, 0)])\n\n    while q:\n        x, y = q.popleft()\n\n        for i in range(4):\n            nx, ny = x + dx[i], y + dy[i]\n\n            if 0 <= nx < m and 0 <= ny < n:\n                t = max(grid[nx][ny], visited[x][y] + 1)\n                if visited[nx][ny] > t:\n                    visited[nx][ny] = t\n                    q.append((nx, ny))\n\n    return visited[m - 1][n - 1] if visited[m - 1][n - 1] != 1000000 else -1", "def min_sum_of_two_numbers(num: str) -> int:\n    cnt = [0] * 10\n    for c in num:\n        cnt[int(c)] += 1\n\n    num1, num2 = 0, 0\n    for i in range(1, 10, 2):\n        temp = cnt[i]\n        while temp > 0:\n            num1 = num1 * 10 + i\n            temp -= 1\n    for i in range(0, 10, 2):\n        temp = cnt[i]\n        while temp > 0:\n            num2 = num2 * 10 + i\n            temp -= 1\n    return num1 + num2", "def number_of_colored_cells(n):\n    return n * n + (n - 1) * (n - 1)", "def total_ways_to_split_ranges(ranges):\n    MOD = 10**9 + 7\n    ranges.sort(key=lambda x: x[1])\n    overlapping, non_overlapping, prev_end = 0, 1, -1\n\n    for start, end in ranges:\n        if start <= prev_end:\n            overlapping += 1\n        else:\n            non_overlapping += 1\n        prev_end = max(prev_end, end)\n\n    result = 1\n    for i in range(1, overlapping + 1):\n        result = (result * 2) % MOD\n\n    return result", "def possibleRoots(edges, guesses, k):\n    n = len(edges) + 1\n    in_degree = [0] * n\n    guess_parents = set()\n    \n    for guess in guesses:\n        guess_parents.add(guess[0])\n    \n    for edge in edges:\n        in_degree[edge[1]] += 1\n    \n    possible_roots = 0\n    for i in range(n):\n        if in_degree[i] == 0:\n            if k == 0 or i in guess_parents:\n                possible_roots += 1\n        elif in_degree[i] == 1 and len(guesses) - k < in_degree[i]:\n            possible_roots += 1\n    \n    return possible_roots", "def pillowHolder(n, time):\n    time %= (2 * n - 2)\n    if time <= n - 1:\n        return time + 1\n    else:\n        return 2 * n - time - 1", "from queue import Queue\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef kthLargestLevelSum(root, k):\n    level_sums = []\n    q = Queue()\n    q.put(root)\n\n    while not q.empty():\n        level_sum = 0\n        level_size = q.qsize()\n        for i in range(level_size):\n            node = q.get()\n            level_sum += node.val\n\n            if node.left:\n                q.put(node.left)\n            if node.right:\n                q.put(node.right)\n\n        level_sums.append(level_sum)\n\n    level_sums.sort(reverse=True)\n    return level_sums[k-1] if k <= len(level_sums) else -1", "def find_valid_split(nums):\n    n = len(nums)\n    prefix = [0] * n\n    suffix = [0] * n\n\n    prefix[0] = nums[0]\n    suffix[-1] = nums[-1]\n\n    for i in range(1, n):\n        prefix[i] = prefix[i - 1] * nums[i]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = suffix[i + 1] * nums[i]\n\n    for i in range(n - 1):\n        if gcd(prefix[i], suffix[i + 1]) == 1:\n            return i\n\n    return -1\n\ndef gcd(a, b):\n    return a if b == 0 else gcd(b, a % b)", "def numberOfWays(target, types):\n    MOD = 10**9 + 7\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    for count, marks in types:\n        dptmp = [0] * (target + 1)\n        for i in range(target + 1):\n            for j in range(count + 1):\n                if j * marks + i <= target:\n                    dptmp[i + j * marks] = (dptmp[i + j * marks] + dp[i]) % MOD\n        dp = dptmp\n    return dp[target]", "def is_vowel(c):\n  return c in 'aeiou'\n\ndef count_vowel_strings(words, left, right):\n  count = 0\n  for i in range(left, right + 1):\n    if is_vowel(words[i][0]) and is_vowel(words[i][-1]):\n      count += 1\n  return count", "def maxScore(nums: List[int]) -> int:\n    nums.sort()\n    result, prefixSum = 0, 0\n    for i in range(len(nums)):\n        if prefixSum + nums[i] > 0:\n            result += 1\n            prefixSum += nums[i]\n    return result", "def beautifulSubarrays(nums):\n    odd = [0] * 20\n    even = [0] * 20\n    even[0] = 1\n\n    for num in nums:\n        parity = bin(num).count('1') % 2\n        for i in range(19, -1, -1):\n            mask = 1 << i\n            if num & mask:\n                if parity:\n                    odd[i], even[i] = even[i], odd[i]\n                odd[i] += 1\n            else:\n                if not parity:\n                    odd[i], even[i] = even[i], odd[i]\n                even[i] += 1\n            num -= num & mask\n\n    ans = 0\n    for i in range(20):\n        ans += even[i] * (even[i] - 1) // 2\n    return ans", "def min_time_on(tasks):\n    intervals = sorted([[task[1] + 1, task[2]] for task in tasks])\n\n    dp = [0] * 2001\n    for interval in intervals:\n        for i in range(2000, interval[0] - 1, -1):\n            dp[i] = max(dp[i], dp[i - interval[1]] + interval[1])\n\n    return dp[-1]", "from typing import List\n\nclass Task:\n    def __init__(self, id: int, description: str, due_date: int, tags: List[str]):\n        self.id = id\n        self.description = description\n        self.due_date = due_date\n        self.tags = tags\n        self.completed = False\n\nclass TodoList:\n\n    def __init__(self):\n        self.task_id = 1\n        self.tasks = {}\n\n    def addTask(self, userId: int, taskDescription: str, dueDate: int, tags: List[str]) -> int:\n        if userId not in self.tasks:\n            self.tasks[userId] = []\n        self.tasks[userId].append(Task(self.task_id, taskDescription, dueDate, tags))\n        self.task_id += 1\n        return self.task_id - 1\n\n    def getAllTasks(self, userId: int) -> List[str]:\n        if userId not in self.tasks:\n            return []\n        user_tasks = sorted(self.tasks[userId], key=lambda task: task.due_date)\n        res = [task.description for task in user_tasks if not task.completed]\n        return res\n\n    def getTasksForTag(self, userId: int, tag: str) -> List[str]:\n        if userId not in self.tasks:\n            return []\n        user_tasks = sorted(self.tasks[userId], key=lambda task: task.due_date)\n        res = [task.description for task in user_tasks if not task.completed and tag in task.tags]\n        return res\n\n    def completeTask(self, userId: int, taskId: int) -> None:\n        if userId not in self.tasks:\n            return\n        for task in self.tasks[userId]:\n            if task.id == taskId:\n                task.completed = True\n                break", "def maximum_children_with_eight_dollars(money, children):\n    if money < children * 1 or money > children * 8:\n        return -1\n    max_eights = (money - children) // 7\n    return children if max_eights >= children else max_eights", "def max_greatness(nums):\n    nums.sort()\n    greatness = 0\n    for i in range(1, len(nums)):\n        if nums[i - 1] < nums[i]:\n            nums[i - 1], nums[i] = nums[i], nums[i - 1]\n            greatness += 1\n    return greatness", "def calculate_score(nums):\n    n = len(nums)\n    dp = [0] * (n + 2)\n\n    for i in range(n):\n        dp[i + 2] = max(dp[i + 1], dp[i] + nums[i])\n\n    return dp[n + 1]", "def min_time_to_repair(ranks, cars):\n    ranks.sort()\n    low, high = 0, 100 * cars * cars\n    \n    while low < high:\n        mid = low + (high - low) // 2\n        total_cars_repaired = 0\n        for rank in ranks:\n            cars_repaired = min(cars, mid // (rank * rank))\n            total_cars_repaired += cars_repaired\n            if total_cars_repaired >= cars:\n                break\n        if total_cars_repaired >= cars:\n            high = mid\n        else:\n            low = mid + 1\n            \n    return low", "def even_odd_indices(n: int) -> List[int]:\n    answer = [0, 0]\n    index = 0\n    while n > 0:\n        if n % 2:\n            answer[index % 2] += 1\n        n //= 2\n        index += 1\n    return answer", "def isValidMove(i, j, k, n):\n    return (i + 1 < n and j + 2 < n and k == n * (i + 1) + (j + 2)) or \\\n           (i + 1 < n and j - 2 >= 0 and k == n * (i + 1) + (j - 2)) or \\\n           (i + 2 < n and j + 1 < n and k == n * (i + 2) + (j + 1)) or \\\n           (i + 2 < n and j - 1 >= 0 and k == n * (i + 2) + (j - 1))\n\ndef validPath(grid):\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            k = grid[i][j]\n            if k != n * n - 1 and not isValidMove(i, j, k + 1, n):\n                return False\n    return True", "def countBeautifulSubsets(nums, k):\n    nums.sort()\n    ans = 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        l = r = 0\n        for j in range(i):\n            while l < j and nums[j] - nums[l] >= k:\n                l += 1\n            while r + 1 < j and nums[r + 1] - nums[j] < k:\n                r += 1\n            dp[j] -= dp[l - 1] if l <= r else 0\n            dp[j] += dp[j - 1] + 1\n            ans += dp[j]\n    return ans", "def maximum_mex(nums: List[int], value: int) -> int:\n    st = set(nums)\n\n    for i in range(100001):\n        if i not in st:\n            st.add(i + value)\n\n    mex = 0\n    while mex in st:\n        mex += 1\n    \n    return mex", "def min_operations(nums):\n    min_prefix = 0\n    prefix = 0\n    for num in nums:\n        prefix += num\n        min_prefix = min(min_prefix, prefix)\n    return -min_prefix if min_prefix < 0 else 0", "def max_sum(numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\n    max_sum = 0\n    for i in range(k + 1):\n        ones = min(i, numOnes)\n        neg_ones = min(k - i, numNegOnes)\n        max_sum = max(max_sum, ones - neg_ones)\n    return max_sum", "def strictlyIncreasingArray(nums):\n    for i in range(len(nums) - 1):\n        nums[i] -= i\n        if nums[i] >= nums[i + 1]:\n            return False\n    return True", "from typing import List\n\ndef min_operations(nums: List[int], queries: List[int]) -> List[int]:\n    answer = []\n    for query in queries:\n        operations = 0\n        for num in nums:\n            operations += abs(num - query)\n        answer.append(operations)\n    return answer", "from collections import defaultdict\n\ndef min_edges_to_collect_coins(coins, edges):\n    adj = defaultdict(list)\n    for a, b in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    return dfs(adj, coins, 0, -1)[1] // 2\n\ndef dfs(adj, coins, node, parent):\n    sum_coins = coins[node]\n    distance = 0\n    for neighbor in adj[node]:\n        if neighbor != parent:\n            result = dfs(adj, coins, neighbor, node)\n            sum_coins += result[0]\n            distance += 2 * result[0] + result[1]\n    return (sum_coins, distance)", "def min_time_to_eat_grains(hens, grains):\n    hens.sort()\n    grains.sort()\n    left, right = 0, 10**9\n\n    while left < right:\n        mid = left + (right - left) // 2\n        can_eat = True\n        i = 0\n\n        for grain in grains:\n            if i >= len(hens):\n                can_eat = False\n                break\n\n            while i < len(hens) and hens[i] < grain - mid:\n                i += 1\n\n            if i >= len(hens) or hens[i] > grain + mid:\n                can_eat = False\n                break\n\n            i += 1\n\n        if can_eat:\n            right = mid\n        else:\n            left = mid + 1\n\n    return left", "def smallest_number_with_at_least_one_digit_from_each_array(nums1, nums2):\n    min1 = min(nums1)\n    min2 = min(nums2)\n    for num1 in nums1:\n        for num2 in nums2:\n            if num1 == num2:\n                return num1\n    return min1 * 10 + min2", "def max_value_substring(s, chars, vals):\n    values = {key: val for key, val in zip(chars, vals)}\n\n    max_cost = 0\n    cost = 0\n\n    for c in s:\n        value = values.get(c) if c in values else ord(c) - ord('a') + 1\n\n        cost = max(0, cost + value)\n        max_cost = max(max_cost, cost)\n\n    return max_cost", "def minOperations(arr: List[int], k: int) -> int:\n    n = len(arr)\n    res = float('inf')\n    prefix = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] + arr[i - 1]\n\n    for i in range(1, n - k + 2):\n        target = (prefix[i - 1] + prefix[n] - prefix[i + k - 1] + n // k - 1) // (n // k)\n        curr_cost = 0\n        for j in range(i, i + k):\n            curr_cost += abs(arr[j - 1] - target)\n        res = min(res, curr_cost)\n\n    return res", "from collections import deque\n\ndef shortest_cycle_length(n, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        \n    shortest_cycle = n + 1\n    for start in range(n):\n        dist = [n + 1] * n\n        dist[start] = 0\n        queue = deque([start])\n        \n        while queue:\n            cur = queue.popleft()\n            for neigh in graph[cur]:\n                if dist[neigh] == n + 1:\n                    dist[neigh] = dist[cur] + 1\n                    queue.append(neigh)\n                elif dist[neigh] >= dist[cur] - 1:\n                    shortest_cycle = min(shortest_cycle, dist[cur] + dist[neigh] + 1)\n                    \n    return -1 if shortest_cycle == n + 1 else shortest_cycle", "def longestBalancedSubstring(s):\n    max_len = 0\n    zeros = ones = 0\n    for c in s:\n        if c == '0':\n            zeros += 1\n        else:\n            ones += 1\n        if zeros == ones:\n            max_len = max(max_len, zeros * 2)\n        elif zeros > ones:\n            zeros = ones = 0\n    zeros = ones = 0\n    for c in reversed(s):\n        if c == '0':\n            zeros += 1\n        else:\n            ones += 1\n        if zeros == ones:\n            max_len = max(max_len, zeros * 2)\n        elif zeros < ones:\n            zeros = ones = 0\n    return max_len", "def distinct_rows_from(nums):\n    rows = []\n    \n    for num in nums:\n        inserted = False\n        for row in rows:\n            if num not in row:\n                row.add(num)\n                inserted = True\n                break\n        \n        if not inserted:\n            rows.append({num})\n\n    return [list(row) for row in rows]", "def maxPoints(reward1, reward2, k):\n    gap = sorted([(reward2[i] - reward1[i], i) for i in range(len(reward1))], reverse=True)\n    firstMousePoints = sum(reward1[gap[i][1]] for i in range(k))\n    secondMousePoints = sum(reward2[gap[i][1]] for i in range(k, len(reward1)))\n    return firstMousePoints + secondMousePoints", "def reach_position(n, p, banned, k):\n    banned_positions = set(banned)\n    ans = [0] * n\n\n    for i in range(n):\n        if i in banned_positions or i == p:\n            ans[i] = -1\n            continue\n\n        an = abs(p - i) // k\n        if abs(p - i) % k == 0 and (an & 1) == (((n - 1) & 1) ^ (k & 1)):\n            steps = an\n        else:\n            steps = -1\n\n        ans[i] = steps\n\n    ans[p] = 0\n    return ans"]